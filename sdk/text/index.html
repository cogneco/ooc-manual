<!DOCTYPE html>
<html>
	<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<title> text &middot; The OOC Manual </title>
	
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/reset.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/text.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/color.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/layout.css">
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://oocmanual.cogneco.com/apple-touch-icon-144-precomposed.png">
	<link rel="shortcut icon" href="http://oocmanual.cogneco.com/favicon.ico">
	
	<link href="" rel="alternate" type="application/rss+xml" title="The OOC Manual" />
</head>

	<body>
		<header>
  <h1><a href="http://oocmanual.cogneco.com">The OOC Manual</a></h1>
  <p></p>
</header>

		<nav>
	<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/introduction">Introduction</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language">Language</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/modules">Modules</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/values">Values</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/tuples">Tuples</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/control-structures">Control Structures</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/collections">Collections</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/functions">Functions</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/first-class-functions">First-class Functions</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/classes">Classes</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/constructors">Constructors</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/properties">Properties</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/operators">Operators</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/interfaces">Interfaces</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/covers">Covers</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/covers-vs-classes">Covers vs Classes</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/enumerations">Enumerations</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/generics">Generics</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/generics2">Generics 2</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/exceptions">Exceptions</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/preprocessor">Preprocessor</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/version-blocks">Version</a>
		
	</li>
	
</ul>


		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools">Tools</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock">Rock</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/basic">Basic Usage</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/drivers">Drivers</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/advanced">Advanced Usage</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/use-files">Use-files</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/use-files2">Use-files 2</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/gc">Garbage Collection</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/debug">Debugging</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/packaging">Packaging</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/sam">Sam</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/editors">Editors</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/troubleshooting">Troubleshooting</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk">sdk</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang">lang</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/types">types</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/string">string</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/numbers">numbers</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/iterators">iterators</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/exceptions">exception</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/memory">memory</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/structs">structs</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/io">io</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/math">math</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os">os</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/process">process</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/jobpool">jobpool</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/coro">coro</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/terminal">terminal</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/pipe">pipe</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/dynlib">dynlib</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/mmap">mmap</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/channel">channel</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/system">system</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/env">env</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/shellutils">shellutils</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/time">time</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/net">net</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/text">text</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/threading">threading</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/native">native</a>
		
	</li>
	
</ul>


		
	</li>
	
</ul>


</nav>


		<main>
			<header>
				<h1>text</h1>
			</header>
			<nav id="TableOfContents">
<ul>
<li><a href="#toc_0">The text package</a></li>
<li><a href="#toc_1">Escape sequences</a></li>
<li><a href="#toc_2">StringTokenizer</a></li>
<li><a href="#toc_3">StringTemplate</a></li>
<li><a href="#toc_4">Shell-like Lexer</a></li>
<li><a href="#toc_5">Regular Expressions</a></li>
<li><a href="#toc_6">JSON</a>
<ul>
<li><a href="#toc_7">Basic reading and writing</a></li>
<li><a href="#toc_8">A JSON generation DSL</a></li>
</ul></li>
</ul>
</nav>
			<article>
				

<h1 id="toc_0">The text package</h1>

<p>This package contains various helper classes to work with text
and JSON.</p>

<h1 id="toc_1">Escape sequences</h1>

<p>The module <code>text/EscapeSequence</code> contains a class <code>EscapeSequence</code> which defines
some methods to work with backslash escape sequences. In the real world, you probably
just need the two following methods:</p>

<p><code>escape</code> takes a string and converts all special characters to escape sequences.
In this context, special characters are:</p>

<ul>
<li>non-printable characters</li>
<li>single and double quotes</li>
<li>backslashes</li>
</ul>

<p>Use it like this:</p>

<pre><code>#!ooc
escaped := EscapeSequence escape(&quot;This is\na 'String'&quot;)
// now, `escaped` looks like this:
escaped == &quot;This is \\n a \\'String\\'&quot;
</code></pre>

<p>But that is only one half of the truth: You can additionally pass a
string of all characters that should not be escaped as the
second argument:</p>

<pre><code>#!ooc
escaped := EscapeSequence escape(&quot;This is\na 'String'&quot;, &quot;'\n&quot;)
// The method did not escape anything now.
escaped == &quot;This is\na 'String'&quot;
</code></pre>

<p><code>unescape</code> is useful if you have a string containing escape sequences
and you need a string with these sequences converted to their real character
counterparts. This method supports one-character escape sequences like
&ldquo;\n&rdquo;, &ldquo;\r&rdquo; or &ldquo;\t&rdquo;, but also hexadecimal sequences like &ldquo;\x34&rdquo;.
Usage is easy:</p>

<pre><code>#!ooc
&quot;\\x27\\163up\\t\\x62ro\\n\\x3f&quot; println()
</code></pre>

<p>which will print</p>

<pre><code>#!bash
'sup    bro
?
</code></pre>

<h1 id="toc_2">StringTokenizer</h1>

<p>Sometimes, one needs to split a string at a special character and turn
it into an array. In ooc, the <code>text/StringTokenizer</code> module adds
every desirable variation of the good old <code>split</code> method to <code>Buffer</code> and <code>String</code>,
each returning an <code>ArrayList</code>:</p>

<pre><code>#!ooc
import text/StringTokenizer
import structs/ArrayList

// split at a specific character
&quot;A|simple and stupid|example&quot; split('|')
// This creates an ArrayList:
//  [&quot;A&quot;, &quot;simple and stupid&quot;, &quot;example&quot;]

// split until a specific number of tokens is reached.
// This will produce an ArrayList like
//    [&quot;A&quot;, &quot;simple and stupid|example&quot;]
&quot;A|simple and stupid|example&quot; split('|', 2)

// There is also a function to split at delimiters longer
// than one char:
&quot;:-)A case :-)of intimidating:-)smiley abuse :-)&quot; split(&quot;:-&quot;)
// ... produces
//  [&quot;&quot;, &quot;A case &quot;, &quot;of intimidating&quot;, &quot;smiley abuse &quot;, &quot;&quot;]
</code></pre>

<h1 id="toc_3">StringTemplate</h1>

<p>The <code>io/StringTemplate</code> module adds a lightweight <code>formatTemplate</code> string interpolation
function to strings, which can be used in cases where <code>format</code> is not enough. This function
uses a hashmap to access items by value:</p>

<p>{{=&lt;% %&gt;=}}</p>

<pre><code>#!ooc
import text/StringTemplate
import structs/HashMap

values := HashMap&lt;String, String&gt; new()
values put(&quot;day&quot;, &quot;Saturday&quot;) \
      .put(&quot;weather&quot;, &quot;cloudy&quot;)

&quot;Hi! Today's {{day}}, and it is a pretty {{  weather   }} {{ day }}!&quot; formatTemplate(values) println()
</code></pre>

<p>&lt;%={{ }}=%&gt;</p>

<p>This will print:</p>

<pre><code>Hi! Today's Saturday, and it is a pretty cloudy Saturday!
</code></pre>

<p>As you can see, you can access the values by their keys, order isn&rsquo;t important
and you can interpolate one value multiple times.<br />
However, this is still pretty basic, since it does not support filters or control
structures, but this is often enough.</p>

<p>In case a key is referenced that does not exist in the hashmap, it will be
replaced by an empty string.</p>

<h1 id="toc_4">Shell-like Lexer</h1>

<p>The <code>text/Shlex</code> module implements a basic lexer for strings containing
quoted strings and backslash escape sequences. Basically, it splits an input
string into an Array, using whitespace characters as delimiters. Single and double
quotes can be used to include whitespace in the string items.</p>

<p>The public API can be accessed like this:</p>

<pre><code>#!ooc
import text/Shlex
import structs/ArrayList
Shlex split(&quot;'This is a \\'quoted\\' string'     and I \&quot;like \\x69\\x74.\&quot;&quot;)
// This produces the following ArrayList:
// [&quot;This is a 'quoted' string&quot;, &quot;and&quot;, &quot;I&quot;, &quot;like it.&quot;]
</code></pre>

<p>This can be useful to parse command-line arguments. However, be careful, since
this module was not designed with security in mind.</p>

<h1 id="toc_5">Regular Expressions</h1>

<p>The SDK provides a simple cover for the <a href="http://www.pcre.org/">Perl Compatible Regular Expressions</a>
library. Its use is pretty straightforward. First, you need to compile a regular
expression pattern, passing some options as a bitmask if you want to:</p>

<pre><code>#!ooc
import text/Regexp

pattern := Regexp compile(&quot;on (?P&lt;year&gt;[0-9]{4})-?P&lt;month&gt;[0-9]{1,2})-(?P&lt;day&gt;[0-9]{1,2})&quot;, RegexOptions CASELESS)
pattern matches(&quot;foo&quot;) // this will return null, since the pattern could not be matched

someDate := pattern matches(&quot;On 2013-08-07&quot;)
// `someDate` is now a `Match` object. You can access groups by index or by name:
someDate group(1)
someDate group(&quot;year&quot;)
// ... both return &quot;2013&quot;.
// Group zero is the whole matched string:
someDate group(0) // is &quot;On 2013-08-07&quot;

// You can also iterate over the matches. This will include
// group 0 (the whole string), though.
for(group in someDate) {
    // `group` is now a String.
}
</code></pre>

<p>For more information about the Perl regular expression syntax, take a look
at the <a href="http://perldoc.perl.org/perlre.html">Perl documentation</a>.</p>

<h1 id="toc_6">JSON</h1>

<h2 id="toc_7">Basic reading and writing</h2>

<p>The <code>text/json/</code> package contains a JSON parser and generator, written in ooc
without external dependencies, which is able to deal with basic JSON. However,
if you care about speed or compliance (especially when dealing with numbers),
you should check out <a href="https://github.com/nddrylliog/ooc-yaml">ooc-yaml</a>.</p>

<p>The JSON classes operate on nested <a href="/docs/sdk/structs/#bag-variants">HashBags and Bags</a>,
so if you parse JSON, you get some (Hash)Bags, and if you want to generate JSON, you need
to pass the data as (Hash)Bags.</p>

<p>To parse or generate JSON, you can just use the convenience <code>text/json</code> module.
Every function exists in two flavours: Normally, you need to pass the class
of your expected base value. So, for example, if you want to parse JSON like that:</p>

<pre><code>#!json
[&quot;Hi&quot;, &quot;World&quot;]
</code></pre>

<p>You need to pass <code>Bag</code> as the base value class. However, since most of the time
you will parse JSON objects that will represented by a <code>HashBag</code>, <code>HashBag</code> is
used by default if you do not pass a class explicitly.</p>

<p>Here are some examples:</p>

<pre><code>#!ooc
import text/json
import structs/HashBag

// if you have a `Reader` (to read directly from a file, for example):
import io/FileReader
myObject := JSON parse(FileReader new(&quot;package.json&quot;))

// ... and if your base value is not a JSON object:
import structs/Bag
myArray := JSON parse(FileReader new(&quot;myarray.json&quot;), Bag)

// reading directly from strings is also supported:
JSON parse(&quot;{\&quot;hello\&quot;: \&quot;world\&quot;}&quot;)
JSON parse(&quot;\&quot;just a string\&quot;&quot;, String)

// and to generate JSON, there is:
myBag := HashBag new()
myBag put(&quot;integer&quot;, 1234) \
     .put(&quot;string&quot;, &quot;Yes&quot;)

import io/FileWriter
JSON generate(FileWriter new(&quot;output.json&quot;), myBag)

myJSONString := JSON generateString(myBag)
</code></pre>

<p>When dealing with the <code>HashBag</code> class, you should take a look at its
<a href="/docs/sdk/structs/#hashbag">getPath</a> function, which will save you
a lot of typing.</p>

<h2 id="toc_8">A JSON generation DSL</h2>

<p>If you find yourself generating a lot of JSON, you might find
the <code>HashBag</code>/<code>Bag</code> objects create a lot of syntactic noise. For this
reason, the SDK contains another convenience module implementing
a small DSL for JSON generation.</p>

<pre><code>#!ooc
// Let's import the module into a namespace, since `make`
// is a bit ambiguous.
import text/json/DSL into JSON

data := JSON make(|j|
    j object(
        &quot;some-key&quot;,
            &quot;some-value&quot;,
        &quot;here comes a list&quot;,
            j array(
                1, 2, &quot;three&quot;, 4
            ),
        &quot;and a nested object&quot;,
            j object(
                &quot;true&quot;, true
            )
    )
)
data println()
</code></pre>

<p><code>make</code> creates a helper object with <code>object</code> and <code>array</code> functions and passes
it to the function you provide; using a closure is the most convenient way here.
You can use <code>object</code> to create JSON objects, passing as many key-value pairs
as you want, and <code>array</code> for JSON arrays.</p>

<p>When it&rsquo;s done, it returns the JSON data as a string.</p>

			</article>
			<footer>
				<p><span id="footer-copyright">2009-2014 Amos Wenger</span><span id="footer-license">CC BY-SA 3.0</span></p>
			</footer>
		</main>
		<footer>
  <p></p>
</footer>

	</body>
</html>
