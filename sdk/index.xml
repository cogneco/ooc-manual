<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Sdks on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/sdk/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>exception</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/exceptions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/exceptions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Exception&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Exception&lt;/code&gt; class is the super-type of anything that can be thrown
and caught.&lt;/p&gt;

&lt;p&gt;There is no special keyword for throwing exceptions in ooc - instead, the
mechanism is implemented transparently thanks to the &lt;code&gt;throw()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
e := Exception new(&amp;quot;Something bad happened&amp;quot;)
e throw()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Message&lt;/h2&gt;

&lt;p&gt;A good exception will have a descriptive message. It can be accessed
via the &lt;code&gt;message&lt;/code&gt; field of the &lt;code&gt;Exception&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  attemptSomethingRisky()
} catch (e: Exception) {
  &amp;quot;Something bad happened, and here&#39;s what: %s&amp;quot; printfln(e message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Origin&lt;/h2&gt;

&lt;p&gt;It might be useful to know which class in particular has thrown an
exception. For this purpose, the &lt;code&gt;origin&lt;/code&gt; field exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
} catch (e: Exception) {
  &amp;quot;Something went wrong, and the culprit is: %s&amp;quot; \
    printfln(e origin ? e origin name : &amp;quot;unknown&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To have a default representation of an exception, like it would be
printed as if there was no try block to catch it, use &lt;code&gt;formatMessage()&lt;/code&gt;,
or, to print it, use &lt;code&gt;print()&lt;/code&gt; directly.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Backtrace&lt;/h2&gt;

&lt;p&gt;On platforms where it is implemented (currently, Linux with the &amp;ldquo;+-rdynamic&amp;rdquo;
compiler option), a series of backtrace can be available, containing info
about each stack frame leading up to the point the exception was thrown.&lt;/p&gt;

&lt;p&gt;The backtrace can be printed with the &lt;code&gt;printBacktrace()&lt;/code&gt; method. It&amp;rsquo;ll get
printed in the default representation, for example if there is no particular
exception handler.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Custom exceptions&lt;/h2&gt;

&lt;p&gt;To add a custom exception type, simply subclass &lt;code&gt;Exception&lt;/code&gt; and provide
a constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FunnyException: class extends Exception {
  init: func {
    super(&amp;quot;Nothing happened, just thought it&#39;d be fun to interrupt the program!&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mmap</title>
      <link>http://oocmanual.cogneco.com/sdk/os/mmap</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/mmap</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/mmap module&lt;/h1&gt;

&lt;p&gt;As it stands, the &lt;code&gt;os/mmap&lt;/code&gt; module just exposes the *nix functions for memory
mapping: &lt;code&gt;mmap&lt;/code&gt;, &lt;code&gt;munmap&lt;/code&gt;, &lt;code&gt;mprotect&lt;/code&gt;, &lt;code&gt;madvise&lt;/code&gt;, &lt;code&gt;mincore&lt;/code&gt;, &lt;code&gt;minherit&lt;/code&gt;,
&lt;code&gt;msync&lt;/code&gt;, &lt;code&gt;mlock&lt;/code&gt;, and &lt;code&gt;munlock&lt;/code&gt;, along with the associated constants.&lt;/p&gt;

&lt;p&gt;It also contains prototypes / covers for the Windows equivalent,
&lt;code&gt;VirtualProtect&lt;/code&gt;, and its constants as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;This module is not a high-level or cross-platform interface and is not
documented extensively here.&lt;/p&gt;

&lt;p&gt;However, to find more information on memory mapping for various platform
see here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap on Wikipedia&lt;/a&gt; (for *nix platforms)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/windows/desktop/aa366898(v=vs.85).aspx&#34;&gt;VirtualProtect on MSDN&lt;/a&gt; (for Windows)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On a historical note, this module was originally included in the SDK as support
code for the closure implementation, which back then implied generating
bytecode at runtime and thus marking some memory regions as executable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dynlib</title>
      <link>http://oocmanual.cogneco.com/sdk/os/dynlib</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/dynlib</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Dynlib module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Dynlib&lt;/code&gt; module allows one to load dynamic libraries on all
major platforms.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s open a library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Dynlib

lib := Dynlib load(&amp;quot;libm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t need to specify the &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dynlib&lt;/code&gt;, or &lt;code&gt;.dll&lt;/code&gt; extension here, it is
set automatically by platform, although the original path will be tested first,
in case of non-standard file extension.&lt;/p&gt;

&lt;p&gt;If the lib returned is null, it wasn&amp;rsquo;t found or couldn&amp;rsquo;t be opened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
if (!lib) {
    raise(&amp;quot;Couldn&#39;t load library!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then retrieve a symbol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cosAddr := lib symbol(&amp;quot;cos&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And cast it to a more useful function. Since &lt;code&gt;Func&lt;/code&gt; is actually
a function pointer and a context, we use a cover literal, passing
null for the context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cos := (cosAddr, null) as Func (Double) -&amp;gt; Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which we can then use!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;cos(PI / 4) = %.3f&amp;quot; printfln(cos(3.14 * 0.25))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This prints &lt;code&gt;cos(PI / 4) = 0.707&lt;/code&gt;, as expected.&lt;/p&gt;

&lt;p&gt;When we&amp;rsquo;re done with the library we can just close it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
lib close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: on Windows, failing to close a library may lead to a
crash on application exit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>string</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/string</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/string</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;String&lt;/h1&gt;

&lt;p&gt;A string in ooc is a chain of bytes with no particular property.
In most cases, you&amp;rsquo;ll want to deal with UTF-8 encoded strings.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;String&lt;/code&gt; type is the full-blown ooc String - it is a pascal
string in the sense that the length is stored with it. It is
backed by the &lt;code&gt;Buffer&lt;/code&gt; type, which contains the actual bytes.&lt;/p&gt;

&lt;p&gt;Buffers are mutable, whereas Strings are immutable. Therefore,
to build up a long String from several elements, using &lt;code&gt;Buffer&lt;/code&gt;
is preferable.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h2&gt;

&lt;p&gt;The size of a String can be retrieved through the &lt;code&gt;size&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;dumb luck&amp;quot; size == 9 // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Tests&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;startsWith?&lt;/code&gt; and &lt;code&gt;endsWith?&lt;/code&gt; do exactly what they sound like.
&lt;code&gt;equals?&lt;/code&gt; tests for equality, and is aliased to the &lt;code&gt;==&lt;/code&gt; operator
and, for non-equality, the &lt;code&gt;!=&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;moonlight&amp;quot; startsWith?(&amp;quot;moon&amp;quot;) // true
&amp;quot;lightscape&amp;quot; endsWith?(&amp;quot;scape&amp;quot;) // true

&amp;quot;moon&amp;quot; == &amp;quot;moon&amp;quot; // true
&amp;quot;light&amp;quot; != &amp;quot;darkness&amp;quot; // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Indexing&lt;/h2&gt;

&lt;p&gt;One can retrieve the n-th byte with the array indexing operator, &lt;code&gt;[]&lt;/code&gt;
and an integer value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;abcdef&amp;quot;[2] // == &#39;c&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the indexes are 0-based, like arrays.&lt;/p&gt;

&lt;p&gt;To iterate through each byte of a String, a foreach can be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Let&#39;s spell!&amp;quot; println()
for (c in &amp;quot;violin&amp;quot;) {
  &amp;quot;%c, &amp;quot; printfln(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Formatting and printing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;format&lt;/code&gt; method can be used to format a string with various
elements such as integers, floats, other strings, etc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;%d&amp;quot; format(42) // == &amp;quot;42&amp;quot;
&amp;quot;%.2f&amp;quot; format(3.1567) // == &amp;quot;3.16&amp;quot;
&amp;quot;%s&amp;quot; format(&amp;quot;Hi!&amp;quot;) // == &amp;quot;Hi!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;print&lt;/code&gt; method will print a string to the standard output.
Since it is so convenient to print a string followed by a newline,
&lt;code&gt;println&lt;/code&gt; does exactly that. And since formatting is often used,
&lt;code&gt;printfln&lt;/code&gt; does formatting, then print the result followed by a newline.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Hello world!\n&amp;quot; print()
// is equivalent to:
&amp;quot;Hello world!&amp;quot; println()
// itself equivalent to:
&amp;quot;Hello %s!&amp;quot; printfln(&amp;quot;world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Concatenation&lt;/h2&gt;

&lt;p&gt;One can use the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;prepend&lt;/code&gt; methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;light&amp;quot; prepend(&amp;quot;moon&amp;quot;) // == &amp;quot;moonlight&amp;quot;
&amp;quot;storm&amp;quot; append(&amp;quot;born&amp;quot;) // == &amp;quot;stormborn&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply, the &lt;code&gt;+&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;not&amp;quot; + &amp;quot;with&amp;quot; + &amp;quot;standing&amp;quot; // == &amp;quot;notwithstanding&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Finding and replacing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;indexOf&lt;/code&gt; method returns the index of a character or string inside
a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;abcdef&amp;quot; indexOf?(&#39;c&#39;) // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;replaceAll&lt;/code&gt;, one can replace all instances of a String with
another String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// yields &amp;quot;Brother | father | lover.&amp;quot;
&amp;quot;Brother, father, lover.&amp;quot; replaceAll(&amp;quot;,&amp;quot;, &amp;quot; |&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Slicing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;substring&lt;/code&gt; method allows one to get a slice of a String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;observe&amp;quot; substring(2) // == &amp;quot;serve&amp;quot;
&amp;quot;laminate&amp;quot; substring(2, 5) // == &amp;quot;min&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, the array indexing operator, &lt;code&gt;[]&lt;/code&gt;, can be used
with a range literal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;observe&amp;quot;[2..-1] // == &amp;quot;serve&amp;quot;
&amp;quot;laminate&amp;quot;[2..5] // == &amp;quot;min&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Trimming&lt;/h2&gt;

&lt;p&gt;To get rid of extra whitespace, use the &lt;code&gt;trim&lt;/code&gt; method, or its variants,
&lt;code&gt;trimLeft&lt;/code&gt; and &lt;code&gt;trimRight&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;  Hi!  &amp;quot; trim() // = &amp;quot;Hi!&amp;quot;
&amp;quot;  Hi!  &amp;quot; trimLeft() // = &amp;quot;Hi!  &amp;quot;
&amp;quot;  Hi!  &amp;quot; trimRight() // = &amp;quot;  Hi!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They also have versions that accept which characters to trim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;[Hola.]&amp;quot; trim() // = &amp;quot;[Hola.]&amp;quot;
&amp;quot;[Hola.]&amp;quot; trim(&amp;quot;[]()&amp;quot;) // = &amp;quot;Hola.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;CString&lt;/h1&gt;

&lt;p&gt;While a pure ooc program will want to deal mostyl with &lt;code&gt;String&lt;/code&gt;s,
when dealing with C functions, one will want to convert back and forth
with &lt;code&gt;toCString()&lt;/code&gt;, which gives a &lt;code&gt;CString&lt;/code&gt;, a cover of &lt;code&gt;char*&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Conversely, converting a CString to a String can be done with &lt;code&gt;toString()&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>terminal</title>
      <link>http://oocmanual.cogneco.com/sdk/os/terminal</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/terminal</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Terminal module&lt;/h1&gt;

&lt;p&gt;Terminal is used to control the terminal output, mostly by setting colors and
attributes on there.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Colors&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Color&lt;/code&gt; enum contains colors that are possible to set on the terminal:&lt;/p&gt;

&lt;p&gt;To change the foreground color, use &lt;code&gt;setFgColor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setFgColor(Color black)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To change the background color, use &lt;code&gt;setBgColor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setBgColor(Color white)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;List of colors&lt;/h2&gt;

&lt;p&gt;Here are the colors defined in the Color enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;black&lt;/li&gt;
&lt;li&gt;red&lt;/li&gt;
&lt;li&gt;green&lt;/li&gt;
&lt;li&gt;yellow&lt;/li&gt;
&lt;li&gt;blue&lt;/li&gt;
&lt;li&gt;magenta&lt;/li&gt;
&lt;li&gt;cyan&lt;/li&gt;
&lt;li&gt;grey&lt;/li&gt;
&lt;li&gt;white&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that depending on your terminal emulator, these colors
might not map to their actual names.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Attributes&lt;/h1&gt;

&lt;p&gt;Attributes can be set using &lt;code&gt;setAttr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setAttr(Attr bright)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;List of attributes&lt;/h2&gt;

&lt;p&gt;Here are the attributes defined in the &lt;code&gt;Attr&lt;/code&gt; enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reset&lt;/li&gt;
&lt;li&gt;bright&lt;/li&gt;
&lt;li&gt;dim&lt;/li&gt;
&lt;li&gt;under&lt;/li&gt;
&lt;li&gt;blink&lt;/li&gt;
&lt;li&gt;reverse&lt;/li&gt;
&lt;li&gt;hidden&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Resetting&lt;/h1&gt;

&lt;p&gt;Reset all color and attribute settings to default by using the
&lt;code&gt;reset&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal reset()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Cross-platform considerations&lt;/h1&gt;

&lt;p&gt;On *nix platforms, all attributes are supposed. On Windows, only
the &lt;code&gt;reset&lt;/code&gt; attribute is supported.&lt;/p&gt;

&lt;p&gt;On *nix, the &lt;code&gt;Terminal&lt;/code&gt; module outputs ANSI escape sequences to
stdout, whereas on Windows it uses the console text attribute API.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why there is no cross-platform way to transform a string
into a &amp;ldquo;colored string&amp;rdquo;, because it would make no sense on Windows.&lt;/p&gt;

&lt;p&gt;Also, on *nix, color escapes will only be outputted if stdout is
a terminal and not if it&amp;rsquo;s redirected to a file or a pipe.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>os</title>
      <link>http://oocmanual.cogneco.com/sdk/os</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os package&lt;/h1&gt;

&lt;p&gt;The os packages contains various modules pertaining to Operating System functionality such as:&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Concurrency&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;process&#34;&gt;Process&lt;/a&gt;, to launch child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;jobpool&#34;&gt;JobPool&lt;/a&gt;, to easily control a pool of child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[Coro](coro, which provides a basic coroutine implementation&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;I/O&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;terminal&#34;&gt;Terminal&lt;/a&gt;, used to control terminal text output (color, etc.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;pipe&#34;&gt;Pipe&lt;/a&gt;, to open, read from, and write to pipes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;dynlib&#34;&gt;Dynlib&lt;/a&gt;, which deals with dynamic library loading&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;mmap&#34;&gt;mmap&lt;/a&gt;, which exposes memory mapping capabilities&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;channel&#34;&gt;Channel&lt;/a&gt;, which implements channels&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;System&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;system&#34;&gt;System&lt;/a&gt;, to get information such as the number of processors,
the hostname, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;env&#34;&gt;Env&lt;/a&gt;, to deal with environment variables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;shellutils&#34;&gt;ShellUtils&lt;/a&gt;, used mostly to find executables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;time&#34;&gt;Time&lt;/a&gt;, to get the current time and date, and sleep&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>structs</title>
      <link>http://oocmanual.cogneco.com/sdk/structs</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/structs</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The structs package&lt;/h1&gt;

&lt;p&gt;A few frequently used data structures ship with the SDK.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Lists&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;structs/List&lt;/code&gt; contains the generic interface for lists, which are ordered, indexed
collections of elements of any type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list: List&amp;lt;String&amp;gt; = // something
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elements can be added to or removed from anywhere in the list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list add(&amp;quot;hi&amp;quot;) // append &amp;quot;hi&amp;quot; to the list
list add(0, &amp;quot;hoe&amp;quot;) // prepend &amp;quot;ho&amp;quot; to the list
list remove(&amp;quot;hi&amp;quot;) // remove the first element equal to &amp;quot;hi&amp;quot;
list removeAt(0) // remove the first element

list addAll(otherList) // append all elements from other list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They can also be retrieved from anywhere in the list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list get(24) == list[24] // get the 24th element
list first() // get the first element
list last() // get the last element
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number of elements in a list is available as the &lt;code&gt;size&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;There are %d elements in this list.&amp;quot; printfln(list size)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going through each element is easy as well, either using a foreach:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (elem in list) {
  elem println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or by passing a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list each(|elem|
  elem println()
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Removing all elements can be done via &lt;code&gt;clear&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list clear()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;ArrayList&lt;/h2&gt;

&lt;p&gt;An array list is backed by an array, which it grows or shrinks depending
on how many elements are in there.&lt;/p&gt;

&lt;p&gt;Removing or adding an element in the middle of an ArrayList is expensive, as
it shifts all elements after it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// constructed through successive add() calls:
a1 := ArrayList&amp;lt;Int&amp;gt; new()
a1 add(1); a1 add(2); a2 add(3)

// constructed from an array literal
a1 := [1, 2, 3] as ArrayList&amp;lt;Int&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An ArrayList can be easily converted to an array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printArray(list toArray())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;LinkedList&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;LinkedList&lt;/code&gt; is a doubly linked list, ie. each element points to the
element after it and the element before it.&lt;/p&gt;

&lt;p&gt;Unlike the ArrayList, removing or adding an element in the middle of a linked list
is inexpensive.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Maps&lt;/h1&gt;

&lt;p&gt;Maps are associative objects, ie. they associate keys to values.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;HashMap&lt;/h2&gt;

&lt;p&gt;The most oftenly used map collection is &lt;code&gt;structs/HashMap&lt;/code&gt;. It can only associate
a given key to one value. E.g. there cannot be duplicate keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map := HashMap&amp;lt;String, Int&amp;gt; new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Key-&amp;gt;value pairs are added to a HashMap using &lt;code&gt;put&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map put(&amp;quot;one&amp;quot;, 1)
map put(&amp;quot;two&amp;quot;, 2)
map put(&amp;quot;three&amp;quot;, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..and retrieved using &lt;code&gt;get&lt;/code&gt;. Key presence is tested with &lt;code&gt;containsKey?&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map get(&amp;quot;two&amp;quot;) == 2 // true
map containsKey?(&amp;quot;two&amp;quot;) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The whole point of a HashMap is that checking for presence or finding the
value corresponding to a key is faster than storing values in a list and
iterating through it entirely every time.&lt;/p&gt;

&lt;p&gt;To remove pairs, one has to specify the key:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map remove(&amp;quot;two&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A HashMap can be iterated through:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map each(|key, value|
  &amp;quot;%s =&amp;gt; %s&amp;quot; printfln(key, value)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s possible to get a list of all keys contained in a map:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map getKeys()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in a HashMap, iteration order is not guaranteed to be equivalent to
insertion order - due to the hashing done, keys might get reordered for efficiency.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;MultiMap&lt;/h2&gt;

&lt;p&gt;MultiMap is a HashMap variant that can contain multiple values for a given key.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;OrderedMultiMap&lt;/h2&gt;

&lt;p&gt;OrderedMultiMap is a MultiMap variant that will maintain the order in which keys
were inserted, for iteration.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Bag variants&lt;/h1&gt;

&lt;p&gt;In the structures presenting above, all elements must have the same type in a given
collection. Bags are different: each element can be a different type.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Cell&lt;/h2&gt;

&lt;p&gt;Actually defined in &lt;code&gt;lang/types&lt;/code&gt;, Cell can contain anything:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
intCell := Cell new(42)
stringCell := Cell new(&amp;quot;turtle&amp;quot;)
// and so on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unwrapping a cell can be done via the indexing operator &lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := cell[Int]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that unwrapping a cell with an incompatible type will throw an error.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Bag&lt;/h2&gt;

&lt;p&gt;Technically, a Bag can be seen as a list of cells, with convenience methods to
deal directly with the values contained inside the cells.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
bag := Bag new()
bag add(93) // add an Int
bag add(&amp;quot;seaside&amp;quot;) // add a String
bag add(bag) // add itself! the fun never ends.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve elements from a bag, one has to specify the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := bag get(0, Int)
title := bag get(1, String)
// and so on
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;HashBag&lt;/h2&gt;

&lt;p&gt;A HashBag maps string values to any type of value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
hash := HashBag new()
hash put(&amp;quot;number&amp;quot;, 93)
hash put(&amp;quot;title&amp;quot;, &amp;quot;seaside&amp;quot;)
hash put(&amp;quot;ourselves&amp;quot;, hash)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve elements from a &lt;code&gt;HashBag&lt;/code&gt;, one has to specify both the string key
and the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := hash get(&amp;quot;number&amp;quot;, Int)
title := hash get(&amp;quot;title&amp;quot;, String)
// etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashBags are particularly useful to represent a tree-like document, that was originally
encoded as JSON or YAML, for example.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;getPath&lt;/code&gt; method allows one to retrieve an element of a tree of &lt;code&gt;HashBag&lt;/code&gt;s and &lt;code&gt;Bag&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say the original JSON looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!json
{&amp;quot;elements&amp;quot;: {
  &amp;quot;house&amp;quot;: {},
  &amp;quot;car&amp;quot;: {
    &amp;quot;wheels&amp;quot;: [
      { &amp;quot;diameter&amp;quot;: 2 }
    ]}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One could use the following code to retrieve the diameter of the first wheel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
data: HashBag = // read from JSON
diameter := data getPath(&amp;quot;elements/car/wheels#0/diameter&amp;quot;, Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;Stacks&lt;/h1&gt;

&lt;p&gt;Stacks are list-like data structures, except their primary purpose is to have elements
pushed on top of them and popped from the top, in a LIFO (last-in, first-out) fashion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
stack := Stack&amp;lt;Int&amp;gt; new()
stack push(1). push(2). push(3)

stack pop() == 3 // true
stack pop() == 2 // also true
stack pop() == 1 // left as an exercise to the reader
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Stick&lt;/h2&gt;

&lt;p&gt;The ill-named &lt;code&gt;Stick&lt;/code&gt; data structure can be thought of as a bag stack - e.g. a Stack
that can contain any type of element.&lt;/p&gt;

&lt;p&gt;Example usage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
stick := Stick new(Float size + Object size)
stick push(1.23)
stick push(&amp;quot;Hi!&amp;quot;)

stick pop(String) == &amp;quot;Hi!&amp;quot; // true
stick pop(Float) == 1.23 // truthful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Stick&lt;/code&gt; is quite low-level - it doesn&amp;rsquo;t resize automatically, it does no
bounds checking, no type checking at all. To be used when you absolutely,
positively need to squeeze bytes together as close as possible and don&amp;rsquo;t care
about safety at all.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>native</title>
      <link>http://oocmanual.cogneco.com/sdk/native</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/native</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The native package&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;native&lt;/code&gt; package of the SDK contains nothing that should be
directly imported in a cross-platform application. It&amp;rsquo;s all platform-specific
support code for other parts of the SDK.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Windows&lt;/h2&gt;

&lt;p&gt;For example, the &lt;code&gt;native/win32&lt;/code&gt; package contains covers for types defined
in the Win32 API, along with a few error handling functions and other
things that are useful in the Win32 implementation of the SDK.&lt;/p&gt;

&lt;p&gt;Note that there exists &lt;code&gt;native&lt;/code&gt; sub packages elsewhere in the SDK, for example
in the &lt;code&gt;io&lt;/code&gt; or in the &lt;code&gt;os&lt;/code&gt; packages.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shellutils</title>
      <link>http://oocmanual.cogneco.com/sdk/os/shellutils</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/shellutils</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/ShellUtils module&lt;/h1&gt;

&lt;p&gt;The entire purpose of the &lt;code&gt;ShellUtils&lt;/code&gt; module is to find an
executable in the PATH environment variable.&lt;/p&gt;

&lt;p&gt;It can be used to implement functionality usually found in the
*nix &lt;code&gt;which&lt;/code&gt; command-line utility.&lt;/p&gt;

&lt;p&gt;For example, to know where &lt;code&gt;autoconf&lt;/code&gt; is hiding, one can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/ShellUtils
file := ShellUtils findExecutable(&amp;quot;autoconf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the executable is not found, &lt;code&gt;file&lt;/code&gt; here will be null. Otherwise,
it&amp;rsquo;ll correspond to the executable first found in the path:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match file {
    case null =&amp;gt; &amp;quot;autoconf not found&amp;quot;
    case =&amp;gt; &amp;quot;found: %s&amp;quot; format(file path)
} println()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Cross-platform&lt;/h2&gt;

&lt;p&gt;Adding the &lt;code&gt;.exe&lt;/code&gt; suffix is not necessary on Windows - it&amp;rsquo;ll be
added automatically on this platform when searching.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Crucial&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;findExecutable&lt;/code&gt; can be made to throw an exception in case an
executable is not found, instead of returning null. For this, pass
&lt;code&gt;true&lt;/code&gt; as its second argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// if we can&#39;t find make, don&#39;t even bother
make := ShellUtils findExecutable(&amp;quot;make&amp;quot;, true)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>net</title>
      <link>http://oocmanual.cogneco.com/sdk/net</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/net</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The net package&lt;/h1&gt;

&lt;p&gt;When you want to deal with TCP and UDP sockets directly, the &lt;code&gt;net&lt;/code&gt; package is
here for you.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;TCP&lt;/h1&gt;

&lt;p&gt;TCP guarantees that packets arrive eventually, and that they arrive in the
order in which they were sent.&lt;/p&gt;

&lt;p&gt;Usually, on the server side, sockets are bound to a port, and then listen.
When clients attempt to connect, they accept connections (and can later
close them if so they wish).&lt;/p&gt;

&lt;p&gt;Accepting a connection via a server socket gives a TCPSocket - so, after
a client has connected, the client and the server use the same data structure
to communicate.&lt;/p&gt;

&lt;p&gt;A Socket, like a &lt;code&gt;TCPSocket&lt;/code&gt;, has a reader / writer pair, since sockets
are bidirectional communication channels. Which means they can write data
to the writer, and read data from the reader.&lt;/p&gt;

&lt;p&gt;For more info on readers and writers, go ahead and read (heh) the documentation
on the &lt;a href=&#34;/docs/sdk/io/&#34;&gt;io package&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;ServerSocket&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s an example usage of ServerSocket serving as a makeshift HTTP
server (don&amp;rsquo;t do that, though):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import net/[ServerSocket]

socket := ServerSocket new(&amp;quot;0.0.0.0&amp;quot;, 8000)
socket listen()
&amp;quot;Listening...&amp;quot; println()

while(true) {
    conn := socket accept()
    &amp;quot;Got a connection!&amp;quot; println()

    while (conn in readLine() trim() != &amp;quot;&amp;quot;) {
      // read the request
    }

    conn out write(&amp;quot;HTTP/1.1 200 OK\r\n&amp;quot;)
    conn out write(&amp;quot;Content-Type: text/html\r\n&amp;quot;)
    conn out write(&amp;quot;\r\n&amp;quot;)
    conn out write(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;\
      Hello, from the ooc socket world!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;)
    conn out write(&amp;quot;\r\n&amp;quot;)
    conn close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t forget to call &lt;code&gt;listen()&lt;/code&gt; before trying to &lt;code&gt;accept()&lt;/code&gt; connections.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;TCPSocket&lt;/h2&gt;

&lt;p&gt;Same as the ServerSocket, but on the client side. Make requests like
that (or don&amp;rsquo;t - use a proper HTTP library):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import net/[TCPSocket]

socket := TCPSocket new(&amp;quot;ooc-lang.org&amp;quot;, 80)
socket connect()
socket out write(&amp;quot;GET / HTTP/1.1\n&amp;quot;)
socket out write(&amp;quot;Host: ooc-lang.org\n&amp;quot;)
socket out write(&amp;quot;User-Agent: An anonymous admirer\n&amp;quot;)
socket out write(&amp;quot;\n\n&amp;quot;)

line := socket in readLine()
&amp;quot;We got a response! %s&amp;quot; printfln(line)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seriously. Use a proper HTTP library. But that&amp;rsquo;s an example.&lt;/p&gt;

&lt;p&gt;Also, don&amp;rsquo;t forget to call &lt;code&gt;connect()&lt;/code&gt; before attempting to use &lt;code&gt;out&lt;/code&gt;
or &lt;code&gt;in&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;UDP&lt;/h1&gt;

&lt;p&gt;Unlike TCP, UDP is unidirectional - some sockets bind and only get to
receive, and some sockets don&amp;rsquo;t bind and can only send.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also no guarantee that anything sent over UDP ever arrives, and
order is not guaranteed either.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;UDPSocket&lt;/h2&gt;

&lt;p&gt;When you create an &lt;code&gt;UDPSocket&lt;/code&gt;, always specify a hostname (or an ip) and a port, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket := UDPSocket new(&amp;quot;localhost&amp;quot;, 5000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to receive datagrams, call bind():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket bind()

while (true) {
  buffer := socket receive(128)
  buffer toString() println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to send datagrams, just call send:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket send(&amp;quot;udp is fun&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s about it for now.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>math</title>
      <link>http://oocmanual.cogneco.com/sdk/math</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/math</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The math package&lt;/h1&gt;

&lt;p&gt;The math package piggybacks on libc for basic mathematical operations with
standard integer and floating point types.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;math&lt;/h1&gt;

&lt;p&gt;By simply importing &lt;code&gt;math&lt;/code&gt;, a most of the math functions from libc will get
imported.&lt;/p&gt;

&lt;p&gt;Often, math operations are available both in function form and in method form.
The function form would be similar to C, e.g.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
sin(2 * PI)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas the method form would be more.. object-oriented-ish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
2 pow(16)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Powers and roots&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;pow&lt;/code&gt; elevates the first argument to the power of the second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
2 pow(8) // 256
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exp&lt;/code&gt; returns the value of e (the base of natural logarithms) raised to the
power of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exp(2) // approx. 7.389
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sqrt&lt;/code&gt; returns the square root of a number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
144 sqrt() // 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cbrt&lt;/code&gt; returns the cube root of a number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
8 cbrt() // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Trigonometry&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PI&lt;/code&gt; is a constant defined in math as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
PI := 3.14159_26535_89793_23846_26433_83279
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;tan&lt;/code&gt;, are available, both in method and function form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
sin(2 * PI) // 0
cos(- (3 / 4) * PI) // -0.707, etc.
tan(PI / 4) // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As are their arc equivalents, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, their hyperbolic
variants, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, and their arc hyperbolic tandems,
&lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As for &lt;code&gt;atan2&lt;/code&gt;, straight from Wikipedia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In a variety of computer languages, the function atan2 is the arctangent
function with two arguments. The purpose of using two arguments instead of
one, is to gather information of the signs of the inputs in order to return
the appropriate quadrant of the computed angle, which is not possible for
the single-argument arctangent function.

For any real number (e.g., floating point) arguments x and y not both equal
to zero, atan2(y, x) is the angle in radians between the positive x-axis of
a plane and the point given by the coordinates (x, y) on it. The angle is
positive for counter-clockwise angles (upper half-plane, y &amp;gt; 0), and
negative for clockwise angles (lower half-plane, y &amp;lt; 0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Source: &lt;a href=&#34;http://en.wikipedia.org/wiki/Atan2&#34;&gt;http://en.wikipedia.org/wiki/Atan2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Logarithms&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;log&lt;/code&gt; function returns the natural logarithm of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
log(2) // about 0.69
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;log10&lt;/code&gt; function returns the base 10 logarithm of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
log10(4000) // about 3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Rounding and truncation&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;roundLong&lt;/code&gt; and &lt;code&gt;roundLLong&lt;/code&gt; are methods that will round to the
nearest integer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.14 round() // 3.00
4.78 roundLong() // 5
0.92 roundLLong() // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ceil&lt;/code&gt; and &lt;code&gt;floor&lt;/code&gt; methods will round to the nearest upper and lower
integer, respectively:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.14 ceil() // 4.00
8.92 floor() // 8.00
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Floating-point remainder&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;mod&lt;/code&gt; function computes the floating-point remainder of dividing x by y.
The return value is x - n * y, where n is the quotient of x / y, rounded toward
zero to an integer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12 mod(5) // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Various&lt;/h2&gt;

&lt;p&gt;To get the absolute value of a number, use &lt;code&gt;abs()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
(-4) abs() // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Random&lt;/h1&gt;

&lt;p&gt;By importing &lt;code&gt;math/Random&lt;/code&gt;, one can generate random numbers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer: neither the libc random number generator or the fast prng
exposed by math/Random are suitable for cryptographic usage. Find a library
that does it right, this was not planned for it.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When the module is loaded (probably at program start-up), the libc random
number generator will be seeded with the current time in microseconds.&lt;/p&gt;

&lt;p&gt;Then, various functions can be used to get random numbers.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;libc generator&lt;/h2&gt;

&lt;p&gt;To get any number between &lt;code&gt;INT_MIN&lt;/code&gt; and &lt;code&gt;INT_MAX&lt;/code&gt;, call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := Random random()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get any number within a range, use either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// gives a number between 0 (included) and 10 (included)
number := Random randInt(0, 10)

// gives a number between 0 (included) and 9 (included)
number = Random randRange(0, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those both have variants to get a number in a range, excluding any
number already contained in a list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get 10 unique numbers between 0 and 100
list := ArrayList&amp;lt;Int&amp;gt; new()

10 times(||
    list add(Random randInt(0, 100, list))
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pick out a random element ouf ot a list, use &lt;code&gt;choice&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get one of those 10 unique numbers we just generated:
num := Random choice(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;choice&lt;/code&gt; is generic, so it will work with lists of any
type of element.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;fast prng&lt;/h2&gt;

&lt;p&gt;Most of the methods above have a &lt;code&gt;fast&lt;/code&gt; variant, working from a PRNG (&lt;a href=&#34;http://en.wikipedia.org/wiki/Pseudorandom_number_generator&#34;&gt;pseudorandom
number generator&lt;/a&gt;) coded directly into the Random class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// all these are documented above, they work in a similar fashion
Random fastRandom()

Random fastRandInt(0, 10)
Random fastRandRange(0, 10)

Random fastRandInt(0, 10, list)
Random fastRandRange(0, 10, list)

Random fastChoice(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fast&lt;/code&gt; variants are meant to be faster, as the name implies, but they&amp;rsquo;re even
less guaranteed to have good random qualities - the numbers it generates might be
less even / repeat more easily.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>memory</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/memory</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/memory</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Memory&lt;/h1&gt;

&lt;p&gt;Sometimes, you just have to handle memory yourself. None of that class
or cover stuff, just give me a raw block of memory any day.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll see the &lt;code&gt;gc_&lt;/code&gt; prefix being used in the following page: that stands
for Garbage Collection, which is enabled by default in ooc. However, when
the GC is disabled, those will point to non-GC version of the functions.&lt;/p&gt;

&lt;p&gt;So that your code remains flexible, do yourself a favor and use the &lt;code&gt;gc_&lt;/code&gt;
variants regardless.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Allocating memory&lt;/h2&gt;

&lt;p&gt;Use &lt;code&gt;gc_malloc&lt;/code&gt; to get a chunk of memory all to yourself.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves a slice of 4 bytes
block := gc_malloc(4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, you&amp;rsquo;ll get a &lt;code&gt;Pointer&lt;/code&gt; back - which is a little bit pointless.
Plus you&amp;rsquo;ll probably want to determine how much you are allocating as
a function of the size of some other type instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves room to store 4 doubles.
doubles := gc_malloc(4 * Double size) as Double*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s better. Now you can index that, like any pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
doubles[0] = 3.14
doubles[1] = 6.28
// etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pointer arithmetic works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
addressOfSecondDouble := doubles + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then again, why not write it the explicit way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
addressOfSecondDouble := doubles[1]&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;gc_malloc&lt;/code&gt; returns zeroed memory (even when the GC is disabled),
just like the C function &lt;code&gt;calloc&lt;/code&gt; does. While a small performance hit, a
little additional safety can&amp;rsquo;t hurt.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Allocating in bulks&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;calloc&lt;/code&gt; is typically used in C to get zeroed memory (e.g. all null bytes).
This is unnecessary in ooc, since &lt;code&gt;gc_malloc&lt;/code&gt; returns zeroed memory anyway.&lt;/p&gt;

&lt;p&gt;In the rare cases where you do mean to allocate &lt;code&gt;num&lt;/code&gt; members of size &lt;code&gt;size&lt;/code&gt;,
use &lt;code&gt;gc_calloc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
members := gc_calloc(num, size)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Re-allocating memory&lt;/h2&gt;

&lt;p&gt;Didn&amp;rsquo;t get enough the first time around? Misjudged your budget needs?&lt;/p&gt;

&lt;p&gt;Fear not, &lt;code&gt;gc_realloc&lt;/code&gt; is here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves 4 bytes
block := gc_malloc(4)

// woops, make that 8
block = gc_realloc(block, 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Duplicating memory&lt;/h2&gt;

&lt;p&gt;In our family of memory-related functions, &lt;code&gt;gc_strdup&lt;/code&gt;, nostalgically
named as if it was only used with strings, is here. It&amp;rsquo;ll make a copy of
a block of memory so that the original may be disposed of.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
someCallback: func (word: CString) {
  // CString is a pointer to a memory block that will get
  // overriden sometimes after this function returns - hence,
  // we want to make a copy so that the data we got doesn&#39;t
  // get tampered with.
  storeString(String new(gc_strdup(word)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The block of code above shows the typical use case, anyway.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Freeing memory&lt;/h2&gt;

&lt;p&gt;Technically, since we are using a garbage collector, you don&amp;rsquo;t need to
free explicitly. Should you feel the need to do so, however, &lt;code&gt;gc_free&lt;/code&gt; is
here to do the job:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// you know what, I&#39;m good for now, thanks.
gc_free(block)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>channel</title>
      <link>http://oocmanual.cogneco.com/sdk/os/channel</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/channel</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Channel module&lt;/h1&gt;

&lt;p&gt;Channels are another way to think about data flow in the program.
Perhaps most famous in their Go implementation, &amp;lsquo;goroutines&amp;rsquo;, can
communicate via channels.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;os/Channel&lt;/code&gt; module contains a trivial implementation of channels
which may be used like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By importing this module, a scheduler is set to run before the program
exits. Let&amp;rsquo;s start by making a channel by which Ints can travel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
chan := make(Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then let&amp;rsquo;s make a data producer coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 0..5) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And another one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 5..10) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
    chan &amp;lt;&amp;lt; -1
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-1 will be used as a stopping signal here. &lt;code&gt;go&lt;/code&gt; create a new
coroutine, and &lt;code&gt;chan &amp;lt;&amp;lt; value&lt;/code&gt; sends a value down a channel.
&lt;code&gt;yield&lt;/code&gt; switches from the current coroutine back to the scheduler.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now make a consumer channel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    while (true) match (i := !chan) {
        case -1 =&amp;gt; break
        case =&amp;gt; &amp;quot;%d&amp;quot; printfln(i)
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re reading from the channel with the not operator: &lt;code&gt;!chan&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will print 0, 5, 1, 6, 2, 7, 3, 8, 4, 9, and then exit, as
expected.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sdk</title>
      <link>http://oocmanual.cogneco.com/sdk</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;An overview of the SDK&amp;rsquo;s packages&lt;/h1&gt;

&lt;p&gt;These pages will give you an overview of what you can find in the SDK:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;lang&#34;&gt;lang&lt;/a&gt; package is imported by default in any ooc file.
It contains essentials usable without further ado in any .ooc program.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;structs&#34;&gt;structs&lt;/a&gt; package contains useful containers like
lists and hash maps, but also stacks, and more cornercase stuff like
multimaps and bags.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;io&#34;&gt;io&lt;/a&gt; package has modules for reading files, writing
to files, and other input/output related matters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;math&#34;&gt;math&lt;/a&gt; package is the home to everything numbers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;os&#34;&gt;os&lt;/a&gt; package contains lots of goodies, from time
management to terminal handling, to launching processes, reading from
pipes, getting hardware information, manipulating environment variables,
creating a parallel job pool, and even coroutines and channels!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;net&#34;&gt;net&lt;/a&gt; package has modules for relatively low-level
network operations such as creating TCP and UDP sockets, and making DNS
requests.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;text&#34;&gt;text&lt;/a&gt; package contains a Regexp class, a JSON encoder
and decoder, a simple template engine, a string tokenizer, an option
parser, and a helper classes for escape sequences.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;threading&#34;&gt;threading&lt;/a&gt; package contains all things threads.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;native&#34;&gt;native&lt;/a&gt; package should not be imported directly -
it contains platform-specific specific implementations of certain features.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>threading</title>
      <link>http://oocmanual.cogneco.com/sdk/threading</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/threading</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The threading package&lt;/h1&gt;

&lt;p&gt;As far as concurrency goes, threads are usually lighter than processes,
but heavier than coroutines.&lt;/p&gt;

&lt;p&gt;Programming with threads is subjecting yourself to preemptive multithreading,
which means any thread might give up control to another thread (e.g. be
pre-empted) at any time.&lt;/p&gt;

&lt;p&gt;Threads also imply shared memory - a variable might be accessed by several
threads concurrently at the same time. Either seemingly, on single processor
machines, or actually in parallel, on multicore machines.&lt;/p&gt;

&lt;p&gt;For that reason, threads have a reputation to be tricky - one has to be
careful what is accessed, from where, and when. To prevent the same data
being accessed by multiple threads, one can use a mutex - but those also
tend to open other cans of worms.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Thread&lt;/h1&gt;

&lt;p&gt;The following section describes how to create threads, wait on them, and
how to wait for them to finish, or just for a little while. You&amp;rsquo;ll also
learn how to check if a thread is still alive, and how to retrieve the
current thread.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Creating, starting, and waiting&lt;/h2&gt;

&lt;p&gt;Creating a thread is as simple as calling &lt;code&gt;Thread new&lt;/code&gt; and passing a closure -
the code that will get executed in the new thread.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import threading/Thread, os/Time

thread := Thread new(||
  &amp;quot;Doing some long work...&amp;quot; println()
  Time sleepSec(2)
  &amp;quot;Done!&amp;quot; println()
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start the thread with &lt;code&gt;start()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
thread start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And wait for it to finish with &lt;code&gt;wait()&lt;/code&gt; (which will block until the
thread terminates):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Waiting for thread to finish...&amp;quot; println()
thread wait()
&amp;quot;All done!&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Check if a thread is still running&lt;/h2&gt;

&lt;p&gt;Instead of calling wait, one can poll for a thread&amp;rsquo;s existence with
&lt;code&gt;alive?()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Waiting for thread to finish...&amp;quot; println()
while (thread alive?()) {
  &amp;quot;Waiting...&amp;quot; println()
  Time sleepSec(1)
}
&amp;quot;All done!&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Timed wait&lt;/h2&gt;

&lt;p&gt;And instead of polling to see if a thread is still a live, one can
wait for the thread to terminate for a certain maximum amount of time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (!thread wait(1.0)) {
  &amp;quot;Waiting...&amp;quot; println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty much equivalent to the &lt;code&gt;alive?()&lt;/code&gt; version, except more
elegant.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Retrieve the current thread&lt;/h2&gt;

&lt;p&gt;The current thread can be retrieved with &lt;code&gt;Thread currentThread()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
thread := Thread currentThread()
match (thread alive?()) {
  case true =&amp;gt; &amp;quot;Good!&amp;quot;
  case =&amp;gt; &amp;quot;Wait, what?&amp;quot;
} println()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Yielding to other threads&lt;/h2&gt;

&lt;p&gt;In some situations it might be useful to give a hint to the operating
system&amp;rsquo;s scheduler, and let it know that the current thread is ready
to be preempted right now - and that the next thread in line can become
active now.&lt;/p&gt;

&lt;p&gt;Typically, the following code will usually print &lt;code&gt;ABCABC&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
create: func -&amp;gt; Thread {
  Thread new(||
    for (letter in &amp;quot;ABC&amp;quot;) {
      letter print()
    }
  )
}

(t1, t2) := (create(), create())
t1 start(); t2 start()
t1 wait(); t2 wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas adding &lt;code&gt;Thread yield&lt;/code&gt; in the for loop, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
create: func -&amp;gt; Thread {
  Thread new(||
    for (letter in &amp;quot;ABC&amp;quot;) {
      letter print()
      Thread yield()
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Might produce something more along the lines of &lt;code&gt;AABBCC&lt;/code&gt;. Then again,
the problem with preemptive multitasking is that it is impossible to
predict exactly what will happen, so seeing &lt;code&gt;AABCBC&lt;/code&gt;, &lt;code&gt;ABABCC&lt;/code&gt;, and even
&lt;code&gt;ABCABC&lt;/code&gt; happen are not out of the question either.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;ThreadLocal&lt;/h1&gt;

&lt;p&gt;By default, global variables are shared among all threads. To make a global
that is specific to each thread, use ThreadLocal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
val := ThreadLocal&amp;lt;Int&amp;gt; new(42)

threads := ArrayList&amp;lt;Thread&amp;gt; new()
for (i in 1..3) {
    threads add(Thread new(||
        val set(i)
    ))
}

for (t in threads) t start()
for (t in threads) t wait()

// prints val = 42
&amp;quot;val = %d&amp;quot; printfln(val get())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, val is initialized from the main application thread, then set by
three other OS threads, and yet the value is still 42 at the end of the program,
in the main thread.&lt;/p&gt;

&lt;p&gt;Inside each of these threads, though, the value is still 1 and 2 respectively.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Mutex&lt;/h1&gt;

&lt;p&gt;A mutex allows to control access to resources that are shared between threads,
to avoid two threads modifying the same resource, which could potentially result
in invalid state.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
counter := 0

threads := ArrayList&amp;lt;Thread&amp;gt; new()
for (i in 0..10) {
    threads add(Thread new(||
        for (i in 0..1000) {
            counter += 1
            Thread yield()
        }
    ))
}

for (t in threads) t start()
for (t in threads) t wait()

// prints counter = ???
&amp;quot;counter = %d&amp;quot; printfln(counter)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above has a problem - many threads may access the counter at the same time,
hence the resulting counter value isn&amp;rsquo;t reliably 10000. In actual testing, it gave
values such as 7064, 6111, 5986, etc.&lt;/p&gt;

&lt;p&gt;This happens because a thread might be reading the value of counter, then another
thread runs and increments it, then the thread who read the value sets the counter
to the value it reads plus one, resulting in &amp;ldquo;lost iterations&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To alleviate that problem, we can use a mutex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
counter := 0

mutex := Mutex new()

threads := ArrayList&amp;lt;Thread&amp;gt; new()
for (i in 0..10) {
    threads add(Thread new(||
        for (i in 0..1000) {
            mutex lock()
            counter += 1
            mutex unlock()
            Thread yield()
        }
    ))
}

for (t in threads) t start()
for (t in threads) t wait()

// prints counter = ???
&amp;quot;counter = %d&amp;quot; printfln(counter)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we have protected the counter incrementation with &lt;code&gt;mutex lock()&lt;/code&gt; and
&lt;code&gt;mutex unlock()&lt;/code&gt; calls. This is known as a critical section. In there, only one
thread can execute at a time - the other threads will block on the &lt;code&gt;lock&lt;/code&gt; call,
waiting to be able to acquire it exclusively.&lt;/p&gt;

&lt;p&gt;Instead of using &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;unlock&lt;/code&gt; by hand, one might want to use the &lt;code&gt;with&lt;/code&gt;
method, that takes a block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (i in 0..1000) {
    mutex with(||
        counter += 1
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With any of these last two versions, the counter is reliably set to 10000
at the end of every run.&lt;/p&gt;

&lt;p&gt;For more information about this problem, read the &lt;a href=&#34;http://en.wikipedia.org/wiki/Mutual_exclusion&#34;&gt;Mutual exclusion&lt;/a&gt;
Wikipedia page.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;RecursiveMutex&lt;/h1&gt;

&lt;p&gt;With a regular mutex, locking multiple times from the same thread results in
undefined behaviour on some platforms (e.g. pthreads).&lt;/p&gt;

&lt;p&gt;A recursive mutex, on the other hand, can be locked multiple times, as long
as it&amp;rsquo;s unlocked a corresponding number of times, all by the same thread.&lt;/p&gt;

&lt;p&gt;A trivial (non-useful) test might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
threads := ArrayList&amp;lt;Thread&amp;gt; new()

mutex := RecursiveMutex new()
counter := 0

for (i in 0..42) {
    threads add(Thread new(||
        for (i in 0..10) mutex lock()
        counter += 1
        for (i in 0..10) mutex unlock()
    ))
}

for (t in threads) t start()
for (t in threads) t wait()

// prints counter = 42
&amp;quot;counter = %d&amp;quot; printfln(counter)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program correctly prints &lt;code&gt;counter = 42&lt;/code&gt; at the end. If we weren&amp;rsquo;t using
a recursive mutex, more funky behaviour could happen. For example, on OSX, the
program enters an infinite waiting loop, as we are trying to lock an already
locked non-recursive mutex acquired by the current thread, resulting in a
deadlock.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>