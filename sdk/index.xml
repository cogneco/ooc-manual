<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Sdks on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/sdk/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>sdk</title>
      <link>http://oocmanual.cogneco.com/sdk/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;An overview of the SDK&amp;rsquo;s packages&lt;/h1&gt;

&lt;p&gt;These pages will give you an overview of what you can find in the SDK:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;lang&#34;&gt;lang&lt;/a&gt; package is imported by default in any ooc file.
It contains essentials usable without further ado in any .ooc program.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;structs&#34;&gt;structs&lt;/a&gt; package contains useful containers like
lists and hash maps, but also stacks, and more cornercase stuff like
multimaps and bags.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;io&#34;&gt;io&lt;/a&gt; package has modules for reading files, writing
to files, and other input/output related matters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;math&#34;&gt;math&lt;/a&gt; package is the home to everything numbers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;os&#34;&gt;os&lt;/a&gt; package contains lots of goodies, from time
management to terminal handling, to launching processes, reading from
pipes, getting hardware information, manipulating environment variables,
creating a parallel job pool, and even coroutines and channels!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;net&#34;&gt;net&lt;/a&gt; package has modules for relatively low-level
network operations such as creating TCP and UDP sockets, and making DNS
requests.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;text&#34;&gt;text&lt;/a&gt; package contains a Regexp class, a JSON encoder
and decoder, a simple template engine, a string tokenizer, an option
parser, and a helper classes for escape sequences.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;threading&#34;&gt;threading&lt;/a&gt; package contains all things threads.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;native&#34;&gt;native&lt;/a&gt; package should not be imported directly -
it contains platform-specific specific implementations of certain features.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>io</title>
      <link>http://oocmanual.cogneco.com/sdk/io/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/io/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The io package&lt;/h1&gt;

&lt;p&gt;Whether you want to read from file, write to files,
walk through directories, or build data in-memory, the
io package contains everything you need&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;File&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;io/File&lt;/code&gt; module is a good starting point to handle
files. Instanciating one with a path will allow to test for
various attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f := File new(&amp;quot;/etc/hosts&amp;quot;)

f exists?()
f dir?() // is a directory?
f file?() // is a file?
f link?() // is a symlink?

f getSize() // size in bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Paths&lt;/h2&gt;

&lt;p&gt;For paths like &lt;code&gt;/path/to/somewhere&lt;/code&gt;, &lt;code&gt;getName()&lt;/code&gt; will return
the &lt;code&gt;somewhere&lt;/code&gt; part, and &lt;code&gt;getParent&lt;/code&gt; will return an instance
of &lt;code&gt;File&lt;/code&gt; corresponding to &lt;code&gt;/path/to&lt;/code&gt;, or null if the path is
at the root of a file system.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;getReducedPath&lt;/code&gt; method will resolve paths like &lt;code&gt;a/b/../../c&lt;/code&gt;
to &lt;code&gt;c&lt;/code&gt;. It is a form of canonicalization, suitable for comparing
paths.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Basic I/O&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;copyTo&lt;/code&gt; method will copy a file to the given &lt;code&gt;dstFile&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
src := File new(&amp;quot;./conf/default.conf&amp;quot;)
dst := File new(Env get(&amp;quot;HOME&amp;quot;), &amp;quot;.myapp&amp;quot;)
src copyTo(dst)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;remove&lt;/code&gt; method will remove a file, but will fail to remove
a directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
tmpFile remove()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt; methods will read a whole file and replace the content
of a file with the given string, respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
respectify: func (file: File) {
  text := file read()
  file write(text replaceAll(&amp;quot;yes&amp;quot;, &amp;quot;yes, sir&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Walking through directories&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;getChildren&lt;/code&gt; method will return a list of &lt;code&gt;File&lt;/code&gt; instances
corresponding to the files in a directory, whereas the &lt;code&gt;getChildrenNames&lt;/code&gt;
method will return a list of strings corresponding to the name of
files in the given directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f := File new(&amp;quot;/etc&amp;quot;)
for (child in f getChildren()) {
  // child might be a file or a directory with
  // children of its own
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;walk&lt;/code&gt; method allows a recursive walk on all the children
of a given directory. When the callback returns false, the search
is terminated.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
findFile: func (prefix: String) -&amp;gt; File {
  result: File
  baseDirectory walk(|f|
    if (f startsWith?(prefix)) {
      result = f
      return false
    }
    true
  )
  result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Permissions&lt;/h2&gt;

&lt;p&gt;The methods &lt;code&gt;ownerPerm&lt;/code&gt;, &lt;code&gt;groupPerm&lt;/code&gt;, and &lt;code&gt;otherPerm&lt;/code&gt; return an int mask with
permissions.&lt;/p&gt;

&lt;p&gt;Note that using octal number literals might be a good idea to test against
that. Unlike C, &lt;code&gt;0777&lt;/code&gt; is decimal in ooc. You want to write &lt;code&gt;0c777&lt;/code&gt; instead.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Current directory&lt;/h2&gt;

&lt;p&gt;The static method &lt;code&gt;File getCwd()&lt;/code&gt; will return the current working directory on
any platform.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Reader / Writer&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;io/Reader&lt;/code&gt; and &lt;code&gt;io/Writer&lt;/code&gt; modules contains interfaces used for input/output.&lt;/p&gt;

&lt;p&gt;For files, use the &lt;code&gt;io/FileReader&lt;/code&gt; and &lt;code&gt;io/FileWriter&lt;/code&gt; implementations. To work in
memory, use the &lt;code&gt;io/BufferReader&lt;/code&gt; and &lt;code&gt;io/BufferWriter&lt;/code&gt; implementations.&lt;/p&gt;

&lt;p&gt;A reader or writer should be closed (by calling &lt;code&gt;reader close()&lt;/code&gt; or &lt;code&gt;writer close()&lt;/code&gt;)
when done with it, so that the corresponding resources may be freed.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Reader basics&lt;/h2&gt;

&lt;p&gt;Some C libraries have an interface similar to &lt;code&gt;io/Reader&lt;/code&gt;. The main I/O loop might
look like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import io/Reader

process: func (reader: Reader) {
  buffer := Buffer new(1024)

  while (reader hasNext?()) {
    bytesRead := reader read(buffer)
    // do something with buffer
  }
  reader close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A reader can also work with raw memory chunks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
onRead: func (reader: Reader, buffer: UInt8*, bufferSize: Int) {
  // fill buffer from beginning, 0 is the offset
  reader read(buffer, 0, bufferSize)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or one character at a time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match (reader read()) {
  case &#39;A&#39; =&amp;gt; &amp;quot;Good!&amp;quot;
  case &#39;F&#39; =&amp;gt; &amp;quot;Also good.&amp;quot;
  case =&amp;gt; &amp;quot;Meh.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An entire stream can be read to a String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
fr := FileReader new(&amp;quot;file.txt&amp;quot;)
contents := fr readAll()
fr close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that this would compactly be achieved by &lt;code&gt;File new(&amp;quot;file.txt&amp;quot;) read()&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;For more details, refer to the oocdocs.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Writer basics&lt;/h2&gt;

&lt;p&gt;Similarly, the writer interface works with buffers, raw memory chunks, single characters,
or strings as needed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
manipulate: func (w: Writer) {
  // char
  w write(&#39;a&#39;)

  // string
  w write(&amp;quot;abc&amp;quot;)

  // buffer
  chars := &amp;quot;moonlight&amp;quot; toCString()
  w write(chars, 4) // only writes &amp;quot;moon&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more details, refer to the oocdocs.&lt;/p&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;BinarySequence&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;io/BinarySequence&lt;/code&gt; module is meant to help deal with binary protocols, precise
on the width and endianness of types being written to a stream.&lt;/p&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;BinarySequenceReader&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// read a file as binary
file := File new(&amp;quot;assets&amp;quot;, &amp;quot;binary.dat&amp;quot;)
seq := BinarySequenceReader new(FileReader new(file))

// read an 16-bit unsigned int:
numElements := seq u16()

for (i in 0..numElements) {
  // coordinates are two floats
  x := seq float32()
  y := seq float32()
  // do something with x, y
}

// check magicn number at the end
assert (seq s32() == 0xdeadbeef)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more details, refer to the oocdocs.&lt;/p&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;BinarySequenceWriter&lt;/h2&gt;

&lt;p&gt;The corresponding module exists for writing binary sequences.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// write a binary file
file := File new(&amp;quot;assets&amp;quot;, &amp;quot;binary.dat&amp;quot;)
seq := BinarySequenceWriter new(FileWriter new(file))

seq u16(elements size)

for (elem in elements) {
  seq float32(elem x)
  seq float32(elem y)
}

seq s32(0xdeadbeef)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more details, refer to the oocdocs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>exception</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/exceptions/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/exceptions/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Exception&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Exception&lt;/code&gt; class is the super-type of anything that can be thrown
and caught.&lt;/p&gt;

&lt;p&gt;There is no special keyword for throwing exceptions in ooc - instead, the
mechanism is implemented transparently thanks to the &lt;code&gt;throw()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
e := Exception new(&amp;quot;Something bad happened&amp;quot;)
e throw()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Message&lt;/h2&gt;

&lt;p&gt;A good exception will have a descriptive message. It can be accessed
via the &lt;code&gt;message&lt;/code&gt; field of the &lt;code&gt;Exception&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  attemptSomethingRisky()
} catch (e: Exception) {
  &amp;quot;Something bad happened, and here&#39;s what: %s&amp;quot; printfln(e message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Origin&lt;/h2&gt;

&lt;p&gt;It might be useful to know which class in particular has thrown an
exception. For this purpose, the &lt;code&gt;origin&lt;/code&gt; field exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
} catch (e: Exception) {
  &amp;quot;Something went wrong, and the culprit is: %s&amp;quot; \
    printfln(e origin ? e origin name : &amp;quot;unknown&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To have a default representation of an exception, like it would be
printed as if there was no try block to catch it, use &lt;code&gt;formatMessage()&lt;/code&gt;,
or, to print it, use &lt;code&gt;print()&lt;/code&gt; directly.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Backtrace&lt;/h2&gt;

&lt;p&gt;On platforms where it is implemented (currently, Linux with the &amp;ldquo;+-rdynamic&amp;rdquo;
compiler option), a series of backtrace can be available, containing info
about each stack frame leading up to the point the exception was thrown.&lt;/p&gt;

&lt;p&gt;The backtrace can be printed with the &lt;code&gt;printBacktrace()&lt;/code&gt; method. It&amp;rsquo;ll get
printed in the default representation, for example if there is no particular
exception handler.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Custom exceptions&lt;/h2&gt;

&lt;p&gt;To add a custom exception type, simply subclass &lt;code&gt;Exception&lt;/code&gt; and provide
a constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FunnyException: class extends Exception {
  init: func {
    super(&amp;quot;Nothing happened, just thought it&#39;d be fun to interrupt the program!&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lang</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The lang package&lt;/h1&gt;

&lt;p&gt;The lang package is considered built-in: it is imported by default in ooc
modules. There is a reason for that, however - the SDK is distributed as
an ooc library itself, and as such, it has a .use file that specifies which
modules should be imported.&lt;/p&gt;

&lt;p&gt;Some of the lang package is essential, like &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Class&lt;/code&gt;, which
means that the compiler, &lt;a href=&#34;../tools/rock/&#34;&gt;rock&lt;/a&gt;, will expect them to be present,
have certain names, fields and methods. However, using a custom sdk is
possible, where the implementation for these can be swapped to something
lighter, for example.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;types&#34;&gt;Types&lt;/a&gt; section describes how Object,
 Class, and other types such as Void, Pointer, Bool, None,
 Cell are defined. It also discusses variable arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;string&#34;&gt;String&lt;/a&gt; section talks about string
 handling, the mutable variant Buffer, and formatting&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;numbers&#34;&gt;Numbers&lt;/a&gt; section talks about number
 types, either integers or floats, and the various functions available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;iterators&#34;&gt;Iterators&lt;/a&gt; section discusses
 how iterators are implemented, and what goes on behind a foreach.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;exceptions&#34;&gt;Exceptions&lt;/a&gt; section talks about
 default properties of exceptions, and how to extend them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;memory&#34;&gt;Memory&lt;/a&gt; section talks about memory
 management, mostly just how to deal with blocks of memory rather
 than more high-level data structures.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>iterators</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/iterators/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/iterators/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Iterators&lt;/h1&gt;

&lt;p&gt;Iterators are the magic that makes foreach loops work.&lt;/p&gt;

&lt;p&gt;The basic premise is that to iterate through something, you have to
be able to know if there&amp;rsquo;s anything left, via &lt;code&gt;hasNext?&lt;/code&gt;, and to
retrieve the next element, via &lt;code&gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a bonus, for safe iteration, the &lt;code&gt;remove&lt;/code&gt; method may be implemented.
If it isn&amp;rsquo;t, though, it will return false.&lt;/p&gt;

&lt;p&gt;Since iterators may iterate on all kinds of data structures, they are
generic, ie. &lt;code&gt;next&lt;/code&gt; will return a T.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a demonstration, iterating through characters of the word &lt;code&gt;hellfire&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
HellfireIterator: class extends Iterator&amp;lt;Char&amp;gt; {
    content := &amp;quot;hellfire&amp;quot;
    index := 0

    init: func

    hasNext?: func -&amp;gt; Bool {
      index &amp;lt; content size
    }

    next: func -&amp;gt; Char {
      val := content[index]
      index += 1
      val
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a foreach to work, one has to have an iterable type. Thankfully,
an &lt;code&gt;Iterator&lt;/code&gt; itself extends &lt;code&gt;Iterable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (letter in HellfireIterator new()) {
  &amp;quot;%c&amp;quot; printfln(letter)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;each and eachUntil&lt;/h2&gt;

&lt;p&gt;Apart from using foreach loops, one can use the each method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
HellfireIterator new() each(|letter|
  // do something with letter
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the eachUntil, which will break if the passed closure returns false:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
HellfireIterator new() eachUntil(|letter|
  if (letter == &#39;f&#39;) {
    return false // just hell, please
  }

  // do something with letter
  true
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;reduce&lt;/h2&gt;

&lt;p&gt;An iterable can be reduced using the &lt;code&gt;reduce&lt;/code&gt; method, accepting a
closure. It&amp;rsquo;ll get called on each pair of two elements, until there
is only one element left.&lt;/p&gt;

&lt;p&gt;Example with a list of ints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list := [1, 2, 3] as ArrayList&amp;lt;Int&amp;gt;
sum := list reduce(|a, b| a + b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;toList&lt;/h2&gt;

&lt;p&gt;Any &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; can be transformed to a &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; via the &lt;code&gt;toList&lt;/code&gt;
method. Let&amp;rsquo;s try it on a string, which is iterable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;ABC&amp;quot; toList() // gives [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>memory</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/memory/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/memory/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Memory&lt;/h1&gt;

&lt;p&gt;Sometimes, you just have to handle memory yourself. None of that class
or cover stuff, just give me a raw block of memory any day.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll see the &lt;code&gt;gc_&lt;/code&gt; prefix being used in the following page: that stands
for Garbage Collection, which is enabled by default in ooc. However, when
the GC is disabled, those will point to non-GC version of the functions.&lt;/p&gt;

&lt;p&gt;So that your code remains flexible, do yourself a favor and use the &lt;code&gt;gc_&lt;/code&gt;
variants regardless.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Allocating memory&lt;/h2&gt;

&lt;p&gt;Use &lt;code&gt;gc_malloc&lt;/code&gt; to get a chunk of memory all to yourself.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves a slice of 4 bytes
block := gc_malloc(4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, you&amp;rsquo;ll get a &lt;code&gt;Pointer&lt;/code&gt; back - which is a little bit pointless.
Plus you&amp;rsquo;ll probably want to determine how much you are allocating as
a function of the size of some other type instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves room to store 4 doubles.
doubles := gc_malloc(4 * Double size) as Double*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s better. Now you can index that, like any pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
doubles[0] = 3.14
doubles[1] = 6.28
// etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pointer arithmetic works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
addressOfSecondDouble := doubles + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then again, why not write it the explicit way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
addressOfSecondDouble := doubles[1]&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;gc_malloc&lt;/code&gt; returns zeroed memory (even when the GC is disabled),
just like the C function &lt;code&gt;calloc&lt;/code&gt; does. While a small performance hit, a
little additional safety can&amp;rsquo;t hurt.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Allocating in bulks&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;calloc&lt;/code&gt; is typically used in C to get zeroed memory (e.g. all null bytes).
This is unnecessary in ooc, since &lt;code&gt;gc_malloc&lt;/code&gt; returns zeroed memory anyway.&lt;/p&gt;

&lt;p&gt;In the rare cases where you do mean to allocate &lt;code&gt;num&lt;/code&gt; members of size &lt;code&gt;size&lt;/code&gt;,
use &lt;code&gt;gc_calloc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
members := gc_calloc(num, size)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Re-allocating memory&lt;/h2&gt;

&lt;p&gt;Didn&amp;rsquo;t get enough the first time around? Misjudged your budget needs?&lt;/p&gt;

&lt;p&gt;Fear not, &lt;code&gt;gc_realloc&lt;/code&gt; is here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves 4 bytes
block := gc_malloc(4)

// woops, make that 8
block = gc_realloc(block, 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Duplicating memory&lt;/h2&gt;

&lt;p&gt;In our family of memory-related functions, &lt;code&gt;gc_strdup&lt;/code&gt;, nostalgically
named as if it was only used with strings, is here. It&amp;rsquo;ll make a copy of
a block of memory so that the original may be disposed of.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
someCallback: func (word: CString) {
  // CString is a pointer to a memory block that will get
  // overriden sometimes after this function returns - hence,
  // we want to make a copy so that the data we got doesn&#39;t
  // get tampered with.
  storeString(String new(gc_strdup(word)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The block of code above shows the typical use case, anyway.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Freeing memory&lt;/h2&gt;

&lt;p&gt;Technically, since we are using a garbage collector, you don&amp;rsquo;t need to
free explicitly. Should you feel the need to do so, however, &lt;code&gt;gc_free&lt;/code&gt; is
here to do the job:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// you know what, I&#39;m good for now, thanks.
gc_free(block)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>numbers</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/numbers/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/numbers/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Numbers&lt;/h1&gt;

&lt;p&gt;Numbers come in various shapes and forms. There is no bignum implementation
in ooc&amp;rsquo;s sdk - which means that you are pretty much stuck with C&amp;rsquo;s types,
either varying width (Int, Long, LLong) or fixed-width (Int16, UInt32, Int64,
etc.)&lt;/p&gt;

&lt;p&gt;However, they share common methods that come in handy from time to time.
This page summarizes these methods.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Integers&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;String representation&lt;/h2&gt;

&lt;p&gt;Calling &lt;code&gt;toString()&lt;/code&gt; will return a default, decimal representation of an
integer.  The &lt;code&gt;toHexString()&lt;/code&gt; method returns a base 16 representation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
0c24222570 toString() // &amp;quot;5318008&amp;quot;
3_735_928_559 toHexString() // &amp;quot;deadbeef&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Divisors&lt;/h2&gt;

&lt;p&gt;Test if a number is odd with &lt;code&gt;odd?()&lt;/code&gt;, if it&amp;rsquo;s even with &lt;code&gt;even?()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
3 odd?() // true
3 even?() // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, to check if a number b is a divisor of a number a, use &lt;code&gt;divisor?()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
9 divisor?(3) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t use this naive prime algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
n := 40_960_001
for (i in 0..n) if (n divisor?(i)) {
  raise(&amp;quot;Not a prime.&amp;quot;)
}
&amp;quot;Alright, it&#39;s a prime.&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find something smarter instead.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Range inclusion&lt;/h2&gt;

&lt;p&gt;To test if a number is within a range, use &lt;code&gt;in?(Range)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
9 in?(0..10) // true
3 in?(5..15) // false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Absolute value&lt;/h2&gt;

&lt;p&gt;Use the &lt;code&gt;abs()&lt;/code&gt; to get the a positive value no matter what:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
9 abs()  // 9
-9 abs() // 9
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Times&lt;/h2&gt;

&lt;p&gt;While not technically number-related, repeating an action &lt;code&gt;n&lt;/code&gt; times
can be done with the &lt;code&gt;times&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
3 times(|| knock())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, the closure can take the current (0-based) index as an argument&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
99 times(|i|
  takeDownBottle(i)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Floats&lt;/h1&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;String representation&lt;/h2&gt;

&lt;p&gt;Calling &lt;code&gt;toString()&lt;/code&gt; will return a default, base 10 representation of a
floating point number, with a precision of 2 after the decimal point.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
3.14 toString() // &amp;quot;3.14&amp;quot;, conveniently
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>string</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/string/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/string/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;String&lt;/h1&gt;

&lt;p&gt;A string in ooc is a chain of bytes with no particular property.
In most cases, you&amp;rsquo;ll want to deal with UTF-8 encoded strings.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;String&lt;/code&gt; type is the full-blown ooc String - it is a pascal
string in the sense that the length is stored with it. It is
backed by the &lt;code&gt;Buffer&lt;/code&gt; type, which contains the actual bytes.&lt;/p&gt;

&lt;p&gt;Buffers are mutable, whereas Strings are immutable. Therefore,
to build up a long String from several elements, using &lt;code&gt;Buffer&lt;/code&gt;
is preferable.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h2&gt;

&lt;p&gt;The size of a String can be retrieved through the &lt;code&gt;size&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;dumb luck&amp;quot; size == 9 // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Tests&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;startsWith?&lt;/code&gt; and &lt;code&gt;endsWith?&lt;/code&gt; do exactly what they sound like.
&lt;code&gt;equals?&lt;/code&gt; tests for equality, and is aliased to the &lt;code&gt;==&lt;/code&gt; operator
and, for non-equality, the &lt;code&gt;!=&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;moonlight&amp;quot; startsWith?(&amp;quot;moon&amp;quot;) // true
&amp;quot;lightscape&amp;quot; endsWith?(&amp;quot;scape&amp;quot;) // true

&amp;quot;moon&amp;quot; == &amp;quot;moon&amp;quot; // true
&amp;quot;light&amp;quot; != &amp;quot;darkness&amp;quot; // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Indexing&lt;/h2&gt;

&lt;p&gt;One can retrieve the n-th byte with the array indexing operator, &lt;code&gt;[]&lt;/code&gt;
and an integer value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;abcdef&amp;quot;[2] // == &#39;c&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the indexes are 0-based, like arrays.&lt;/p&gt;

&lt;p&gt;To iterate through each byte of a String, a foreach can be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Let&#39;s spell!&amp;quot; println()
for (c in &amp;quot;violin&amp;quot;) {
  &amp;quot;%c, &amp;quot; printfln(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Formatting and printing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;format&lt;/code&gt; method can be used to format a string with various
elements such as integers, floats, other strings, etc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;%d&amp;quot; format(42) // == &amp;quot;42&amp;quot;
&amp;quot;%.2f&amp;quot; format(3.1567) // == &amp;quot;3.16&amp;quot;
&amp;quot;%s&amp;quot; format(&amp;quot;Hi!&amp;quot;) // == &amp;quot;Hi!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;print&lt;/code&gt; method will print a string to the standard output.
Since it is so convenient to print a string followed by a newline,
&lt;code&gt;println&lt;/code&gt; does exactly that. And since formatting is often used,
&lt;code&gt;printfln&lt;/code&gt; does formatting, then print the result followed by a newline.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Hello world!\n&amp;quot; print()
// is equivalent to:
&amp;quot;Hello world!&amp;quot; println()
// itself equivalent to:
&amp;quot;Hello %s!&amp;quot; printfln(&amp;quot;world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Concatenation&lt;/h2&gt;

&lt;p&gt;One can use the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;prepend&lt;/code&gt; methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;light&amp;quot; prepend(&amp;quot;moon&amp;quot;) // == &amp;quot;moonlight&amp;quot;
&amp;quot;storm&amp;quot; append(&amp;quot;born&amp;quot;) // == &amp;quot;stormborn&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply, the &lt;code&gt;+&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;not&amp;quot; + &amp;quot;with&amp;quot; + &amp;quot;standing&amp;quot; // == &amp;quot;notwithstanding&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Finding and replacing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;indexOf&lt;/code&gt; method returns the index of a character or string inside
a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;abcdef&amp;quot; indexOf?(&#39;c&#39;) // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;replaceAll&lt;/code&gt;, one can replace all instances of a String with
another String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// yields &amp;quot;Brother | father | lover.&amp;quot;
&amp;quot;Brother, father, lover.&amp;quot; replaceAll(&amp;quot;,&amp;quot;, &amp;quot; |&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Slicing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;substring&lt;/code&gt; method allows one to get a slice of a String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;observe&amp;quot; substring(2) // == &amp;quot;serve&amp;quot;
&amp;quot;laminate&amp;quot; substring(2, 5) // == &amp;quot;min&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, the array indexing operator, &lt;code&gt;[]&lt;/code&gt;, can be used
with a range literal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;observe&amp;quot;[2..-1] // == &amp;quot;serve&amp;quot;
&amp;quot;laminate&amp;quot;[2..5] // == &amp;quot;min&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Trimming&lt;/h2&gt;

&lt;p&gt;To get rid of extra whitespace, use the &lt;code&gt;trim&lt;/code&gt; method, or its variants,
&lt;code&gt;trimLeft&lt;/code&gt; and &lt;code&gt;trimRight&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;  Hi!  &amp;quot; trim() // = &amp;quot;Hi!&amp;quot;
&amp;quot;  Hi!  &amp;quot; trimLeft() // = &amp;quot;Hi!  &amp;quot;
&amp;quot;  Hi!  &amp;quot; trimRight() // = &amp;quot;  Hi!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They also have versions that accept which characters to trim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;[Hola.]&amp;quot; trim() // = &amp;quot;[Hola.]&amp;quot;
&amp;quot;[Hola.]&amp;quot; trim(&amp;quot;[]()&amp;quot;) // = &amp;quot;Hola.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;CString&lt;/h1&gt;

&lt;p&gt;While a pure ooc program will want to deal mostyl with &lt;code&gt;String&lt;/code&gt;s,
when dealing with C functions, one will want to convert back and forth
with &lt;code&gt;toCString()&lt;/code&gt;, which gives a &lt;code&gt;CString&lt;/code&gt;, a cover of &lt;code&gt;char*&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Conversely, converting a CString to a String can be done with &lt;code&gt;toString()&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>types</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/types/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/types/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Base types in the lang package&lt;/h1&gt;

&lt;p&gt;Some types are useful enough that they are imported into every ooc
module out there. For example, &lt;code&gt;Object&lt;/code&gt;, which is the default super type
of all objects.&lt;/p&gt;

&lt;p&gt;Integer types, both fixed-width (&lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;) and variable-width
(&lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;LLong&lt;/code&gt;) are also in &lt;code&gt;lang/types&lt;/code&gt;, along with the boolean type
&lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Object / Class&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Class&lt;/code&gt; classes are written in ooc itself, and not part
of some separate C runtime.&lt;/p&gt;

&lt;p&gt;Anytime a type is referred to, you have something of type &lt;code&gt;Class&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
type := Int
type name // &amp;quot;Int&amp;quot;
type size // 4
type instanceSize // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, in this case, it&amp;rsquo;s an instance of &lt;code&gt;IntClass&lt;/code&gt;, as demonstrated
by this chunk of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
type class name // &amp;quot;IntClass&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even base types have classes, although they aren&amp;rsquo;t available via the
&lt;code&gt;class&lt;/code&gt; property, unlike objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
dog := Dog new()
dog class == Dog // true

a := 42
a class // invalid, not an object, it doesn&#39;t have fields
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is especially useful for generics, where classes are passed
along with actual arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
acceptAnything: func &amp;lt;T&amp;gt; (t: T) {
  T // is a subtype of Class, can access &#39;name&#39;, etc.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;size vs instanceSize&lt;/h2&gt;

&lt;p&gt;For basic types such as Int, Float, Char - there is no difference between size
and instanceSize. For complex types, e.g. objects, there is a difference between
size and instanceSize.&lt;/p&gt;

&lt;p&gt;For objects, &lt;code&gt;size&lt;/code&gt; is always equal to the size of a pointer - since objects are
references. However, &lt;code&gt;instanceSize&lt;/code&gt; is equal to the amount of memory an object
takes in memory.&lt;/p&gt;

&lt;p&gt;For more information on the subject, read about &lt;a href=&#34;/docs/lang/classes/&#34;&gt;ooc classes&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Various types&lt;/h1&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Bool&lt;/h2&gt;

&lt;p&gt;Booleans in ooc, equal to either the boolean literal &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;,
are of type &lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
b := true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Void&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Void&lt;/code&gt; is the type of nothing. A function that doesn&amp;rsquo;t return anything
has a return type of &lt;code&gt;Void&lt;/code&gt;, implicitly.&lt;/p&gt;

&lt;p&gt;It is never used explicitly throughout the SDK, it is mostly there so
that compiler iternals work fine.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Pointer&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Pointer&lt;/code&gt; is the umbrella term for any type of pointer. When possible,
using a more precise type such as &lt;code&gt;Int*&lt;/code&gt; is desirable.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;None&lt;/h2&gt;

&lt;p&gt;None can be used as an object representing nothing. It has a single
no-argument constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
nothing := None new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can be used in place of null when adopting a pattern-matching approach.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Cell&lt;/h2&gt;

&lt;p&gt;Cell is documented in the &lt;a href=&#34;/docs/sdk/structs/&#34;&gt;structs package&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;VarArgs&lt;/h1&gt;

&lt;p&gt;This is the sdk-side implementation of variable arguments. Basically,
it allows packing different values in the &lt;code&gt;VarArgs&lt;/code&gt; structure with
&lt;code&gt;_addValue&lt;/code&gt; - although the compiler will typically write those out
with a static initializer for efficiency.&lt;/p&gt;

&lt;p&gt;They can be iterated through thanks to &lt;code&gt;VarArgsIterator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
something: func (args: ...) {
  iter := args iterator()
  while (iter hasNext?()) {
    T := iter getNextType()
    match T {
      case Int =&amp;gt;
        value := iter next(Int)
        // do something with value
      case =&amp;gt;
        raise(&amp;quot;Unsupported argument type: %s&amp;quot; format(T name))
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, more simply, with &lt;code&gt;each&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
something: func (args: ...) {
  args each(|arg|
    match arg {
      case value: Int =&amp;gt;
        // do something with value
      case =&amp;gt;
        raise(&amp;quot;Unsupported argument type&amp;quot;)
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>math</title>
      <link>http://oocmanual.cogneco.com/sdk/math/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/math/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The math package&lt;/h1&gt;

&lt;p&gt;The math package piggybacks on libc for basic mathematical operations with
standard integer and floating point types.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;math&lt;/h1&gt;

&lt;p&gt;By simply importing &lt;code&gt;math&lt;/code&gt;, a most of the math functions from libc will get
imported.&lt;/p&gt;

&lt;p&gt;Often, math operations are available both in function form and in method form.
The function form would be similar to C, e.g.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
sin(2 * PI)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas the method form would be more.. object-oriented-ish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
2 pow(16)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Powers and roots&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;pow&lt;/code&gt; elevates the first argument to the power of the second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
2 pow(8) // 256
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exp&lt;/code&gt; returns the value of e (the base of natural logarithms) raised to the
power of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exp(2) // approx. 7.389
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sqrt&lt;/code&gt; returns the square root of a number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
144 sqrt() // 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cbrt&lt;/code&gt; returns the cube root of a number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
8 cbrt() // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Trigonometry&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PI&lt;/code&gt; is a constant defined in math as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
PI := 3.14159_26535_89793_23846_26433_83279
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;tan&lt;/code&gt;, are available, both in method and function form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
sin(2 * PI) // 0
cos(- (3 / 4) * PI) // -0.707, etc.
tan(PI / 4) // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As are their arc equivalents, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, their hyperbolic
variants, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, and their arc hyperbolic tandems,
&lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As for &lt;code&gt;atan2&lt;/code&gt;, straight from Wikipedia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In a variety of computer languages, the function atan2 is the arctangent
function with two arguments. The purpose of using two arguments instead of
one, is to gather information of the signs of the inputs in order to return
the appropriate quadrant of the computed angle, which is not possible for
the single-argument arctangent function.

For any real number (e.g., floating point) arguments x and y not both equal
to zero, atan2(y, x) is the angle in radians between the positive x-axis of
a plane and the point given by the coordinates (x, y) on it. The angle is
positive for counter-clockwise angles (upper half-plane, y &amp;gt; 0), and
negative for clockwise angles (lower half-plane, y &amp;lt; 0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Source: &lt;a href=&#34;http://en.wikipedia.org/wiki/Atan2&#34;&gt;http://en.wikipedia.org/wiki/Atan2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Logarithms&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;log&lt;/code&gt; function returns the natural logarithm of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
log(2) // about 0.69
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;log10&lt;/code&gt; function returns the base 10 logarithm of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
log10(4000) // about 3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Rounding and truncation&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;roundLong&lt;/code&gt; and &lt;code&gt;roundLLong&lt;/code&gt; are methods that will round to the
nearest integer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.14 round() // 3.00
4.78 roundLong() // 5
0.92 roundLLong() // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ceil&lt;/code&gt; and &lt;code&gt;floor&lt;/code&gt; methods will round to the nearest upper and lower
integer, respectively:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.14 ceil() // 4.00
8.92 floor() // 8.00
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Floating-point remainder&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;mod&lt;/code&gt; function computes the floating-point remainder of dividing x by y.
The return value is x - n * y, where n is the quotient of x / y, rounded toward
zero to an integer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12 mod(5) // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Various&lt;/h2&gt;

&lt;p&gt;To get the absolute value of a number, use &lt;code&gt;abs()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
(-4) abs() // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Random&lt;/h1&gt;

&lt;p&gt;By importing &lt;code&gt;math/Random&lt;/code&gt;, one can generate random numbers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer: neither the libc random number generator or the fast prng
exposed by math/Random are suitable for cryptographic usage. Find a library
that does it right, this was not planned for it.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When the module is loaded (probably at program start-up), the libc random
number generator will be seeded with the current time in microseconds.&lt;/p&gt;

&lt;p&gt;Then, various functions can be used to get random numbers.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;libc generator&lt;/h2&gt;

&lt;p&gt;To get any number between &lt;code&gt;INT_MIN&lt;/code&gt; and &lt;code&gt;INT_MAX&lt;/code&gt;, call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := Random random()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get any number within a range, use either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// gives a number between 0 (included) and 10 (included)
number := Random randInt(0, 10)

// gives a number between 0 (included) and 9 (included)
number = Random randRange(0, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those both have variants to get a number in a range, excluding any
number already contained in a list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get 10 unique numbers between 0 and 100
list := ArrayList&amp;lt;Int&amp;gt; new()

10 times(||
    list add(Random randInt(0, 100, list))
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pick out a random element ouf ot a list, use &lt;code&gt;choice&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get one of those 10 unique numbers we just generated:
num := Random choice(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;choice&lt;/code&gt; is generic, so it will work with lists of any
type of element.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;fast prng&lt;/h2&gt;

&lt;p&gt;Most of the methods above have a &lt;code&gt;fast&lt;/code&gt; variant, working from a PRNG (&lt;a href=&#34;http://en.wikipedia.org/wiki/Pseudorandom_number_generator&#34;&gt;pseudorandom
number generator&lt;/a&gt;) coded directly into the Random class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// all these are documented above, they work in a similar fashion
Random fastRandom()

Random fastRandInt(0, 10)
Random fastRandRange(0, 10)

Random fastRandInt(0, 10, list)
Random fastRandRange(0, 10, list)

Random fastChoice(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fast&lt;/code&gt; variants are meant to be faster, as the name implies, but they&amp;rsquo;re even
less guaranteed to have good random qualities - the numbers it generates might be
less even / repeat more easily.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>native</title>
      <link>http://oocmanual.cogneco.com/sdk/native/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/native/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The native package&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;native&lt;/code&gt; package of the SDK contains nothing that should be
directly imported in a cross-platform application. It&amp;rsquo;s all platform-specific
support code for other parts of the SDK.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Windows&lt;/h2&gt;

&lt;p&gt;For example, the &lt;code&gt;native/win32&lt;/code&gt; package contains covers for types defined
in the Win32 API, along with a few error handling functions and other
things that are useful in the Win32 implementation of the SDK.&lt;/p&gt;

&lt;p&gt;Note that there exists &lt;code&gt;native&lt;/code&gt; sub packages elsewhere in the SDK, for example
in the &lt;code&gt;io&lt;/code&gt; or in the &lt;code&gt;os&lt;/code&gt; packages.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>net</title>
      <link>http://oocmanual.cogneco.com/sdk/net/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/net/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The net package&lt;/h1&gt;

&lt;p&gt;When you want to deal with TCP and UDP sockets directly, the &lt;code&gt;net&lt;/code&gt; package is
here for you.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;TCP&lt;/h1&gt;

&lt;p&gt;TCP guarantees that packets arrive eventually, and that they arrive in the
order in which they were sent.&lt;/p&gt;

&lt;p&gt;Usually, on the server side, sockets are bound to a port, and then listen.
When clients attempt to connect, they accept connections (and can later
close them if so they wish).&lt;/p&gt;

&lt;p&gt;Accepting a connection via a server socket gives a TCPSocket - so, after
a client has connected, the client and the server use the same data structure
to communicate.&lt;/p&gt;

&lt;p&gt;A Socket, like a &lt;code&gt;TCPSocket&lt;/code&gt;, has a reader / writer pair, since sockets
are bidirectional communication channels. Which means they can write data
to the writer, and read data from the reader.&lt;/p&gt;

&lt;p&gt;For more info on readers and writers, go ahead and read (heh) the documentation
on the &lt;a href=&#34;/docs/sdk/io/&#34;&gt;io package&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;ServerSocket&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s an example usage of ServerSocket serving as a makeshift HTTP
server (don&amp;rsquo;t do that, though):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import net/[ServerSocket]

socket := ServerSocket new(&amp;quot;0.0.0.0&amp;quot;, 8000)
socket listen()
&amp;quot;Listening...&amp;quot; println()

while(true) {
    conn := socket accept()
    &amp;quot;Got a connection!&amp;quot; println()

    while (conn in readLine() trim() != &amp;quot;&amp;quot;) {
      // read the request
    }

    conn out write(&amp;quot;HTTP/1.1 200 OK\r\n&amp;quot;)
    conn out write(&amp;quot;Content-Type: text/html\r\n&amp;quot;)
    conn out write(&amp;quot;\r\n&amp;quot;)
    conn out write(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;\
      Hello, from the ooc socket world!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;)
    conn out write(&amp;quot;\r\n&amp;quot;)
    conn close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t forget to call &lt;code&gt;listen()&lt;/code&gt; before trying to &lt;code&gt;accept()&lt;/code&gt; connections.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;TCPSocket&lt;/h2&gt;

&lt;p&gt;Same as the ServerSocket, but on the client side. Make requests like
that (or don&amp;rsquo;t - use a proper HTTP library):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import net/[TCPSocket]

socket := TCPSocket new(&amp;quot;ooc-lang.org&amp;quot;, 80)
socket connect()
socket out write(&amp;quot;GET / HTTP/1.1\n&amp;quot;)
socket out write(&amp;quot;Host: ooc-lang.org\n&amp;quot;)
socket out write(&amp;quot;User-Agent: An anonymous admirer\n&amp;quot;)
socket out write(&amp;quot;\n\n&amp;quot;)

line := socket in readLine()
&amp;quot;We got a response! %s&amp;quot; printfln(line)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seriously. Use a proper HTTP library. But that&amp;rsquo;s an example.&lt;/p&gt;

&lt;p&gt;Also, don&amp;rsquo;t forget to call &lt;code&gt;connect()&lt;/code&gt; before attempting to use &lt;code&gt;out&lt;/code&gt;
or &lt;code&gt;in&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;UDP&lt;/h1&gt;

&lt;p&gt;Unlike TCP, UDP is unidirectional - some sockets bind and only get to
receive, and some sockets don&amp;rsquo;t bind and can only send.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also no guarantee that anything sent over UDP ever arrives, and
order is not guaranteed either.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;UDPSocket&lt;/h2&gt;

&lt;p&gt;When you create an &lt;code&gt;UDPSocket&lt;/code&gt;, always specify a hostname (or an ip) and a port, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket := UDPSocket new(&amp;quot;localhost&amp;quot;, 5000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to receive datagrams, call bind():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket bind()

while (true) {
  buffer := socket receive(128)
  buffer toString() println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to send datagrams, just call send:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket send(&amp;quot;udp is fun&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s about it for now.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>channel</title>
      <link>http://oocmanual.cogneco.com/sdk/os/channel/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/channel/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Channel module&lt;/h1&gt;

&lt;p&gt;Channels are another way to think about data flow in the program.
Perhaps most famous in their Go implementation, &amp;lsquo;goroutines&amp;rsquo;, can
communicate via channels.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;os/Channel&lt;/code&gt; module contains a trivial implementation of channels
which may be used like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By importing this module, a scheduler is set to run before the program
exits. Let&amp;rsquo;s start by making a channel by which Ints can travel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
chan := make(Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then let&amp;rsquo;s make a data producer coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 0..5) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And another one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 5..10) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
    chan &amp;lt;&amp;lt; -1
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-1 will be used as a stopping signal here. &lt;code&gt;go&lt;/code&gt; create a new
coroutine, and &lt;code&gt;chan &amp;lt;&amp;lt; value&lt;/code&gt; sends a value down a channel.
&lt;code&gt;yield&lt;/code&gt; switches from the current coroutine back to the scheduler.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now make a consumer channel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    while (true) match (i := !chan) {
        case -1 =&amp;gt; break
        case =&amp;gt; &amp;quot;%d&amp;quot; printfln(i)
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re reading from the channel with the not operator: &lt;code&gt;!chan&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will print 0, 5, 1, 6, 2, 7, 3, 8, 4, 9, and then exit, as
expected.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>coro</title>
      <link>http://oocmanual.cogneco.com/sdk/os/coro/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/coro/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Coro module&lt;/h1&gt;

&lt;p&gt;That module was originally an ooc port of Steve Dekorte&amp;rsquo;s &lt;a href=&#34;https://github.com/stevedekorte/coroutine&#34;&gt;libcoroutine&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Coroutines help achieve cooperative multi-tasking, as opposed to threads, which
achieve preemptive multitasking. In cooperative multi-tasking, each task (or
&amp;lsquo;coroutine&amp;rsquo;) is responsible for handing the control to another coroutine.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;First, we have to create a main coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Coro

mainCoro := Coro new()
mainCoro initializeMainCoro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then create another coroutine, which we&amp;rsquo;ll here use as a generator&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
letter: Char

coro1 := Coro new()
mainCoro startCoro(coro1, ||
    for (c in &amp;quot;LLAMACORE&amp;quot;) {
        letter = c
        coro1 switchTo(mainCoro)
    }
    exit(0)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can retrieve those letters one by one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (true) {
    &amp;quot;%c&amp;quot; printfln(letter)
    mainCoro switchTo(coro1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is quite simple, just printing each letter that
&lt;code&gt;coro1&lt;/code&gt; gives us on separate lines, but complex tasks can be
broken down in various coroutines and be achieved in a much
more lightweight fashion than threads or processes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dynlib</title>
      <link>http://oocmanual.cogneco.com/sdk/os/dynlib/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/dynlib/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Dynlib module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Dynlib&lt;/code&gt; module allows one to load dynamic libraries on all
major platforms.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s open a library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Dynlib

lib := Dynlib load(&amp;quot;libm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t need to specify the &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dynlib&lt;/code&gt;, or &lt;code&gt;.dll&lt;/code&gt; extension here, it is
set automatically by platform, although the original path will be tested first,
in case of non-standard file extension.&lt;/p&gt;

&lt;p&gt;If the lib returned is null, it wasn&amp;rsquo;t found or couldn&amp;rsquo;t be opened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
if (!lib) {
    raise(&amp;quot;Couldn&#39;t load library!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then retrieve a symbol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cosAddr := lib symbol(&amp;quot;cos&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And cast it to a more useful function. Since &lt;code&gt;Func&lt;/code&gt; is actually
a function pointer and a context, we use a cover literal, passing
null for the context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cos := (cosAddr, null) as Func (Double) -&amp;gt; Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which we can then use!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;cos(PI / 4) = %.3f&amp;quot; printfln(cos(3.14 * 0.25))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This prints &lt;code&gt;cos(PI / 4) = 0.707&lt;/code&gt;, as expected.&lt;/p&gt;

&lt;p&gt;When we&amp;rsquo;re done with the library we can just close it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
lib close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: on Windows, failing to close a library may lead to a
crash on application exit.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>