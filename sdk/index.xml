<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Sdks on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/sdk/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>channel</title>
      <link>http://oocmanual.cogneco.com/sdk/os/channel</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/channel</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Channel module&lt;/h1&gt;

&lt;p&gt;Channels are another way to think about data flow in the program.
Perhaps most famous in their Go implementation, &amp;lsquo;goroutines&amp;rsquo;, can
communicate via channels.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;os/Channel&lt;/code&gt; module contains a trivial implementation of channels
which may be used like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By importing this module, a scheduler is set to run before the program
exits. Let&amp;rsquo;s start by making a channel by which Ints can travel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
chan := make(Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then let&amp;rsquo;s make a data producer coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 0..5) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And another one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 5..10) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
    chan &amp;lt;&amp;lt; -1
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-1 will be used as a stopping signal here. &lt;code&gt;go&lt;/code&gt; create a new
coroutine, and &lt;code&gt;chan &amp;lt;&amp;lt; value&lt;/code&gt; sends a value down a channel.
&lt;code&gt;yield&lt;/code&gt; switches from the current coroutine back to the scheduler.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now make a consumer channel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    while (true) match (i := !chan) {
        case -1 =&amp;gt; break
        case =&amp;gt; &amp;quot;%d&amp;quot; printfln(i)
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re reading from the channel with the not operator: &lt;code&gt;!chan&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will print 0, 5, 1, 6, 2, 7, 3, 8, 4, 9, and then exit, as
expected.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>net</title>
      <link>http://oocmanual.cogneco.com/sdk/net</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/net</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The net package&lt;/h1&gt;

&lt;p&gt;When you want to deal with TCP and UDP sockets directly, the &lt;code&gt;net&lt;/code&gt; package is
here for you.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;TCP&lt;/h1&gt;

&lt;p&gt;TCP guarantees that packets arrive eventually, and that they arrive in the
order in which they were sent.&lt;/p&gt;

&lt;p&gt;Usually, on the server side, sockets are bound to a port, and then listen.
When clients attempt to connect, they accept connections (and can later
close them if so they wish).&lt;/p&gt;

&lt;p&gt;Accepting a connection via a server socket gives a TCPSocket - so, after
a client has connected, the client and the server use the same data structure
to communicate.&lt;/p&gt;

&lt;p&gt;A Socket, like a &lt;code&gt;TCPSocket&lt;/code&gt;, has a reader / writer pair, since sockets
are bidirectional communication channels. Which means they can write data
to the writer, and read data from the reader.&lt;/p&gt;

&lt;p&gt;For more info on readers and writers, go ahead and read (heh) the documentation
on the &lt;a href=&#34;/docs/sdk/io/&#34;&gt;io package&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;ServerSocket&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s an example usage of ServerSocket serving as a makeshift HTTP
server (don&amp;rsquo;t do that, though):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import net/[ServerSocket]

socket := ServerSocket new(&amp;quot;0.0.0.0&amp;quot;, 8000)
socket listen()
&amp;quot;Listening...&amp;quot; println()

while(true) {
    conn := socket accept()
    &amp;quot;Got a connection!&amp;quot; println()

    while (conn in readLine() trim() != &amp;quot;&amp;quot;) {
      // read the request
    }

    conn out write(&amp;quot;HTTP/1.1 200 OK\r\n&amp;quot;)
    conn out write(&amp;quot;Content-Type: text/html\r\n&amp;quot;)
    conn out write(&amp;quot;\r\n&amp;quot;)
    conn out write(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;\
      Hello, from the ooc socket world!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;)
    conn out write(&amp;quot;\r\n&amp;quot;)
    conn close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t forget to call &lt;code&gt;listen()&lt;/code&gt; before trying to &lt;code&gt;accept()&lt;/code&gt; connections.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;TCPSocket&lt;/h2&gt;

&lt;p&gt;Same as the ServerSocket, but on the client side. Make requests like
that (or don&amp;rsquo;t - use a proper HTTP library):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import net/[TCPSocket]

socket := TCPSocket new(&amp;quot;ooc-lang.org&amp;quot;, 80)
socket connect()
socket out write(&amp;quot;GET / HTTP/1.1\n&amp;quot;)
socket out write(&amp;quot;Host: ooc-lang.org\n&amp;quot;)
socket out write(&amp;quot;User-Agent: An anonymous admirer\n&amp;quot;)
socket out write(&amp;quot;\n\n&amp;quot;)

line := socket in readLine()
&amp;quot;We got a response! %s&amp;quot; printfln(line)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seriously. Use a proper HTTP library. But that&amp;rsquo;s an example.&lt;/p&gt;

&lt;p&gt;Also, don&amp;rsquo;t forget to call &lt;code&gt;connect()&lt;/code&gt; before attempting to use &lt;code&gt;out&lt;/code&gt;
or &lt;code&gt;in&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;UDP&lt;/h1&gt;

&lt;p&gt;Unlike TCP, UDP is unidirectional - some sockets bind and only get to
receive, and some sockets don&amp;rsquo;t bind and can only send.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also no guarantee that anything sent over UDP ever arrives, and
order is not guaranteed either.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;UDPSocket&lt;/h2&gt;

&lt;p&gt;When you create an &lt;code&gt;UDPSocket&lt;/code&gt;, always specify a hostname (or an ip) and a port, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket := UDPSocket new(&amp;quot;localhost&amp;quot;, 5000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to receive datagrams, call bind():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket bind()

while (true) {
  buffer := socket receive(128)
  buffer toString() println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to send datagrams, just call send:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
socket send(&amp;quot;udp is fun&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s about it for now.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>env</title>
      <link>http://oocmanual.cogneco.com/sdk/os/env</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/env</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Env module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Env&lt;/code&gt; module allows to get and set environment variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting an environment variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
path := Env get(&amp;quot;PATH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt; if the given environment variable is not set.&lt;/p&gt;

&lt;p&gt;Setting an environment variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Env set(&amp;quot;CFLAGS&amp;quot;, &amp;quot;-Os&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Environment variables can be unset as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Env unset(&amp;quot;PKG_CONFIG_PATH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>os</title>
      <link>http://oocmanual.cogneco.com/sdk/os</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os package&lt;/h1&gt;

&lt;p&gt;The os packages contains various modules pertaining to Operating System functionality such as:&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Concurrency&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;process&#34;&gt;Process&lt;/a&gt;, to launch child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;jobpool&#34;&gt;JobPool&lt;/a&gt;, to easily control a pool of child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[Coro](coro, which provides a basic coroutine implementation&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;I/O&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;terminal&#34;&gt;Terminal&lt;/a&gt;, used to control terminal text output (color, etc.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;pipe&#34;&gt;Pipe&lt;/a&gt;, to open, read from, and write to pipes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;dynlib&#34;&gt;Dynlib&lt;/a&gt;, which deals with dynamic library loading&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;mmap&#34;&gt;mmap&lt;/a&gt;, which exposes memory mapping capabilities&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;channel&#34;&gt;Channel&lt;/a&gt;, which implements channels&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;System&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;system&#34;&gt;System&lt;/a&gt;, to get information such as the number of processors,
the hostname, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;env&#34;&gt;Env&lt;/a&gt;, to deal with environment variables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;shellutils&#34;&gt;ShellUtils&lt;/a&gt;, used mostly to find executables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;time&#34;&gt;Time&lt;/a&gt;, to get the current time and date, and sleep&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>process</title>
      <link>http://oocmanual.cogneco.com/sdk/os/process</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/process</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Process module&lt;/h1&gt;

&lt;p&gt;The Process module deals with everything related to launching a child process, waiting for
its status or signals, and communicating with it.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;A process can be launched by providing an array or a list of arguments to the &lt;code&gt;Process&lt;/code&gt; constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Process

p := Process new([&amp;quot;cat&amp;quot;, &amp;quot;/etc/hosts&amp;quot;])
exitCode := p execute()

// at this point, the process has ended
// and &#39;exitCode&#39; contains the value returned by the program
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of running execute, one might want to run &lt;code&gt;getOutput&lt;/code&gt; directly, to get
the standard output of the process as a string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;cat&amp;quot;, &amp;quot;/etc/hosts&amp;quot;])
out := p getOutput()
// out now contains the contents of the /etc/hosts file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or getErrOutput to get the standard error output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;cat&amp;quot;, &amp;quot;/etc/hosts&amp;quot;])
err := p getErrOutput()
// err is empty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve the result of both stderr and stdout, see the &amp;lsquo;Redirecting&amp;rsquo; section
below.&lt;/p&gt;

&lt;p&gt;However, depending on your use case, that might not be the best way to do it.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Manual wait and pid&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;execute&lt;/code&gt; will start the child process, wait for it to finish, and print the output.&lt;/p&gt;

&lt;p&gt;However, we can do things manually if we want:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;curl&amp;quot;, &amp;quot;example.org&amp;quot;])
p executeNoWait()
p wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wait&lt;/code&gt; method will wait until the child process has exited or errored. If you
just want to check if a process is still running, &lt;code&gt;waitNoHang&lt;/code&gt; can be used instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;curl&amp;quot;, &amp;quot;example.org&amp;quot;])
p executeNoWait()
while (p waitNoHang() == -1) {
    Time sleepMilli(20)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To execute a bunch of processes in parallel, using a &lt;a href=&#34;/docs/sdk/os/jobpool&#34;&gt;JobPool&lt;/a&gt; is easier and
more suitable.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Process settings&lt;/h1&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Current working directory&lt;/h2&gt;

&lt;p&gt;By default, a process will inherit from the current working directory. To make
the child process run in a specified directory, use the &lt;code&gt;setCwd&lt;/code&gt; method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;cat&amp;quot;, &amp;quot;hosts&amp;quot;])
p setCwd(&amp;quot;/etc&amp;quot;)
p execute()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Environment&lt;/h2&gt;

&lt;p&gt;To specify custom environment variables for a process, use the &lt;code&gt;setEnv&lt;/code&gt; method
with a &lt;code&gt;HashMap&amp;lt;String, String&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;bash&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $MYVAR&amp;quot;])

env := HashMap&amp;lt;String, String&amp;gt; new()
env put(&amp;quot;MYVAR&amp;quot;, &amp;quot;42&amp;quot;)
p setEnv(env)

// prints 42
p execute()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Communicating with a process&lt;/h1&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Redirecting stdin, stdout, stderr&lt;/h2&gt;

&lt;p&gt;One may use &lt;a href=&#34;/docs/sdk/os/pipe/&#34;&gt;pipes&lt;/a&gt; to redirect the standard input, output, or error stream of
a process.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Process, Pipe, PipeReader]

p := Process new([&amp;quot;some&amp;quot;, &amp;quot;process&amp;quot;])

(out, err) := (Pipe new(), Pipe new())
p setStdout(out)
p setStderr(err)

exitCode := p execute()

outString := PipeReader new(out) toString()
errString := PipeReader new(err) toString()

out close(&#39;r&#39;). close(&#39;w&#39;)
err close(&#39;r&#39;). close(&#39;w&#39;)

// we now have the exit code in exitCode, the
// stdout in outString, and the stderr in errString
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Streaming output&lt;/h2&gt;

&lt;p&gt;This can be used to stream stdout to the output of our main program, if the launched
process is interactive. If blinkenlights is still up and running when you try this, it
should display star wars scene in ASCII art:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;nc&amp;quot;, &amp;quot;towel.blinkenlights.nl&amp;quot;, &amp;quot;23&amp;quot;])

out := Pipe new()
out setNonBlocking()
p setStdout(out)

p executeNoWait()

while (true) {
    chr := out read()
    if (chr != &#39;\0&#39;) {
        chr print()
    } else if(p waitNoHang() &amp;gt; 0) {
        // process is done
        break
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Terminate or kill a process&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;terminate&lt;/code&gt; method will send a process the &lt;code&gt;SIGTERM&lt;/code&gt; message, while the &lt;code&gt;kill&lt;/code&gt; method
will send a process the &lt;code&gt;SIGKILL&lt;/code&gt; message.&lt;/p&gt;

&lt;p&gt;This can be used to gracefully end a process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p terminate()
if (p waitNoHang() != -1) {
    // give a few seconds of grace..
    Time sleepSec(3)
}

if (p waitNoHang() != -1) {
    // still not finished? alright, that&#39;s enough
    p kill()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>pipe</title>
      <link>http://oocmanual.cogneco.com/sdk/os/pipe</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/pipe</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Pipe module&lt;/h1&gt;

&lt;p&gt;The Pipe module allows one to deal with pipes. Pipes are basically a pair of
read and write file descriptors.&lt;/p&gt;

&lt;p&gt;The writer writes into the write file descriptor and the reader reads into the
read file descriptor.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Reading&lt;/h2&gt;

&lt;p&gt;A read call may either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;successfully read, if there&amp;rsquo;s data in the pipe&lt;/li&gt;
&lt;li&gt;block to wait for some more data (in blocking mode)&lt;/li&gt;
&lt;li&gt;return immediately with no data (in non-blocking mode)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In non-blocking mode, one has to be careful to distinguish between the &amp;lsquo;no
data&amp;rsquo; condition and the &amp;lsquo;end of pipe&amp;rsquo; condition. OS pipes don&amp;rsquo;t have a proper
&amp;lsquo;eof&amp;rsquo; marker, but reading from a closed pipe will mark the Pipe class as eof
anyway, accessible with &lt;code&gt;Pipe eof?()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;os/Pipe&lt;/code&gt; package contains a &lt;code&gt;PipeReader&lt;/code&gt; class, which extends the
&lt;code&gt;io/Reader&lt;/code&gt; class, for convenience.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Writing&lt;/h2&gt;

&lt;p&gt;A write call may either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;return immediately if there&amp;rsquo;s room in the pipe&lt;/li&gt;
&lt;li&gt;block to wait for some data to be read, making room to write something (in
blocking mode)&lt;/li&gt;
&lt;li&gt;return immediately, having written as much as it can (in non-blocking mode)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;os/Pipe&lt;/code&gt; package contains a &lt;code&gt;PipeWriter&lt;/code&gt; class, which extends the
&lt;code&gt;io/Writer&lt;/code&gt; class, for convenience.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Buffering considerations&lt;/h2&gt;

&lt;p&gt;Note that a pipe&amp;rsquo;s user has to do its own buffering when writing: in blocking
mode, writing something too large will hang forever, and in non-blocking mode,
only the part that fits will be written, leaving the rest unwritten.&lt;/p&gt;

&lt;p&gt;As a result, using a &lt;code&gt;PipeReader&lt;/code&gt; or a &lt;code&gt;PipeReader&lt;/code&gt; in non-blocking mode is
unreliable.  Instead, using blocking mode inside a thread is preferrable.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;Here&amp;rsquo;s a not so useful pipe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe := Pipe new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can write a string into it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe write(&amp;quot;Hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then read the result back:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
str := pipe read(128)
str println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though we requested 128 bytes from the pipe, only 5 bytes have been written,
so we the call immediately returns with a String of size 5.&lt;/p&gt;

&lt;p&gt;We could have also read into our own buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
b := Buffer new(128)
pipe read(b)
b println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same here, the buffer has 128 bytes capacity, but only 5 bytes have been read, and
the buffer&amp;rsquo;s length has been set accordingly. Using a buffer is more efficient
because fewer allocations are being done.&lt;/p&gt;

&lt;p&gt;Then, we shouldn&amp;rsquo;t forget to close both the reading and the writing end of the pipe&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe close(&#39;r&#39;)
pipe close(&#39;w&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Communication&lt;/h1&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Inter-thread communication&lt;/h2&gt;

&lt;p&gt;Pipes can be used to communicate between threads.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a pipe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe := Pipe new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a thread that is going to read out of it until it&amp;rsquo;s closed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
reader := Thread new(||
    while (!pipe eof?()) {
        result := pipe read(128)
        if (result) result print()
    }
    pipe close(&#39;r&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a writer path which is going to write ten hellos, one every 100
milliseconds:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
writer := Thread new(||
    for (i in 0..10) {
        pipe write(&amp;quot;Hello %d\n&amp;quot; format(i))
        Time sleepMilli(100)
    }
    pipe close(&#39;w&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s start them both:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
reader start(); writer start()
reader wait();  writer wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Inter-process communication&lt;/h2&gt;

&lt;p&gt;Similarly, pipes can be (and are mostly) used to communicate with other
processes. This is covered in the &lt;a href=&#34;/docs/sdk/os/process/&#34;&gt;Process&lt;/a&gt; section.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Non-blocking I/O&lt;/h2&gt;

&lt;p&gt;A pipe can be set to non-blocking mode to use non-blocking read operations.
This is used in the streaming example in the &lt;a href=&#34;/docs/sdk/os/process/&#34;&gt;Process&lt;/a&gt; section.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a pipe in non-blocking mode for reading only:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe := Pipe new()
pipe setNonBlocking(&#39;r&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a state variable that&amp;rsquo;ll be shared by both threads:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
done := false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we&amp;rsquo;ll make a writer thread that never closes the pipe itself (much like a
process launched in the background that you never blockingly wait on):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
t := Thread new(||
  for (i in 0..10) {
    Time sleepSec(1)
    pipe write(&amp;quot;Hello %d&amp;quot; format(i))
  }
  done = true
)

t start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It does set done to true after it&amp;rsquo;s done, though - much like you could know if
a background process is still running with &lt;code&gt;waitNoHang&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then we&amp;rsquo;ll read, from the main thread, as much as we can, and when we don&amp;rsquo;t receive
anything, we&amp;rsquo;ll check if we&amp;rsquo;re done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (true) {
  res := pipe read(128)
  if (res) {
    &amp;quot;Received: %s&amp;quot; printfln(res)
  } else if (done) break
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And let&amp;rsquo;s not forget to clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe close()
t wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That behaves as expected. Note that in the main thread loop we could be doing anything
really, without blocking on the read.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Pipes disclaimer&lt;/h1&gt;

&lt;p&gt;If you have read all the way down, and you&amp;rsquo;re thinking of doing some complex
stuff with pipes, you probably want some queuing library instead of using raw
pipes, both for cross-platform support, performance, and ease of use.
&lt;a href=&#34;http://zeromq.org/&#34;&gt;zeromq&lt;/a&gt; is an interesting library and it has &lt;a href=&#34;https://github.com/nddrylliog/ooc-zeromq&#34;&gt;ooc bindings&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>terminal</title>
      <link>http://oocmanual.cogneco.com/sdk/os/terminal</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/terminal</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Terminal module&lt;/h1&gt;

&lt;p&gt;Terminal is used to control the terminal output, mostly by setting colors and
attributes on there.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Colors&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Color&lt;/code&gt; enum contains colors that are possible to set on the terminal:&lt;/p&gt;

&lt;p&gt;To change the foreground color, use &lt;code&gt;setFgColor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setFgColor(Color black)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To change the background color, use &lt;code&gt;setBgColor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setBgColor(Color white)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;List of colors&lt;/h2&gt;

&lt;p&gt;Here are the colors defined in the Color enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;black&lt;/li&gt;
&lt;li&gt;red&lt;/li&gt;
&lt;li&gt;green&lt;/li&gt;
&lt;li&gt;yellow&lt;/li&gt;
&lt;li&gt;blue&lt;/li&gt;
&lt;li&gt;magenta&lt;/li&gt;
&lt;li&gt;cyan&lt;/li&gt;
&lt;li&gt;grey&lt;/li&gt;
&lt;li&gt;white&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that depending on your terminal emulator, these colors
might not map to their actual names.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Attributes&lt;/h1&gt;

&lt;p&gt;Attributes can be set using &lt;code&gt;setAttr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setAttr(Attr bright)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;List of attributes&lt;/h2&gt;

&lt;p&gt;Here are the attributes defined in the &lt;code&gt;Attr&lt;/code&gt; enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reset&lt;/li&gt;
&lt;li&gt;bright&lt;/li&gt;
&lt;li&gt;dim&lt;/li&gt;
&lt;li&gt;under&lt;/li&gt;
&lt;li&gt;blink&lt;/li&gt;
&lt;li&gt;reverse&lt;/li&gt;
&lt;li&gt;hidden&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Resetting&lt;/h1&gt;

&lt;p&gt;Reset all color and attribute settings to default by using the
&lt;code&gt;reset&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal reset()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Cross-platform considerations&lt;/h1&gt;

&lt;p&gt;On *nix platforms, all attributes are supposed. On Windows, only
the &lt;code&gt;reset&lt;/code&gt; attribute is supported.&lt;/p&gt;

&lt;p&gt;On *nix, the &lt;code&gt;Terminal&lt;/code&gt; module outputs ANSI escape sequences to
stdout, whereas on Windows it uses the console text attribute API.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why there is no cross-platform way to transform a string
into a &amp;ldquo;colored string&amp;rdquo;, because it would make no sense on Windows.&lt;/p&gt;

&lt;p&gt;Also, on *nix, color escapes will only be outputted if stdout is
a terminal and not if it&amp;rsquo;s redirected to a file or a pipe.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>time</title>
      <link>http://oocmanual.cogneco.com/sdk/os/time</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/time</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Time module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Time&lt;/code&gt; module allows for both time measurement and sleeping.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Sleep&lt;/h2&gt;

&lt;p&gt;There are three granularities for sleep: second, milli, and microseconds.
Note that each system has different guarantees as to the actual clock
granularity, but the SDK will use the most precise method available.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// sleep for one second
Time sleepSec(1)

// then for 12 milliseconds
Time sleepMilli(12)

// then for 300 microseconds
Time sleepMicro(300)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Date and time&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;dateTime&lt;/code&gt; will return the current time date and time formatted as a
human-readable string. The exact format might depend on the locale and
operating system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Today is: %s&amp;quot; printfln(Time dateTime())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;sec&lt;/code&gt; return the current hour, minute, and second.&lt;/p&gt;

&lt;p&gt;Executed at 12h34 and 56 seconds, the following will print 123456:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;%d%d%d&amp;quot; printfln(Time hour(), Time min(), Time sec())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;microtime&lt;/code&gt; returns the microseconds that have elapsed in the current
minute, whereas &lt;code&gt;microsec&lt;/code&gt; returns the microseconds that have elapsed
int he current second.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runTime&lt;/code&gt; returns the number of milliseconds elapsed since program start.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Uptime: %d seconds.&amp;quot; printfln(Time runTime() / 1_000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Measure&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;measure&lt;/code&gt; function accepts a block and returns the number of milliseconds
spent elapsing it. It might be used as a poor humanoid&amp;rsquo;s profiler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
duration := Time measure(||
    // some time-consuming task
)
&amp;quot;Huge task done in %d ms&amp;quot; printfln(duration)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>sdk</title>
      <link>http://oocmanual.cogneco.com/sdk</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;An overview of the SDK&amp;rsquo;s packages&lt;/h1&gt;

&lt;p&gt;These pages will give you an overview of what you can find in the SDK:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;lang&#34;&gt;lang&lt;/a&gt; package is imported by default in any ooc file.
It contains essentials usable without further ado in any .ooc program.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;structs&#34;&gt;structs&lt;/a&gt; package contains useful containers like
lists and hash maps, but also stacks, and more cornercase stuff like
multimaps and bags.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;io&#34;&gt;io&lt;/a&gt; package has modules for reading files, writing
to files, and other input/output related matters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;math&#34;&gt;math&lt;/a&gt; package is the home to everything numbers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;os&#34;&gt;os&lt;/a&gt; package contains lots of goodies, from time
management to terminal handling, to launching processes, reading from
pipes, getting hardware information, manipulating environment variables,
creating a parallel job pool, and even coroutines and channels!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;net&#34;&gt;net&lt;/a&gt; package has modules for relatively low-level
network operations such as creating TCP and UDP sockets, and making DNS
requests.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;text&#34;&gt;text&lt;/a&gt; package contains a Regexp class, a JSON encoder
and decoder, a simple template engine, a string tokenizer, an option
parser, and a helper classes for escape sequences.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;threading&#34;&gt;threading&lt;/a&gt; package contains all things threads.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;native&#34;&gt;native&lt;/a&gt; package should not be imported directly -
it contains platform-specific specific implementations of certain features.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>jobpool</title>
      <link>http://oocmanual.cogneco.com/sdk/os/jobpool</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/jobpool</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/JobPool module&lt;/h1&gt;

&lt;p&gt;JobPool is useful when several background tasks have to be launched in
parallel. It allows to control how many tasks are run in parallel, and to wait
until all tasks have ended.&lt;/p&gt;

&lt;p&gt;A good example of JobPool usage would be a build system, where multiple
instances of a compiler have to be ran on different files, and the number of
instances running in parallel should be limited.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;Creating a job pool is trivial:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/JobPool
pool := JobPool new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then jobs should be added. Jobs are attached to processes, so the process
must be launched beforehand.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;find&amp;quot;, &amp;quot;./&amp;quot;, &amp;quot;-name&amp;quot;, &amp;quot;*.log&amp;quot;])
p executeNoWait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then an associated job can be created and added to the pool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
job := Job new(p)
pool add(job)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;pool add&lt;/code&gt; call might block, if there already is too many
jobs running in parallel, waiting for at least one job to complete.&lt;/p&gt;

&lt;p&gt;When all jobs have been added, one can wait for all jobs to finish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exitCode := pool waitAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If at least one job failed (returned with a non-zero exit code),
&lt;code&gt;waitAll&lt;/code&gt; will return its exit code. If they all succeeded, &lt;code&gt;waitAll&lt;/code&gt;
will just return 0.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Proof of concept&lt;/h2&gt;

&lt;p&gt;To demonstrate how it works, we can launch several &lt;code&gt;sleep&lt;/code&gt; commands
in the background, and wait for them all to finish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pool := JobPool new()

for (i in 0..pool parallelism) {
    p := Process new([&amp;quot;sleep&amp;quot;, &amp;quot;1&amp;quot;])
    p executeNoWait()
    pool add(Job new(p))
}

pool waitAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program wil take about 1 second to complete, no matter the level
of parallelism. Instead of being executed sequentially (which would add
up the time of execution), they&amp;rsquo;re being executed in parallel.&lt;/p&gt;

&lt;p&gt;Note that this is a contrived example. In a real example, one would not
adjust the total number of jobs from the &lt;code&gt;pool parallelism&lt;/code&gt; setting, but
rather let the natural number of jobs be distributed by the job pool itself.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Customization&lt;/h1&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Parallelism&lt;/h2&gt;

&lt;p&gt;By default, &lt;code&gt;JobPool&lt;/code&gt; tries to have a level of parallelism (max jobs in
parallel) equal to the number of cores on the machine it&amp;rsquo;s running on.&lt;/p&gt;

&lt;p&gt;It can be adjusted by hand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// never run more that 2 jobs in parallel
pool parallelism = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Custom job&lt;/h2&gt;

&lt;p&gt;In our examples above we&amp;rsquo;ve always used the default &lt;code&gt;Job&lt;/code&gt; class. But it can be
extended as well. By making a subclass of it, we can override the &lt;code&gt;Job onExit&lt;/code&gt;
method, allowing us to take action after each job is finished.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
CompilationJob: class extends Job {
    init: func {
        p := Process new([&amp;quot;gcc&amp;quot;, &amp;quot;-v&amp;quot;])
        p executeNoWait()
        super(p)
    }

    onExit: func (code: Int) {
        if (code != 0) {
            raise(&amp;quot;Compilation failed!&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our new job type can then be used, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pool := Pool new()
for (i in 0..10) {
    pool add(CompilationJob new())
}
pool waitAll()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>system</title>
      <link>http://oocmanual.cogneco.com/sdk/os/system</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/system</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/System module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;System&lt;/code&gt; module allows to get information about the system, such
as the number of processors, as an &lt;code&gt;Int&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cores := System numProcessors()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the hostname of the machine, as a &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
hostname := System hostname()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iterators</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/iterators</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/iterators</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Iterators&lt;/h1&gt;

&lt;p&gt;Iterators are the magic that makes foreach loops work.&lt;/p&gt;

&lt;p&gt;The basic premise is that to iterate through something, you have to
be able to know if there&amp;rsquo;s anything left, via &lt;code&gt;hasNext?&lt;/code&gt;, and to
retrieve the next element, via &lt;code&gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a bonus, for safe iteration, the &lt;code&gt;remove&lt;/code&gt; method may be implemented.
If it isn&amp;rsquo;t, though, it will return false.&lt;/p&gt;

&lt;p&gt;Since iterators may iterate on all kinds of data structures, they are
generic, ie. &lt;code&gt;next&lt;/code&gt; will return a T.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a demonstration, iterating through characters of the word &lt;code&gt;hellfire&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
HellfireIterator: class extends Iterator&amp;lt;Char&amp;gt; {
    content := &amp;quot;hellfire&amp;quot;
    index := 0

    init: func

    hasNext?: func -&amp;gt; Bool {
      index &amp;lt; content size
    }

    next: func -&amp;gt; Char {
      val := content[index]
      index += 1
      val
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a foreach to work, one has to have an iterable type. Thankfully,
an &lt;code&gt;Iterator&lt;/code&gt; itself extends &lt;code&gt;Iterable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (letter in HellfireIterator new()) {
  &amp;quot;%c&amp;quot; printfln(letter)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;each and eachUntil&lt;/h2&gt;

&lt;p&gt;Apart from using foreach loops, one can use the each method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
HellfireIterator new() each(|letter|
  // do something with letter
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the eachUntil, which will break if the passed closure returns false:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
HellfireIterator new() eachUntil(|letter|
  if (letter == &#39;f&#39;) {
    return false // just hell, please
  }

  // do something with letter
  true
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;reduce&lt;/h2&gt;

&lt;p&gt;An iterable can be reduced using the &lt;code&gt;reduce&lt;/code&gt; method, accepting a
closure. It&amp;rsquo;ll get called on each pair of two elements, until there
is only one element left.&lt;/p&gt;

&lt;p&gt;Example with a list of ints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list := [1, 2, 3] as ArrayList&amp;lt;Int&amp;gt;
sum := list reduce(|a, b| a + b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;toList&lt;/h2&gt;

&lt;p&gt;Any &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; can be transformed to a &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; via the &lt;code&gt;toList&lt;/code&gt;
method. Let&amp;rsquo;s try it on a string, which is iterable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;ABC&amp;quot; toList() // gives [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>structs</title>
      <link>http://oocmanual.cogneco.com/sdk/structs</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/structs</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The structs package&lt;/h1&gt;

&lt;p&gt;A few frequently used data structures ship with the SDK.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Lists&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;structs/List&lt;/code&gt; contains the generic interface for lists, which are ordered, indexed
collections of elements of any type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list: List&amp;lt;String&amp;gt; = // something
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elements can be added to or removed from anywhere in the list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list add(&amp;quot;hi&amp;quot;) // append &amp;quot;hi&amp;quot; to the list
list add(0, &amp;quot;hoe&amp;quot;) // prepend &amp;quot;ho&amp;quot; to the list
list remove(&amp;quot;hi&amp;quot;) // remove the first element equal to &amp;quot;hi&amp;quot;
list removeAt(0) // remove the first element

list addAll(otherList) // append all elements from other list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They can also be retrieved from anywhere in the list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list get(24) == list[24] // get the 24th element
list first() // get the first element
list last() // get the last element
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number of elements in a list is available as the &lt;code&gt;size&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;There are %d elements in this list.&amp;quot; printfln(list size)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going through each element is easy as well, either using a foreach:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (elem in list) {
  elem println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or by passing a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list each(|elem|
  elem println()
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Removing all elements can be done via &lt;code&gt;clear&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list clear()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;ArrayList&lt;/h2&gt;

&lt;p&gt;An array list is backed by an array, which it grows or shrinks depending
on how many elements are in there.&lt;/p&gt;

&lt;p&gt;Removing or adding an element in the middle of an ArrayList is expensive, as
it shifts all elements after it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// constructed through successive add() calls:
a1 := ArrayList&amp;lt;Int&amp;gt; new()
a1 add(1); a1 add(2); a2 add(3)

// constructed from an array literal
a1 := [1, 2, 3] as ArrayList&amp;lt;Int&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An ArrayList can be easily converted to an array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printArray(list toArray())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;LinkedList&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;LinkedList&lt;/code&gt; is a doubly linked list, ie. each element points to the
element after it and the element before it.&lt;/p&gt;

&lt;p&gt;Unlike the ArrayList, removing or adding an element in the middle of a linked list
is inexpensive.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Maps&lt;/h1&gt;

&lt;p&gt;Maps are associative objects, ie. they associate keys to values.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;HashMap&lt;/h2&gt;

&lt;p&gt;The most oftenly used map collection is &lt;code&gt;structs/HashMap&lt;/code&gt;. It can only associate
a given key to one value. E.g. there cannot be duplicate keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map := HashMap&amp;lt;String, Int&amp;gt; new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Key-&amp;gt;value pairs are added to a HashMap using &lt;code&gt;put&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map put(&amp;quot;one&amp;quot;, 1)
map put(&amp;quot;two&amp;quot;, 2)
map put(&amp;quot;three&amp;quot;, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..and retrieved using &lt;code&gt;get&lt;/code&gt;. Key presence is tested with &lt;code&gt;containsKey?&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map get(&amp;quot;two&amp;quot;) == 2 // true
map containsKey?(&amp;quot;two&amp;quot;) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The whole point of a HashMap is that checking for presence or finding the
value corresponding to a key is faster than storing values in a list and
iterating through it entirely every time.&lt;/p&gt;

&lt;p&gt;To remove pairs, one has to specify the key:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map remove(&amp;quot;two&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A HashMap can be iterated through:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map each(|key, value|
  &amp;quot;%s =&amp;gt; %s&amp;quot; printfln(key, value)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s possible to get a list of all keys contained in a map:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map getKeys()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in a HashMap, iteration order is not guaranteed to be equivalent to
insertion order - due to the hashing done, keys might get reordered for efficiency.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;MultiMap&lt;/h2&gt;

&lt;p&gt;MultiMap is a HashMap variant that can contain multiple values for a given key.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;OrderedMultiMap&lt;/h2&gt;

&lt;p&gt;OrderedMultiMap is a MultiMap variant that will maintain the order in which keys
were inserted, for iteration.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Bag variants&lt;/h1&gt;

&lt;p&gt;In the structures presenting above, all elements must have the same type in a given
collection. Bags are different: each element can be a different type.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Cell&lt;/h2&gt;

&lt;p&gt;Actually defined in &lt;code&gt;lang/types&lt;/code&gt;, Cell can contain anything:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
intCell := Cell new(42)
stringCell := Cell new(&amp;quot;turtle&amp;quot;)
// and so on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unwrapping a cell can be done via the indexing operator &lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := cell[Int]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that unwrapping a cell with an incompatible type will throw an error.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Bag&lt;/h2&gt;

&lt;p&gt;Technically, a Bag can be seen as a list of cells, with convenience methods to
deal directly with the values contained inside the cells.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
bag := Bag new()
bag add(93) // add an Int
bag add(&amp;quot;seaside&amp;quot;) // add a String
bag add(bag) // add itself! the fun never ends.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve elements from a bag, one has to specify the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := bag get(0, Int)
title := bag get(1, String)
// and so on
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;HashBag&lt;/h2&gt;

&lt;p&gt;A HashBag maps string values to any type of value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
hash := HashBag new()
hash put(&amp;quot;number&amp;quot;, 93)
hash put(&amp;quot;title&amp;quot;, &amp;quot;seaside&amp;quot;)
hash put(&amp;quot;ourselves&amp;quot;, hash)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve elements from a &lt;code&gt;HashBag&lt;/code&gt;, one has to specify both the string key
and the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := hash get(&amp;quot;number&amp;quot;, Int)
title := hash get(&amp;quot;title&amp;quot;, String)
// etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashBags are particularly useful to represent a tree-like document, that was originally
encoded as JSON or YAML, for example.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;getPath&lt;/code&gt; method allows one to retrieve an element of a tree of &lt;code&gt;HashBag&lt;/code&gt;s and &lt;code&gt;Bag&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say the original JSON looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!json
{&amp;quot;elements&amp;quot;: {
  &amp;quot;house&amp;quot;: {},
  &amp;quot;car&amp;quot;: {
    &amp;quot;wheels&amp;quot;: [
      { &amp;quot;diameter&amp;quot;: 2 }
    ]}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One could use the following code to retrieve the diameter of the first wheel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
data: HashBag = // read from JSON
diameter := data getPath(&amp;quot;elements/car/wheels#0/diameter&amp;quot;, Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;Stacks&lt;/h1&gt;

&lt;p&gt;Stacks are list-like data structures, except their primary purpose is to have elements
pushed on top of them and popped from the top, in a LIFO (last-in, first-out) fashion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
stack := Stack&amp;lt;Int&amp;gt; new()
stack push(1). push(2). push(3)

stack pop() == 3 // true
stack pop() == 2 // also true
stack pop() == 1 // left as an exercise to the reader
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Stick&lt;/h2&gt;

&lt;p&gt;The ill-named &lt;code&gt;Stick&lt;/code&gt; data structure can be thought of as a bag stack - e.g. a Stack
that can contain any type of element.&lt;/p&gt;

&lt;p&gt;Example usage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
stick := Stick new(Float size + Object size)
stick push(1.23)
stick push(&amp;quot;Hi!&amp;quot;)

stick pop(String) == &amp;quot;Hi!&amp;quot; // true
stick pop(Float) == 1.23 // truthful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Stick&lt;/code&gt; is quite low-level - it doesn&amp;rsquo;t resize automatically, it does no
bounds checking, no type checking at all. To be used when you absolutely,
positively need to squeeze bytes together as close as possible and don&amp;rsquo;t care
about safety at all.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>math</title>
      <link>http://oocmanual.cogneco.com/sdk/math</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/math</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The math package&lt;/h1&gt;

&lt;p&gt;The math package piggybacks on libc for basic mathematical operations with
standard integer and floating point types.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;math&lt;/h1&gt;

&lt;p&gt;By simply importing &lt;code&gt;math&lt;/code&gt;, a most of the math functions from libc will get
imported.&lt;/p&gt;

&lt;p&gt;Often, math operations are available both in function form and in method form.
The function form would be similar to C, e.g.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
sin(2 * PI)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas the method form would be more.. object-oriented-ish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
2 pow(16)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Powers and roots&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;pow&lt;/code&gt; elevates the first argument to the power of the second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
2 pow(8) // 256
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exp&lt;/code&gt; returns the value of e (the base of natural logarithms) raised to the
power of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exp(2) // approx. 7.389
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sqrt&lt;/code&gt; returns the square root of a number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
144 sqrt() // 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cbrt&lt;/code&gt; returns the cube root of a number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
8 cbrt() // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Trigonometry&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PI&lt;/code&gt; is a constant defined in math as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
PI := 3.14159_26535_89793_23846_26433_83279
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;tan&lt;/code&gt;, are available, both in method and function form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
sin(2 * PI) // 0
cos(- (3 / 4) * PI) // -0.707, etc.
tan(PI / 4) // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As are their arc equivalents, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, their hyperbolic
variants, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, and their arc hyperbolic tandems,
&lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As for &lt;code&gt;atan2&lt;/code&gt;, straight from Wikipedia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In a variety of computer languages, the function atan2 is the arctangent
function with two arguments. The purpose of using two arguments instead of
one, is to gather information of the signs of the inputs in order to return
the appropriate quadrant of the computed angle, which is not possible for
the single-argument arctangent function.

For any real number (e.g., floating point) arguments x and y not both equal
to zero, atan2(y, x) is the angle in radians between the positive x-axis of
a plane and the point given by the coordinates (x, y) on it. The angle is
positive for counter-clockwise angles (upper half-plane, y &amp;gt; 0), and
negative for clockwise angles (lower half-plane, y &amp;lt; 0).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Source: &lt;a href=&#34;http://en.wikipedia.org/wiki/Atan2&#34;&gt;http://en.wikipedia.org/wiki/Atan2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Logarithms&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;log&lt;/code&gt; function returns the natural logarithm of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
log(2) // about 0.69
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;log10&lt;/code&gt; function returns the base 10 logarithm of x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
log10(4000) // about 3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Rounding and truncation&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;roundLong&lt;/code&gt; and &lt;code&gt;roundLLong&lt;/code&gt; are methods that will round to the
nearest integer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.14 round() // 3.00
4.78 roundLong() // 5
0.92 roundLLong() // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ceil&lt;/code&gt; and &lt;code&gt;floor&lt;/code&gt; methods will round to the nearest upper and lower
integer, respectively:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.14 ceil() // 4.00
8.92 floor() // 8.00
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Floating-point remainder&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;mod&lt;/code&gt; function computes the floating-point remainder of dividing x by y.
The return value is x - n * y, where n is the quotient of x / y, rounded toward
zero to an integer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12 mod(5) // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Various&lt;/h2&gt;

&lt;p&gt;To get the absolute value of a number, use &lt;code&gt;abs()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
(-4) abs() // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Random&lt;/h1&gt;

&lt;p&gt;By importing &lt;code&gt;math/Random&lt;/code&gt;, one can generate random numbers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer: neither the libc random number generator or the fast prng
exposed by math/Random are suitable for cryptographic usage. Find a library
that does it right, this was not planned for it.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When the module is loaded (probably at program start-up), the libc random
number generator will be seeded with the current time in microseconds.&lt;/p&gt;

&lt;p&gt;Then, various functions can be used to get random numbers.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;libc generator&lt;/h2&gt;

&lt;p&gt;To get any number between &lt;code&gt;INT_MIN&lt;/code&gt; and &lt;code&gt;INT_MAX&lt;/code&gt;, call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := Random random()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get any number within a range, use either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// gives a number between 0 (included) and 10 (included)
number := Random randInt(0, 10)

// gives a number between 0 (included) and 9 (included)
number = Random randRange(0, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those both have variants to get a number in a range, excluding any
number already contained in a list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get 10 unique numbers between 0 and 100
list := ArrayList&amp;lt;Int&amp;gt; new()

10 times(||
    list add(Random randInt(0, 100, list))
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pick out a random element ouf ot a list, use &lt;code&gt;choice&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get one of those 10 unique numbers we just generated:
num := Random choice(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;choice&lt;/code&gt; is generic, so it will work with lists of any
type of element.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;fast prng&lt;/h2&gt;

&lt;p&gt;Most of the methods above have a &lt;code&gt;fast&lt;/code&gt; variant, working from a PRNG (&lt;a href=&#34;http://en.wikipedia.org/wiki/Pseudorandom_number_generator&#34;&gt;pseudorandom
number generator&lt;/a&gt;) coded directly into the Random class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// all these are documented above, they work in a similar fashion
Random fastRandom()

Random fastRandInt(0, 10)
Random fastRandRange(0, 10)

Random fastRandInt(0, 10, list)
Random fastRandRange(0, 10, list)

Random fastChoice(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fast&lt;/code&gt; variants are meant to be faster, as the name implies, but they&amp;rsquo;re even
less guaranteed to have good random qualities - the numbers it generates might be
less even / repeat more easily.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lang</title>
      <link>http://oocmanual.cogneco.com/sdk/lang</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The lang package&lt;/h1&gt;

&lt;p&gt;The lang package is considered built-in: it is imported by default in ooc
modules. There is a reason for that, however - the SDK is distributed as
an ooc library itself, and as such, it has a .use file that specifies which
modules should be imported.&lt;/p&gt;

&lt;p&gt;Some of the lang package is essential, like &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Class&lt;/code&gt;, which
means that the compiler, &lt;a href=&#34;../tools/rock/&#34;&gt;rock&lt;/a&gt;, will expect them to be present,
have certain names, fields and methods. However, using a custom sdk is
possible, where the implementation for these can be swapped to something
lighter, for example.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;types&#34;&gt;Types&lt;/a&gt; section describes how Object,
 Class, and other types such as Void, Pointer, Bool, None,
 Cell are defined. It also discusses variable arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;string&#34;&gt;String&lt;/a&gt; section talks about string
 handling, the mutable variant Buffer, and formatting&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;numbers&#34;&gt;Numbers&lt;/a&gt; section talks about number
 types, either integers or floats, and the various functions available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;iterators&#34;&gt;Iterators&lt;/a&gt; section discusses
 how iterators are implemented, and what goes on behind a foreach.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;exceptions&#34;&gt;Exceptions&lt;/a&gt; section talks about
 default properties of exceptions, and how to extend them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;memory&#34;&gt;Memory&lt;/a&gt; section talks about memory
 management, mostly just how to deal with blocks of memory rather
 than more high-level data structures.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>