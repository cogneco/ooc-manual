<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Tools on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/tools/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Editors</title>
      <link>http://oocmanual.cogneco.com/tools/editors</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/editors</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;ooc support in text editors&lt;/h1&gt;

&lt;p&gt;ooc has a varying level of support among different text editors.&lt;/p&gt;

&lt;p&gt;Read on to find if your favourite flavor is supported. If you add
support for a new editor, please open an issue on the &lt;a href=&#34;https://github.com/nddrylliog/ooc-lang.org&#34;&gt;ooc-lang.org repo&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;vim&lt;/h1&gt;

&lt;p&gt;ooc support for vim is provided by the &lt;a href=&#34;https://github.com/nddrylliog/ooc.vim&#34;&gt;ooc.vim&lt;/a&gt; plug-in. It provides:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Syntax highlighting&lt;/li&gt;
&lt;li&gt;Indentation support&lt;/li&gt;
&lt;li&gt;A syntastic plug-in for use with &lt;a href=&#34;https://github.com/nddrylliog/sam&#34;&gt;sam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:make&lt;/code&gt; command support (launches &lt;code&gt;rock -v&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can read more at the &lt;a href=&#34;https://github.com/nddrylliog/ooc.vim&#34;&gt;project repository&lt;/a&gt;&amp;rsquo;s page.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;emacs&lt;/h1&gt;

&lt;p&gt;ooc support for emacs is provided by &lt;a href=&#34;https://github.com/nixeagle/ooc-mode&#34;&gt;ooc-mode&lt;/a&gt;. It provides:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Syntax highlighting&lt;/li&gt;
&lt;li&gt;Indentation support&lt;/li&gt;
&lt;li&gt;On the fly syntax check with flymake-ooc&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;TextMate&lt;/h1&gt;

&lt;p&gt;ooc support for TextMate is provided by &lt;a href=&#34;https://github.com/nilium/ooc.tmbundle&#34;&gt;ooc.tmbundle&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Atom&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://atom.io/&#34;&gt;Atom editor&lt;/a&gt; can use converted TextMate bundles.&lt;/p&gt;

&lt;p&gt;You can easily convert &lt;a href=&#34;https://github.com/nilium/ooc.tmbundle&#34;&gt;ooc.tmbundle&lt;/a&gt; for your own usage, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apm init --package ~/.atom/packages/language-ooc --convert https://github.com/nilium/ooc.tmbundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might need to restart Atom to see the changes.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Brackets&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;http://brackets.io/&#34;&gt;Brackets editor&lt;/a&gt; now has an extension for ooc syntax highlighting.
It can be installed from the Extensions Manager by searching for &lt;code&gt;ooc syntax&lt;/code&gt;.
The source is available &lt;a href=&#34;https://github.com/nddrylliog/brackets-ooc&#34;&gt;on GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;gtksourceview&lt;/h1&gt;

&lt;p&gt;gtksourceview-based tools such as gedit, meld, etc. have
ooc support out of the box.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;pygments&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://pygments.org/&#34;&gt;pygments&lt;/a&gt; has relatively good ooc support built-in. It is a python
solution for syntax highlighting used on GitHub and easy to integrate with
static website generators such as &lt;a href=&#34;http://nanoc.ws/&#34;&gt;nanoc&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drivers</title>
      <link>http://oocmanual.cogneco.com/tools/rock/drivers</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/drivers</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Compilation strategy&lt;/h1&gt;

&lt;p&gt;Unlike other compilers, rock takes care of building whole projects at
a time, not just single modules. However, how much you want to let up
to rock is your choice, thanks to different &lt;code&gt;drivers&lt;/code&gt;, or compilation strategies.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Sequence driver&lt;/h1&gt;

&lt;p&gt;This is the default driver. It&amp;rsquo;ll parse all relevant .ooc files, generate
C files, and call the C compiler to produce object files, then link the result.&lt;/p&gt;

&lt;p&gt;It can be customized using the following options:&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Parsing only&lt;/h2&gt;

&lt;p&gt;If you only want rock to make sure there are no syntax errors, using
the &lt;code&gt;--onlyparse&lt;/code&gt; option will work.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Checking only&lt;/h2&gt;

&lt;p&gt;If you want rock to parse and make sure that the code is correct ooc
(e.g. types correspond, all functions calls have corresponding definitions,
etc.), the &lt;code&gt;--onlycheck&lt;/code&gt; option will do that.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Generation only&lt;/h2&gt;

&lt;p&gt;If you just want rock to generate C files to look at what is being done
under the hood, the &lt;code&gt;--onlygen&lt;/code&gt; option can be used. They will be output
in the &lt;code&gt;rock_tmp&lt;/code&gt; (for .c files) and &lt;code&gt;.libs&lt;/code&gt; (for header files) folders by default.&lt;/p&gt;

&lt;p&gt;If the goal is to tinker with the&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Parallelism&lt;/h2&gt;

&lt;p&gt;By default, rock will attempt to max out your processors by launching C
compiler jobs in parallel. One can adjust the level of parallelism by
specifying &lt;code&gt;-jN&lt;/code&gt; to rock, where &lt;code&gt;N&lt;/code&gt; is an int. To completely disable
parallelism (ie. behave in a purely sequential way), pass &lt;code&gt;-j0&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Lib-caching&lt;/h2&gt;

&lt;p&gt;Lib-caching is very convenient, yet at the same time it can cause unforeseen
issues. The basic idea is that, between two compilations, only a portion of
generated C code is affected by the changes, there is no reason to recompile
what hasn&amp;rsquo;t changed.&lt;/p&gt;

&lt;p&gt;It is active by default, which means that even though the first compilation
might take some time, subsequent compilations will be shorter. If a compilation
seems to fail because of the remainder of previous compilations, running &lt;code&gt;rock -x&lt;/code&gt;
should fix it up.&lt;/p&gt;

&lt;p&gt;To temporarily disable lib-caching, one can use the &lt;code&gt;--nolibcache&lt;/code&gt; compiler
option.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Make driver&lt;/h1&gt;

&lt;p&gt;The make driver is particularly useful when an ooc project is to be compiled
on another platform lacking the ooc toolchain (for example, when bootstrapping
rock), or when one wants to modify the C output of rock and recompile afterwards.&lt;/p&gt;

&lt;p&gt;By using &lt;code&gt;--driver=make&lt;/code&gt;, the compile process looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
# In project directory
rock --driver=make
cd build/
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;build&lt;/code&gt; directory which is generated and populated with C files and a
stand-alone Makefile, can be packaged and distributed on other platforms.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;$GC_PATH&lt;/code&gt; environment variable might need to be adjusted for
the exported sources to build somewhere else. It could be as simple as
installing the Boehm GC in &lt;code&gt;/usr&lt;/code&gt; and setting &lt;code&gt;GC_PATH&lt;/code&gt; to &lt;code&gt;-lgc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One can use &lt;code&gt;make clean&lt;/code&gt; to clean the produced objects and binaries. Modifying
sources and partial recompilation is possible. Make accepts parallelism options
similar to rock, e.g. with 8 cores, one might want to use &lt;code&gt;make -j7&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Android driver&lt;/h1&gt;

&lt;p&gt;In spirit, the Android driver (invoked with &lt;code&gt;--driver=android&lt;/code&gt;) is similar to
the make driver, excepts that instead of generating Makefiles, it will generate
&lt;code&gt;Android.mk&lt;/code&gt; files, suitable for usage with the &lt;code&gt;ndk-build&lt;/code&gt; utility from the
Android NDK toolchain.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use-files 2</title>
      <link>http://oocmanual.cogneco.com/tools/rock/use-files2</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/use-files2</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Use files&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Use files specify the C and ooc dependencies of a library, along
with some basic info like its name, description.&lt;/p&gt;

&lt;p&gt;They are useful for package managers (see &lt;a href=&#34;https://github.com/nddrylliog/sam&#34;&gt;sam&lt;/a&gt;),
but also for the rock compile, to import required ooc libraries, and
to know which flags and libraries to pass to the C compiler.&lt;/p&gt;

&lt;p&gt;A few well-written .use files make using libraries very easy,
without having to worry about writing a Makefile of some sort, and
it makes compiling programs on various platforms a no-brainer.&lt;/p&gt;

&lt;p&gt;.use files are generally located at the root of an ooc app or library.&lt;/p&gt;

&lt;p&gt;For a language binding, the tree structure is usually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ooc-gtk
  README.md
  gtk.use
  source
    gtk
  samples
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a pure ooc library or application, the tree structure is usually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deadlogger
  README.md
  deadlogger.use
  source
    deadlogger
  samples
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Libs search path&lt;/h2&gt;

&lt;p&gt;Using a third-party ooc library is as easy as doing &lt;code&gt;use library&lt;/code&gt; in an .ooc file&lt;/p&gt;

&lt;p&gt;When doing so, the ooc compiler will look for a &lt;code&gt;library.use&lt;/code&gt; file in your lib folders.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$OOC_LIBS&lt;/code&gt; environment variable defines the lib folders, separated by &lt;code&gt;:&lt;/code&gt; on *nix,
and &amp;lsquo;;&amp;rsquo; on Windows.&lt;/p&gt;

&lt;p&gt;A simple setup is to have all your ooc libraries sitting in the same folder, for example
&lt;code&gt;$HOME/Dev/&lt;/code&gt;, with the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;someproject
  someproject.use
ooc-gtk
  gtk.use
rock
  rock.use
  sdk.use
  math.use
  pcre.use
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the standard ooc sdk is a library like any other - it has a .use file with
standard directives as defined below.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Syntax&lt;/h2&gt;

&lt;p&gt;The file is composed of key-value pairs, formatted like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Key1: Value1
Key2: Value2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whitespace around the colon &lt;code&gt;:&lt;/code&gt; doesn&amp;rsquo;t matter. For keys that accept multiple
directives like &lt;code&gt;Libs&lt;/code&gt; or &lt;code&gt;IncludePaths&lt;/code&gt;, values should be separated by commas
(and whitespace is accepted).&lt;/p&gt;

&lt;p&gt;For example, this is wrong:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Libs: -lGLU -lGL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is right:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Libs: -lGLU, -lGL
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Versioning&lt;/h2&gt;

&lt;p&gt;A use file might be versioned using version blocks, however, only some directives
are valid in a version block.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Name: SDL 2.0 OpenGL support

version (linux) {
  Libs: -lGL
}

version (apple) {
  Frameworks: Carbon, OpenGL
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Version blocks have the same syntax as in .ooc files. For more details, see the
version chapter.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Top-level directives&lt;/h2&gt;

&lt;p&gt;Those directives cannot be versioned and must appear at the top level of
a use file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Short description
Name: llama

# Longer description
Description: A lib to deal with llamas

# The version of the library
Version: 0.1.3

# Modules that are automatically imported when &#39;use&#39;-ing this library
Imports: llama/beast, llama/human

# For programs, the main ooc file to compile when rock is called without arguments
Main: llama/program

# This will be added to the list of folders the ooc compiler looks for .ooc files
SourcePath: source

# Dependencies - the &#39;use&#39; of .use files
Requires: spit
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Basic directives&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# gcc&#39;s -I
IncludePaths: /some/weird/place/include

# will be included in all files using this .use file
Includes: someheader.h, someother.h

# gcc&#39;s -L
LibPaths: /some/weird/place/include

# will be linked with the final executable
Libs: -lsomething, -lotherthing

# additional .c files to compile and link into the library/executable
Additionals: source/somefile.c
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;pkg-config packages&lt;/h2&gt;

&lt;p&gt;For many packages, there is already a pkg-config &lt;code&gt;.pc&lt;/code&gt; file with the information
needed to make it compile right. What&amp;rsquo;s more, that file is often customized depending
on what system you install the library on, which makes version blocks unnecessary.&lt;/p&gt;

&lt;p&gt;Whenever a package has a pkg-config file, it is imperative to use &lt;code&gt;Pkgs&lt;/code&gt; instead
of specifying manually &lt;code&gt;IncludePaths&lt;/code&gt;, &lt;code&gt;Includes&lt;/code&gt;, &lt;code&gt;LibPaths&lt;/code&gt;, and &lt;code&gt;Libs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, the &lt;code&gt;cairo.use&lt;/code&gt; file would probably contain:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pkgs: cairo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;pkg-config-like utilities&lt;/h2&gt;

&lt;p&gt;Sometimes, libraries ship with pkg-config-like utilities. &lt;code&gt;imlib2-config&lt;/code&gt;,
&lt;code&gt;sdl2-config&lt;/code&gt;, &lt;code&gt;llvm-config&lt;/code&gt;. Those are often used similarly as pkg-config,
except without specifying a package.&lt;/p&gt;

&lt;p&gt;When this is the case, a simple form of &lt;code&gt;CustomPkg&lt;/code&gt; does the trick:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CustomPkg: sdl2-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, others have more complex options. For those, the full power of
&lt;code&gt;CustomPkg&lt;/code&gt; is required, with 4 arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The name of the utility to run&lt;/li&gt;
&lt;li&gt;A list of arguments space-separated, always passed to the utility&lt;/li&gt;
&lt;li&gt;Equivalent to pkg-config &lt;code&gt;--cflags&lt;/code&gt; option&lt;/li&gt;
&lt;li&gt;Equivalent to pkg-config &lt;code&gt;--libs&lt;/code&gt; option&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For llvm-config, this boils down to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CustomPkg: llvm-config, core executionengine jit, --cflags, --libs --ldflags
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Custom linkers&lt;/h2&gt;

&lt;p&gt;Some C++ libraries will required a C++ linker in order to work. LLVM does.&lt;/p&gt;

&lt;p&gt;Hence, the &lt;code&gt;Linker&lt;/code&gt; directive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Linker: g++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise, the ooc compiler uses the same linker as your specified C compiler.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;OSX-specific directives&lt;/h2&gt;

&lt;p&gt;OSX has some libraries packaged in &lt;code&gt;frameworks&lt;/code&gt; instead of unix-y libs. For example,
on OSX, &lt;code&gt;-lGL&lt;/code&gt; doesn&amp;rsquo;t exist. For those cases, the &lt;code&gt;Frameworks&lt;/code&gt; directive can be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Frameworks: Carbon, OpenGL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This directive has no effect on other platforms, even outside version blocks.&lt;/p&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Android-specific directives&lt;/h2&gt;

&lt;p&gt;The android build process has some intricacies, which is why .use files can contain
android-specific directives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AndroidLibs: SDL2
AndroidIncludes: ../SDL/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These really depend on the setup of your android project but it makes sense.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AndroidLibs&lt;/code&gt; are mk dependencies that need to be built, and &lt;code&gt;AndroidIncludes&lt;/code&gt; are
include paths, relative to the subfolder of your app/library.&lt;/p&gt;

&lt;p&gt;These directives have no effect on other platforms, even outside version blocks.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Packaging</title>
      <link>http://oocmanual.cogneco.com/tools/rock/packaging</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/packaging</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;While ooc provides facilities to write highly cross-platform applications, and
makes it rather easy to develop on all these platforms, distributing standalone
applications is another matter entirely.&lt;/p&gt;

&lt;p&gt;Until a tool comes along and in the darkness binds them, this chapter documents
the manual process that goes into releasing neatly packaged software for
Windows, OSX and Linux.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Windows&lt;/h1&gt;

&lt;p&gt;Windows is surprisingly easy to package for — a 32-bit executable will happily
run on both 32-bit and 64-bit systems, there is no library path headache if you
include all the required DLLs in the same directory as the .exe, and the
current working directory is always the one with the .exe file.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Dynamic GC&lt;/h2&gt;

&lt;p&gt;If your application is multi-threaded, make sure to link with the GC
dynamically as explained in &lt;a href=&#34;/docs/tools/rock/gc/#threads&#34;&gt;the Garbage Collection chapter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you link statically with the GC and use multiple threads, chances are you
will run into very ugly memory corruption bugs that seemingly make no sense.
So, make sure to double-check that first.&lt;/p&gt;

&lt;p&gt;Since you&amp;rsquo;ll link dynamically with it, you&amp;rsquo;ll need to include &lt;code&gt;libgc-1.dll&lt;/code&gt;,
and you might also need &lt;code&gt;pthreadGC2.dll&lt;/code&gt;, which lives in &lt;code&gt;/mingw/bin/&lt;/code&gt; under
MinGW.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Resource file&lt;/h2&gt;

&lt;p&gt;To bundle an icon with your executable, and add the full program name, author,
etc, create a .rc file containing something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id ICON &amp;quot;art/foo.ico&amp;quot;
1 VERSIONINFO
FILEVERSION     1,0,0,0
PRODUCTVERSION  1,0,0,0
BEGIN
  BLOCK &amp;quot;StringFileInfo&amp;quot;
  BEGIN
    BLOCK &amp;quot;040904E4&amp;quot;
    BEGIN
      VALUE &amp;quot;CompanyName&amp;quot;, &amp;quot;Company Name&amp;quot;
      VALUE &amp;quot;FileDescription&amp;quot;, &amp;quot;Application Name&amp;quot;
      VALUE &amp;quot;FileVersion&amp;quot;, &amp;quot;1.0&amp;quot;
      VALUE &amp;quot;InternalName&amp;quot;, &amp;quot;applicationname&amp;quot;
      VALUE &amp;quot;LegalCopyright&amp;quot;, &amp;quot;Author Name&amp;quot;
      VALUE &amp;quot;OriginalFilename&amp;quot;, &amp;quot;foo.exe&amp;quot;
      VALUE &amp;quot;ProductName&amp;quot;, &amp;quot;Application Name&amp;quot;
      VALUE &amp;quot;ProductVersion&amp;quot;, &amp;quot;1.0&amp;quot;
    END
  END

  BLOCK &amp;quot;VarFileInfo&amp;quot;
  BEGIN
    VALUE &amp;quot;Translation&amp;quot;, 0x409, 1252
  END
END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adjust these values as needed. To create a high-quality &lt;code&gt;.ico&lt;/code&gt; file from a
PNG image, the usage of a tool such as &lt;a href=&#34;http://icofx.ro/&#34;&gt;IcoFX&lt;/a&gt; might be needed.&lt;/p&gt;

&lt;p&gt;Then, compile this &lt;code&gt;.rc&lt;/code&gt; file with the &lt;code&gt;windres&lt;/code&gt; command-line utility - if
you have a Makefile you might want to add a target for this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;windres -i foo.rc -o foo.res -O coff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step to include these resources is to link them with your executable.
This can be done easily if you already have a .use file, by adding a section in
a &lt;code&gt;version(windows)&lt;/code&gt; block. For example, in foo.use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Name: foo
Version: 1.0
Description: Foo builds upon bar baz and does wonderful stuff
SourcePath: source
Requires: bar, baz
Main: foo/foo

# Add resources on Windows
version (windows) {
  Libs: ./foo.res
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure to &lt;code&gt;use foo&lt;/code&gt; in the main file of your application so that rock takes
these into account. The resulting executable should have the icon built-in,
along with the author and product information you have specified in the
&lt;code&gt;foo.rc&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;Note that every time &lt;code&gt;foo.rc&lt;/code&gt; changes, it needs to be recompiled to &lt;code&gt;foo.res&lt;/code&gt;.
You don&amp;rsquo;t need to distribute either the &lt;code&gt;.rc&lt;/code&gt; or the &lt;code&gt;.res&lt;/code&gt; file with the
executable, it&amp;rsquo;s all baked in!&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;DLL dependencies&lt;/h2&gt;

&lt;p&gt;To figure out which libraries someone will need to run your application, you can use
&lt;a href=&#34;http://www.dependencywalker.com/&#34;&gt;Dependency Walker&lt;/a&gt;, also known as &lt;code&gt;depends.exe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Loading your .exe in it, with the right working directory, will allow you to
see which DLLs it loads and from where. Then, all you need is to copy those
DLLs to the directory of your application and distribute them along.&lt;/p&gt;

&lt;p&gt;Be warned: there may be several versions of a given library on your system.
Make sure to pick the right one.&lt;/p&gt;

&lt;p&gt;If your program can be launched by double-clicking on it in the Windows GUI
(instead of running it from the command-line), it&amp;rsquo;s a good sign - but it might
not be enough. Some open-source programs install libraries to system paths, and
your application may be relying on that.&lt;/p&gt;

&lt;p&gt;To make sure the application runs everywhere, testing it on a &amp;ldquo;virgin&amp;rdquo; install
of Windows is recommended. If there was a time to use a virtual machine, that
would be it.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Final notes&lt;/h2&gt;

&lt;p&gt;You can choose to generate an installer of course, but a .zip file is fine as
well.  Windows systems usually have facilities to extract .zip files without
the need for an external program.&lt;/p&gt;

&lt;p&gt;Creating a zip file can be done with the command line GNU zip utility:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zip -r Foo-1.0-Windows.zip Foo-1.0-Windows
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..or by using a graphical tool, for example, &lt;a href=&#34;http://www.7-zip.org/&#34;&gt;7-Zip&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;OSX&lt;/h1&gt;

&lt;p&gt;Releasing an app on OSX is relatively easy, as tools exist to make it easier.
64-bit executables are the norm for recent versions of Mac OS X, so there is no
pain there either.&lt;/p&gt;

&lt;p&gt;The only part where it needs a little hand holding is when creating the app
bundle.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;dylibbundler&lt;/h2&gt;

&lt;p&gt;We need to distribute libraries inside the app bundle - however, so that the
paths are resolve correctly, we&amp;rsquo;ll need to use &lt;a href=&#34;http://macdylibbundler.sourceforge.net/&#34;&gt;dylibbundler&lt;/a&gt; to modify
the executable and &amp;lsquo;fix&amp;rsquo; the paths to these libraries.&lt;/p&gt;

&lt;p&gt;With &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;, installing dylibbundler is as simple as doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install dylibbundler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step is to tell the C compiler to reserve enough room to modify the
library paths later:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rock +-headerpad_max_install_names
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we&amp;rsquo;ll have to create a folder that will be our app bundle, such as
&lt;code&gt;Foo.app&lt;/code&gt;, with the following directory structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Foo.app/
  Contents/
    Info.pList
    MacOS/
      foo
      wrapper
    Resources/
      foo.icns
    libs/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Contents/MacOS/foo&lt;/code&gt; is our executable that we have copied from before, and
&lt;code&gt;Contents/MacOS/wrapper&lt;/code&gt; will be our launcher script (described in a further
section).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Contents/MacOS&lt;/code&gt; directory should also contain any files the executable
expects to find in the current working directory when launched (e.g. for game
that would be the graphics, sounds, etc.)&lt;/p&gt;

&lt;p&gt;The next step is to dylibbundler on the executable so that libs are copied and
the paths are fixed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dylibbundler -od -b -x ./Foo.app/Contents/MacOS/helloworld -d ./Foo.app/Contents/libs/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Info.pList&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Info.pList&lt;/code&gt; file is similar to the &lt;code&gt;foo.rc&lt;/code&gt; file we discussed in the
Windows section. A stock plist file looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple Computer//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;CFBundleGetInfoString&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;Application Name&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleExecutable&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;wrapper&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;com.yourdomain.www&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleName&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;applicationname&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleIconFile&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;foo.icns&amp;lt;/string&amp;gt;
  &amp;lt;!-- Don&#39;t modify those! --&amp;gt;
  &amp;lt;key&amp;gt;CFBundleShortVersionString&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;1.0&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleInfoDictionaryVersion&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;6.0&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundlePackageType&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;APPL&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;IFMajorVersion&amp;lt;/key&amp;gt;
  &amp;lt;integer&amp;gt;0&amp;lt;/integer&amp;gt;
  &amp;lt;key&amp;gt;IFMinorVersion&amp;lt;/key&amp;gt;
  &amp;lt;integer&amp;gt;1&amp;lt;/integer&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should live in &lt;code&gt;Foo.app/Contents/Info.pList&lt;/code&gt;. Just like a Windows RC file,
it references a &lt;code&gt;foo.icns&lt;/code&gt; file. A tool like &lt;a href=&#34;http://www.img2icnsapp.com/&#34;&gt;img2icns&lt;/a&gt; can be used
to convert a high-resolution PNG image to a Mac OSX icon.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Launcher script&lt;/h2&gt;

&lt;p&gt;Finally, we have to use a launcher script so that the current working
directory of the app will be correct.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
#!/bin/bash
cd &amp;quot;${0%/*}&amp;quot;
./foo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Troubleshooting&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s not uncommon to encounter an error if an app Bundle is malformed or
otherwise problematic. Instead of double-clicking on the .app bundle to
launch it, one can open it from the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open Foo.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you get an &amp;ldquo;error -10180&amp;rdquo;, it means something went wrong while launching
the app. Make sure the files inside &lt;code&gt;Contents/MacOS/&lt;/code&gt; are executable, and
that the wrapper is trying to launch the correct executable.&lt;/p&gt;

&lt;p&gt;In doubt, running &lt;code&gt;plutil&lt;/code&gt; can help proofread the &lt;code&gt;pList&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plutil Foo.app/Contents/Info.pList
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Final notes&lt;/h2&gt;

&lt;p&gt;OSX apps are sometimes encountered as &lt;code&gt;.dmg&lt;/code&gt; files in the wild, which are
image files that contain partitions, which can be mounted and read from.
This allows a nice &amp;ldquo;drag and drop&amp;rdquo; window to be displayed.&lt;/p&gt;

&lt;p&gt;However, distributing an OSX application by just zipping up the &lt;code&gt;.app&lt;/code&gt;
bundle is acceptable. It can be done either on the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zip -r Foo.OSX.zip Foo.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;or in the graphical interface (Right Click -&amp;gt; Compress Foo.app).&lt;/p&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;Linux&lt;/h1&gt;

&lt;p&gt;Linux may be one of the comfiest platform for ooc development, but ironically,
it is one of the most painful to package standalone applications for. As a rule
of thumb, do not assume that your users will want to install libraries
themselves — always package them with the software.&lt;/p&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Multiarch&lt;/h2&gt;

&lt;p&gt;64-bit installs of Linux that aren&amp;rsquo;t multi-arch will complaing about missing
32-bit libraries, and conversely, 32-bit installs won&amp;rsquo;t be able to run a 64-bit
application at all. Which leaves us with the only option of providing both a
32-bit and a 64-bit executable.&lt;/p&gt;

&lt;p&gt;An example folder hierarchy is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo-1.0-linux/
  bin/
    foo32
    foo64
    libs32/
    libs64/
  foo.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we are going to ship dynamic libraries with the app, we should specify
the path where they are with the &lt;code&gt;-rpath&lt;/code&gt; linker option. The rock command looks
a little bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rock +-Wl,-rpath=bin/libs32 -o=foo32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;for the 32-bit version, and similarly for the 64-bit version.&lt;/p&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;Chroot&lt;/h2&gt;

&lt;p&gt;One of the easiest ways to build both a 32-bit and a 64-bit executable is to
have a 64-bit VM of Ubuntu, and set up a 32-bit chroot inside of it, then copy
files out of the chroot to retrieve the binaries and associated libraries.&lt;/p&gt;

&lt;p&gt;Setting up a chroot with debootstrap is &lt;a href=&#34;https://wiki.ubuntu.com/DebootstrapChroot&#34;&gt;documented on the Ubuntu website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_15&#34;&gt;Copying libs&lt;/h2&gt;

&lt;p&gt;To figure out the libraries you need to copy to &lt;code&gt;libs32&lt;/code&gt; or &lt;code&gt;libs64&lt;/code&gt;, the &lt;code&gt;ldd&lt;/code&gt;
command line utility can be used. Filtering its output to remove a few
libraries always present on Linux systems can help:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
ldd foo64 | egrep &amp;quot;(/usr/lib/)|(prefix64)&amp;quot; | cut -d &#39; &#39; -f 3 | egrep -v &amp;quot;lib(X|x|GL|gl|drm)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example above works for an OpenGL-based application. Copying these files
automatically can be done with a shell script such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
for l in $(ldd foo64 | egrep &amp;quot;(/usr/lib/)|(prefix64)&amp;quot; | cut -d &#39; &#39; -f 3 | egrep -v &amp;quot;lib(X|x|GL|gl|drm)&amp;quot; | tr &#39;\n&#39; &#39; &#39;); do
  cp $l libs64/
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checking that it well can be done by running &lt;code&gt;ldd bin/foo64&lt;/code&gt; in the release
directory.  Here&amp;rsquo;s some example output that shows the libs are resolved to
their relative paths:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ldd bin/foo64
libSDL2-2.0.so.0 =&amp;gt; bin/libs64/libSDL2-2.0.so.0 (0x00007fc6fa615000)
libSDL2_mixer-2.0.so.0 =&amp;gt; bin/libs64/libSDL2_mixer-2.0.so.0 (0x00007fc6f9ee0000)
libmxml.so.1 =&amp;gt; bin/libs64/libmxml.so.1 (0x00007fc6f9cd3000)
libfreetype.so.6 =&amp;gt; bin/libs64/libfreetype.so.6 (0x00007fc6f9a37000)
libyaml-0.so.2 =&amp;gt; bin/libs64/libyaml-0.so.2 (0x00007fc6f9815000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_16&#34;&gt;Launcher script&lt;/h2&gt;

&lt;p&gt;Courtesy of &lt;a href=&#34;https://twitter.com/flibitijibibo&#34;&gt;Ethan Lee&lt;/a&gt;, such a launcher script will detect the architecture
of the machine it&amp;rsquo;s running on and launch the right executable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
#!/bin/bash
# Move to the script&#39;s directory
cd &amp;quot;`dirname &amp;quot;$0&amp;quot;`&amp;quot;

# Get the kernel/architecture information
UNAME=`uname`
ARCH=`uname -m`

# Pick the proper executable
if [ &amp;quot;$ARCH&amp;quot; == &amp;quot;x86_64&amp;quot; ]; then
  ./bin/foo64
else
  ./bin/foo32
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_17&#34;&gt;Final notes&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;.tar.gz&lt;/code&gt; or &lt;code&gt;.tar.bz2&lt;/code&gt; archive formats is well-suited to distribute
applications for Linux, but &lt;code&gt;.zip&lt;/code&gt; works just as well, and &lt;code&gt;.tar.xz&lt;/code&gt; is usually
a little smaller.&lt;/p&gt;

&lt;p&gt;To create a &lt;code&gt;.tar.gz&lt;/code&gt;, do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar czvf foo-1.0-linux.tar.gz foo-1.0-linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a &lt;code&gt;.tar.bz2&lt;/code&gt;, use &lt;code&gt;cjvf&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;To create a &lt;code&gt;.tar.xz&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar cf --xz foo-1.0-linux.tar.xz foo-1.0-linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a &lt;code&gt;.zip&lt;/code&gt;, do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zip -r foo-1.0-linux.tar.zip foo-1.0-linux
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Debugging</title>
      <link>http://oocmanual.cogneco.com/tools/rock/debug</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/debug</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;Debugging applications is a natural cycle of writing software. One simply cannot
anticipate every single problem they are going to run into while using an piece
of software.&lt;/p&gt;

&lt;p&gt;For rock, since we compile to C, we can use traditional debugging tools like gdb,
and the next few sections explain exactly how.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Debug symbols&lt;/h1&gt;

&lt;p&gt;By default, rock compiles in the debug profile. The corresponding command line
option is &lt;code&gt;-pg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Not only will this pass the corresponding option to the C compiler used (gcc,
clang, etc.) but it will also:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add &lt;code&gt;#line&lt;/code&gt; directives for debuggers to map back to .ooc files&lt;/li&gt;
&lt;li&gt;Keep produced C files around for further inspection.&lt;/li&gt;
&lt;li&gt;On Linux, it&amp;rsquo;ll add -rdynamic so that all symbols are exported&lt;/li&gt;
&lt;li&gt;On OSX, it&amp;rsquo;ll run dsymutil so that a &lt;code&gt;.dSYM&lt;/code&gt; archive will be produced,
containing debug symbols.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When releasing a production build of your software, use the release profile
instead, using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rock -pr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will omit debug symbols.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Fancy backtraces&lt;/h1&gt;

&lt;p&gt;While the next sections cover using a debugger, which is a prerequisite for
pretty much all hardcore problem-solving sections, there is a way to get
information about program crashes without using a debugger.&lt;/p&gt;

&lt;p&gt;The fancy-backtrace rock extension produces output like this when a program crashes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[OutOfBoundsException in ArrayList]: Trying to access an element at offset 0, but size is only 0!
[fancy backtrace]
0     fancy_backtrace.c                                        (from C:\msys64\home\amwenger\Dev\rock\bin\fancy_backtrace.DLL)
1     BacktraceHandler backtrace_impl()  in lang/Backtrace     (at C:/msys64/home/amwenger/Dev/rock/sdk/lang/Backtrace.ooc:50)
2     BacktraceHandler backtrace()       in lang/Backtrace     (at C:/msys64/home/amwenger/Dev/rock/sdk/lang/Backtrace.ooc:243)
3     Exception addBacktrace_impl()      in lang/Exception     (at C:/msys64/home/amwenger/Dev/rock/sdk/lang/Exception.ooc:108)
4     Exception addBacktrace()           in lang/Exception     (at C:/msys64/home/amwenger/Dev/rock/sdk/lang/Exception.ooc:212)
5     Exception throw_impl()             in lang/Exception     (at C:/msys64/home/amwenger/Dev/rock/sdk/lang/Exception.ooc:177)
6     Exception throw()                  in lang/Exception     (at C:/msys64/home/amwenger/Dev/rock/sdk/lang/Exception.ooc:232)
7     ArrayList get_impl()               in structs/ArrayList  (at C:/msys64/home/amwenger/Dev/rock/sdk/structs/ArrayList.ooc:82)
8     ArrayList get()                    in structs/ArrayList  (at C:/msys64/home/amwenger/Dev/rock/sdk/structs/ArrayList.ooc:40)
9     __OP_IDX_ArrayList_Int__T()        in structs/ArrayList  (at C:/msys64/home/amwenger/Dev/rock/sdk/structs/ArrayList.ooc:290)
10    foo()                              in crash              (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:32)
11    bar()                              in crash              (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:41)
12    App runToo_impl()                  in crash              (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:72)
13    App runToo()                       in crash              (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:84)
14    __crash_closure403()               in crash              (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:67)
15    __crash_closure403_thunk()         in crash              (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:66)
16    loop()                             in lang/Abstractions  (at C:/msys64/home/amwenger/Dev/rock/sdk/lang/Abstractions.ooc:2)
17    App run_impl()                     in crash              (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:65)
18    App run()                          in crash              (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:80)
19    main()                             in                    (at C:/msys64/home/amwenger/Dev/rock/test/sdk/lang/crash.ooc:1)
20    crtexe.c                                                 (from C:\msys64\home\amwenger\Dev\rock\test\sdk\lang\crash.exe)
21    crtexe.c                                                 (from C:\msys64\home\amwenger\Dev\rock\test\sdk\lang\crash.exe)
22    BaseThreadInitThunk                                      (from C:\Windows\system32\kernel32.dll)
23    RtlUserThreadStart                                       (from C:\Windows\SYSTEM32\ntdll.dll)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the case above,&lt;/p&gt;

&lt;p&gt;Fancy backtraces works on Windows, Linux, and OSX, on both 32 and 64-bit machines.&lt;/p&gt;

&lt;p&gt;To use it, simply go in the rock directory and do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make extensions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few dependencies might be needed, such as &lt;code&gt;binutils-dev&lt;/code&gt; and &lt;code&gt;zlibg1-dev&lt;/code&gt; on
Debian, or a few brew formulas on OSX.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Fancy backtrace principle&lt;/h2&gt;

&lt;p&gt;Basically, whenever an exception is thrown, a backtrace is captured. It
contains a list of frames, e.g. the addresses of the various function calls (as
can be seen above).&lt;/p&gt;

&lt;p&gt;If an Exception isn&amp;rsquo;t caught, the program will abort, but before it does, the
backtrace captured when the exception was thrown is formatted nicely and
printed out to the standard error stream.&lt;/p&gt;

&lt;p&gt;Similarly, when the program receives a signal (such as SIGSEGV), a backtrace is
printed to help the developer know when things were wrong.&lt;/p&gt;

&lt;p&gt;Since fancy-backtrace has more dependencies than rock itself, it&amp;rsquo;s a little bit
harder to build, and that&amp;rsquo;s why it exists as a dynamic library (a .dll file on
Windows, .dylib on OSX, and .so on Linux).&lt;/p&gt;

&lt;p&gt;When a program compiled in the debug profile starts up, it attempts to load the
library. If it succeeds, it will use it to display friendly stack traces. If it
doesn&amp;rsquo;t, it will fall back to the execinfo interface (which displays only
function names, not source files or line numbers), or to&amp;hellip; nothing, on
Windows.&lt;/p&gt;

&lt;p&gt;By default, the fancy_backtrace.{dll,so,dylib} file is copied along to the rock
binary, in &lt;code&gt;${ROCK_DIST}/bin&lt;/code&gt;. An ooc executable will first look in its own
directory (useful if the application is distributed on a system that doesn&amp;rsquo;t
have rock), and will then search in the directory where the rock executable
resides (useful on a developer system).&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Fancy backtrace configuration&lt;/h2&gt;

&lt;p&gt;The default setting is to display something as helpful as possible. However, if
one wants unformatted backtraces, one may define the &lt;code&gt;RAW_BACKTRACE&lt;/code&gt;
environment variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RAW_BACKTRACE=1 ./myprogram
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To disable the usage of fancy-backtrace altogether, one may use the
&lt;code&gt;NO_FANCY_BACKTRACE&lt;/code&gt; environment variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NO_FANCY_BACKTRACE=1 ./myprogram
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Crash course in gdb&lt;/h1&gt;

&lt;p&gt;GDB, the &lt;a href=&#34;https://www.gnu.org/software/gdb/&#34;&gt;GNU Debugger&lt;/a&gt;, is the canonical tool to debug C applications compiled with gcc
(or even clang).&lt;/p&gt;

&lt;p&gt;For example, writing this in &lt;code&gt;dog.ooc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Dog: class {
    shout: func {
        raise(&amp;quot;Woops, not implemented yet&amp;quot;)
    }
}

main: func {
    work()
}

work: func {
    Dog new() shout()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compiling with &lt;code&gt;rock -pg&lt;/code&gt; gives an executable, &lt;code&gt;dog&lt;/code&gt;, and a folder with C files.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Running&lt;/h2&gt;

&lt;p&gt;We can run it with gdb like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we wanted to pass arguments we could do&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb --args dog arg1 arg2 arg3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside gdb, we are greeted with a prompt. Typing &lt;code&gt;run&lt;/code&gt; (or &lt;code&gt;r&lt;/code&gt;) for short, followed
by a line feed, runs the program. In this case, it aborts and tells us where it failed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) r
Starting program: /Users/amos/Dev/tests/dog
Reading symbols for shared libraries +.............................. done
[Exception]: Woops, not implemented yet

Program received signal SIGABRT, Aborted.
0x00007fff96b82d46 in __kill ()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Getting a backtrace&lt;/h2&gt;

&lt;p&gt;However, as-is, we don&amp;rsquo;t know much. So it died in &lt;code&gt;__kill&lt;/code&gt; — that seems to be a system
function on OSX (where this doc was written). How about a nice backtrace instead? Running
&lt;code&gt;backtrace&lt;/code&gt; or simply &lt;code&gt;bt&lt;/code&gt; will give you that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) bt
#0  0x00007fff96b82d46 in __kill ()
#1  0x00007fff8edfadf0 in abort ()
#2  0x0000000100007121 in lang_Exception__Exception_throw_impl (this=0x100230030) at Exception.ooc:205
#3  0x00000001000072a3 in lang_Exception__Exception_throw (this=0x100230030) at Exception.ooc:241
#4  0x0000000100008090 in lang_Exception__raise (msg=0x100231600) at Exception.ooc:104
#5  0x0000000100000e9b in dog__Dog_shout_impl (this=0x100238ff0) at dog.c:3
#6  0x0000000100000ef0 in dog__Dog_shout (this=0x100238ff0) at dog.ooc:11
#7  0x0000000100001131 in dog__work () at dog.ooc:12
#8  0x0000000100001102 in main (__argc2=1, __argv3=0x7fff5fbff230) at dog.ooc:8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have from left to right - the frame number, the address of the function (we
can ignore), the name of the function, then the arguments and their values, and
then the files where they were defined (if they can be found) along with the
line number.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Reading code with context&lt;/h2&gt;

&lt;p&gt;As expected, we can see ooc line numbers in the backtrace. What if we want to
investigate the code without opening the .ooc file ourselves? We can just place
ourselves in the context of frame 7 with &lt;code&gt;frame 7&lt;/code&gt; or simply &lt;code&gt;f 7&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) f 7
#7  0x0000000100001131 in dog__work () at dog.ooc:12
12      Dog new() shout()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Want more context, e.g. the lines of code around? Use &lt;code&gt;list&lt;/code&gt; (or simply &lt;code&gt;l&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) l
7   main: func {
8       work()
9   }
10
11  work: func {
12      Dog new() shout()
13  }
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Inspecting values&lt;/h2&gt;

&lt;p&gt;GDB can also print values. For example, going back to frame 2, we can inspect
the exception being thrown by using &lt;code&gt;print&lt;/code&gt; (or &lt;code&gt;p&lt;/code&gt;, for short):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) f 2
#2  0x0000000100007121 in lang_Exception__Exception_throw_impl (this=0x100230030) at Exception.ooc:205
205             abort()
(gdb) p this
$4 = (lang_Exception__Exception *) 0x100230030
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting an address is not that useful, though, how about printing the content
of an object instead? We can dereference the object from within gdb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p *this
$10 = {
  __super__ = {
    class = 0x100047e60
  },
  backtraces = 0x100234f40,
  origin = 0x0,
  message = 0x100231600
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What if we want to read the message? Since it&amp;rsquo;s an ooc String, we&amp;rsquo;ll need to
print the content of the underlying buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p *this.message._buffer
$11 = {
  __super__ = {
    __super__ = {
      class = 0x100047490
    },
    T = 0x1000478c0
  },
  size = 26,
  capacity = 0,
  mallocAddr = 0x0,
  data = 0x10002fe24 &amp;quot;Woops, not implemented yet&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Inspecting generics&lt;/h2&gt;

&lt;p&gt;Inspecting generics is a bit trickier - one has to cast it directly to the
right type. For example, the &lt;code&gt;Exception&lt;/code&gt; class has a LinkedList of backtraces,
which is a generic type. We can inspect it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p *this.backtraces
$21 = {
  __super__ = {
    __super__ = {
      __super__ = {
        __super__ = {
          class = 0x10004b2b0
        },
        T = 0x100047df0
      }
    },
    equals__quest = {
      thunk = 0x10001a660,
      context = 0x0
    }
  },
  _size = 0,
  head = 0x100239f60
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not so useful. What about head?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p *this.backtraces.head
$22 = {
  __super__ = {
    class = 0x10004b4a0
  },
  T = 0x100047df0,
  prev = 0x100239f60,
  next = 0x100239f60,
  data = 0x100238fe0 &amp;quot;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks like a node from a doubly-linked list. We&amp;rsquo;re on the right track! However,
data is printed as a C string (since generics are &lt;code&gt;uint8_t*&lt;/code&gt; under the hood, and
&lt;code&gt;uint8_t&lt;/code&gt; is usually typedef&amp;rsquo;d to &lt;code&gt;char&lt;/code&gt;). We can cast it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p (lang_types__Pointer) *this.backtraces.head.data
$24 = (lang_types__Pointer) 0x0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which seems about right, as the exception has not been re-thrown (obviously the
example here is rather specific, but the general techniques can be applied to any
ooc application).&lt;/p&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Breakpoints&lt;/h2&gt;

&lt;p&gt;What if we want to inspect values somewhere the program wouldn&amp;rsquo;t stop naturally?
In the program above, we could set up a breakpoint when the constructor of &lt;code&gt;Dog&lt;/code&gt;
is called.&lt;/p&gt;

&lt;p&gt;It can be non-trivial to determine the C symbol corresponding to an ooc function.
Tab-completion is here to the rescue though - typing &lt;code&gt;break dog_&lt;/code&gt; and then hitting
Tab twice will display a helpful list of symbols:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) break dog_&amp;lt;TAB&amp;gt;&amp;lt;TAB&amp;gt;
dog__Dog___defaults__       dog__Dog___load__           dog__Dog_init               dog__Dog_shout              dog__work
dog__Dog___defaults___impl  dog__Dog_class              dog__Dog_new                dog__Dog_shout_impl         dog_load
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we seem to want &lt;code&gt;dog__Dog_new&lt;/code&gt;. As a rule, we have &lt;code&gt;packagename__ClassName_methodName_suffix&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Setting up the break point does nothing until we run the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) break dog__Dog_new
Breakpoint 1 at 0x100000f3a: file dog.ooc, line 1.
(gdb) r
Starting program: /Users/amos/Dev/tests/dog
Reading symbols for shared libraries +.............................. done

Breakpoint 1, dog__Dog_new () at dog.ooc:1
1   Dog: class {
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Stepping&lt;/h2&gt;

&lt;p&gt;From there, we can investigate as before, with &lt;code&gt;backtrace&lt;/code&gt;, &lt;code&gt;frame&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, etc. We can also decide
to step line by line. Using &lt;code&gt;step&lt;/code&gt; will enter the functions being called, whereas &lt;code&gt;next&lt;/code&gt; will skip them
and return to the prompt when the functions have fully executed.&lt;/p&gt;

&lt;p&gt;The shorthand for &lt;code&gt;step&lt;/code&gt; is &lt;code&gt;s&lt;/code&gt;, and the shorthand for next is &lt;code&gt;n&lt;/code&gt;. When we step, we can see everything
being executed, including string and object allocation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) s
dog__Dog_class () at dog.ooc:25
Line number 25 out of range; dog.ooc has 13 lines.
(gdb)
Line number 26 out of range; dog.ooc has 13 lines.
(gdb)
Line number 27 out of range; dog.ooc has 13 lines.
(gdb)
lang_types__Object_class () at types.ooc:55
55          if(object) {
(gdb)
dog__Dog_class () at dog.ooc:28
Line number 28 out of range; dog.ooc has 13 lines.
(gdb)
Line number 29 out of range; dog.ooc has 13 lines.
(gdb)
lang_String__makeStringLiteral (str=0x10002fe20 &amp;quot;Dog&amp;quot;, strLen=3) at String.ooc:377
377     String new(Buffer new(str, strLen, true))
(gdb)
lang_Buffer__Buffer_new_cStrWithLength (s=0x10002fe20 &amp;quot;Dog&amp;quot;, length=3, stringLiteral__quest=true) at Buffer.ooc:59
59      init: func ~cStrWithLength(s: CString, length: Int, stringLiteral? := false) {
(gdb)
lang_Buffer__Buffer_class () at Buffer.ooc:157
157     clone: func ~withMinimum (minimumLength := size) -&amp;gt; This {
(gdb)
158         newCapa := minimumLength &amp;gt; size ? minimumLength : size
(gdb)
163         copy
(gdb)
0x00000001000050dd in lang_Buffer__Buffer_new_cStrWithLength (s=0x10002fe20 &amp;quot;Dog&amp;quot;, length=3, stringLiteral__quest=true) at Buffer.ooc:59
59      init: func ~cStrWithLength(s: CString, length: Int, stringLiteral? := false) {
(gdb)
lang_types__Class_alloc__class (this=0x100047490) at types.ooc:54
54          object := gc_malloc(instanceSize) as Object
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that some line numbers seem to be problematic here - but we still get to see which parts of the
code get executed and in which order. Instead of typing &lt;code&gt;s&lt;/code&gt; every time, we can just hit Enter to
re-execute the last command.&lt;/p&gt;

&lt;p&gt;When we&amp;rsquo;re done stepping and just want to resume program execution, we can use &lt;code&gt;continue&lt;/code&gt; (or &lt;code&gt;c&lt;/code&gt; for short).&lt;/p&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Quitting&lt;/h2&gt;

&lt;p&gt;When we&amp;rsquo;re done running gdb, we can quit with &lt;code&gt;quit&lt;/code&gt; (or &lt;code&gt;q&lt;/code&gt; for short). It might ask for confirmation
if the program is still running, but otherwise, it&amp;rsquo;s all good.&lt;/p&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;Attaching to a process&lt;/h2&gt;

&lt;p&gt;Up to there, we have seen how to run a program from gdb. What if we want to attach gdb to a process that has been
launched somewhere else? Let&amp;rsquo;s try with this program, &lt;code&gt;sleep.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Time
main: func {
    while (true) {
        doThing()
        Time sleepSec(1)
    }
}

doThing: func {
    &amp;quot;Hey!&amp;quot; println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compiling it with &lt;code&gt;rock -pg&lt;/code&gt; and running it with &lt;code&gt;./sleep&lt;/code&gt; prints &lt;code&gt;Hey!&lt;/code&gt; every second, as expected.&lt;/p&gt;

&lt;p&gt;To attach to this process, we need to find out its process ID. We can either use the &lt;code&gt;ps&lt;/code&gt; command line
utility, or we can interrupt its execution with &lt;code&gt;Ctrl-Z&lt;/code&gt; (in most shells, like bash, zsh, etc.). You
might see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;amos at coyote in ~/Dev/tests
$ ./sleep
Hey!
Hey!
Hey!
^Z
[1]  + 48130 suspended  ./sleep
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the process ID is &lt;code&gt;48130&lt;/code&gt; here. We can attach gdb to that process like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb attach 48130
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When attaching to a process, GDB will pause execution, waiting for orders. Quitting gdb
will then detach gdb from the process, which will resume execution.&lt;/p&gt;

&lt;p&gt;If you need to quit the process, you can bring it back to the front with the &lt;code&gt;fg&lt;/code&gt; shell
command, then exit it with &lt;code&gt;Ctrl-C&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;Other tips&lt;/h1&gt;

&lt;h2 id=&#34;toc_16&#34;&gt;ooc vs C line numbers&lt;/h2&gt;

&lt;p&gt;By default, rock will output &amp;lsquo;sourcemaps&amp;rsquo;, mapping C code back to the original ooc
code that generated it. This allows the debugger to display ooc line numbers, as seen
above. This behavior can be disabled with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rock --nolines
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In which case gdb will fall back to displaying C line numbers (corresponding to the files
generated by rock). This can be useful if you suspect that rock is generating invalid code,
or if the ooc line numbers are messed up for some reason.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Garbage Collection</title>
      <link>http://oocmanual.cogneco.com/tools/rock/gc</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/gc</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Garbage Collection in rock&lt;/h1&gt;

&lt;p&gt;rock uses the &lt;a href=&#34;http://www.hpl.hp.com/personal/Hans_Boehm/gc/&#34;&gt;Boehm GC&lt;/a&gt;. It is a conservative garbage collector that
tends to play well with C libraries, hence the choice for a &amp;ldquo;compile-to-C&amp;rdquo;
implementation of ooc.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Distribution&lt;/h2&gt;

&lt;p&gt;The Boehm GC (along with &lt;code&gt;lib_atomic_ops&lt;/code&gt;) is vendored in rock&amp;rsquo;s repository,
under &lt;code&gt;libs/&lt;/code&gt;. When building the compiler, rock&amp;rsquo;s Makefile will check for an
installed GC version and, if absent, it will compile its own.&lt;/p&gt;

&lt;p&gt;Depending on your platform, the static version of the library compiled when
building rock might be in the following places:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Linux: `rock/libs/linux32` or `rock/libs/linux64`, as `libgc.a`
* OSX: `rock/libs/osx`
* Windows: `rock/libs/win32`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, rock links statically with the GC. However, for multithreaded
applications on Windows, that might not be such a good idea. Read on for
more details.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Threads&lt;/h2&gt;

&lt;p&gt;On Windows, for the GC to work correctly, it has to be linked dynamically,
not statically. At some point, rock should handle that case itself, but for
now here&amp;rsquo;s what you have to do.&lt;/p&gt;

&lt;p&gt;The first step is to build your own copy of the GC. Thanks to &lt;a href=&#34;https://github.com/nddrylliog/winbrew&#34;&gt;winbrew&lt;/a&gt;,
that is as easy as doing &lt;code&gt;brew install bdw-gc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You should now have Boehm-GC-related files in both &lt;code&gt;/usr/local/lib&lt;/code&gt; and
&lt;code&gt;/usr/local/bin&lt;/code&gt; (&lt;code&gt;/usr/local&lt;/code&gt; being mapped to a Windows path like &lt;code&gt;C:\MinGW\msys\1.0\local&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;To make rock use that version, simply do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rock --gc=dynamic -I/usr/local/include -L/usr/local/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;and when distributing applications, include &lt;code&gt;libgc-1.dll&lt;/code&gt; with it. See the &lt;a href=&#34;/docs/tools/rock/packaging/&#34;&gt;Packaging&lt;/a&gt;
chapter for more details.&lt;/p&gt;

&lt;p&gt;Linking dynamically with the GC on other platforms is as simple as using &lt;code&gt;--gc=dynamic&lt;/code&gt; - the
&lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; options above are just to add include paths and library paths, since homebrew installs
libraries in its own prefix.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Disabling the GC&lt;/h2&gt;

&lt;p&gt;One can prevent rock from linking with the GC with the command line option &lt;code&gt;--gc=off&lt;/code&gt;. Keep in mind
that the SDK was written with the GC in mind though.&lt;/p&gt;

&lt;p&gt;When the GC is disabled, &lt;code&gt;version(gc)&lt;/code&gt; block will get discarded, and &lt;code&gt;version(!gc)&lt;/code&gt; blocks will be
used. You can use this to write both GC and non-GC friendly code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rock</title>
      <link>http://oocmanual.cogneco.com/tools/rock</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;About Rock&lt;/h1&gt;

&lt;p&gt;Rock is the main ooc compiler. It parses ooc files using nagaqueen, does some
checking and inference, produces .c files, and then drives the C compilation process
to produce either an executable or a library.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/basic/&#34;&gt;Basic usage&lt;/a&gt; section explains how to quickly get
up and running, using rock to compile ooc projects.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/drivers/&#34;&gt;Drivers&lt;/a&gt; section gives an overview of rock&amp;rsquo;s various
drivers, akin to compiling strategies, like the sequence driver (default), the make
driver, and the android driver.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/advanced/&#34;&gt;Advanced usage&lt;/a&gt; section covers some less-often used
options like using a different C compiler, keeping source files, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/usefiles/&#34;&gt;Usefiles&lt;/a&gt; section describes the format of &lt;code&gt;.use&lt;/code&gt; files,
which define the characteristics of an ooc app or library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/gc/&#34;&gt;Garbage Collection&lt;/a&gt; section talks about the Garbage Collection
strategy in rock, how to make sure things work well on different plaforms, how the
Boehm GC is bundled, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/debug/&#34;&gt;Debugging&lt;/a&gt; section talks about what to do when a program
doesn&amp;rsquo;t behave correctly. Debug symbols, stack traces, debugging on particularly painful
platforms like Windows.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/packaging/&#34;&gt;Packaging&lt;/a&gt; section talks about releasing standalone
applications coded in ooc, such as games — when you don&amp;rsquo;t want to have users install
dependencies on their own, but would rather bundle everything together.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Tools</title>
      <link>http://oocmanual.cogneco.com/tools</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Frequently used ooc tools&lt;/h1&gt;

&lt;p&gt;There are some tools you should know about when you start looking into ooc.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;rock&#34;&gt;Rock&lt;/a&gt; is the ooc compiler. In most cases,
you will use it to generate C sources and executables from your ooc sources.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;sam&#34;&gt;Sam&lt;/a&gt; helps you to keep all your libraries together and up-to-date.
It&amp;rsquo;s also able to resolve dependencies without any hassle.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;editors&#34;&gt;Editors&lt;/a&gt; - describes how to get syntax highlighting,
program checking, indentation in vim, emacs, TextMate?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tools like autoconf, automake, even CMake, are irrelevant in the context of
ooc, since rock drives the whole compilation process.&lt;/p&gt;

&lt;p&gt;ooc libraries have one, standardized way to be built - as such, the ooc ecosystem
is a lot more homogenous than, say, the C ecosystem. Complexity is dealt with
through &lt;a href=&#34;rock/usefiles&#34;&gt;use files&lt;/a&gt; and the such.&lt;/p&gt;

&lt;p&gt;Still, the ooc toolchain is quite flexible, working on major desktop OSes, and
more constrained platform such as Android.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advanced Usage</title>
      <link>http://oocmanual.cogneco.com/tools/rock/advanced</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/advanced</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Using more Rock options&lt;/h1&gt;

&lt;p&gt;Often, rock does the right thing by itself, but if it doesn&amp;rsquo;t, you can use some of these more
advanced options and flags.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Keep the C sources&lt;/h1&gt;

&lt;p&gt;If rock somehow generates invalid C code and you want to know why, it can be helpful to actually
take a look at all the C. Normally, rock deletes everything it has generated at exit, but you can
tell rock to keep the sources for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock --noclean ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Afterwards, you&amp;rsquo;ll find the C source files in corresponding subdirectories of &lt;code&gt;rock_tmp&lt;/code&gt;. The header
files reside in &lt;code&gt;.libs&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;More information&lt;/h1&gt;

&lt;p&gt;Also useful in these cases: Let rock tell its story of compilation. That means: print everything about
all stages of symbol resolution and code generation. Invoke rock with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -vv ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Ditch gcc for your compiler of choice&lt;/h1&gt;

&lt;p&gt;Since gcc is the evergreen of compilers, rock uses it by default. In case you want to use something else
to turn your C sources into machine code, rock provides you with some alternatives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock --gcc # if you change your mind
rock --tcc # the tiny c compiler
rock --icc # the intel c compiler
rock --clang # llvm&#39;s clang
rock --onlygen # no compiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The latter is especially useful if you want to compile your C code to assembler by hand.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Basic Usage</title>
      <link>http://oocmanual.cogneco.com/tools/rock/basic</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/basic</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Using rock, the basic way&lt;/h1&gt;

&lt;p&gt;If you have a usefile, calling rock is pretty easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will look for usefiles in your current directory and, if possible, build them.&lt;/p&gt;

&lt;p&gt;Since the world is not always perfect, it&amp;rsquo;s also possible to pass an &lt;code&gt;.ooc&lt;/code&gt; file directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock mmorpg.ooc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sadly, it&amp;rsquo;s possible that rock thinks your ooc code is alright and passes the C files to your
C compiler which then prints pages of errors and explodes subsequently.
In that case, you&amp;rsquo;ll need to increase rock&amp;rsquo;s verbosity to see the compiler output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -v ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Building an executable and tired of typing &lt;code&gt;./mmorpg&lt;/code&gt; all over again?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -r ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will run your executable after having built it successfully.&lt;/p&gt;

&lt;p&gt;To speed up the compilation process and to save you some time, rock caches compiled dependencies
in a hidden subdirectory called &lt;code&gt;.libs&lt;/code&gt;. In most cases, this is awesome, but sometimes, something
goes wrong and you get pretty strange unexplainable error messages. Just to be sure, you can just&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then, recompile and see if it works.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sam</title>
      <link>http://oocmanual.cogneco.com/tools/sam</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/sam</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;About sam&lt;/h1&gt;

&lt;p&gt;sam is a minimal package and dependency manager for ooc projects. It operates
similarly to &lt;a href=&#34;https://brew.sh&#34;&gt;homebrew&lt;/a&gt; for OS X, but in a much more minimal way.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Installation&lt;/h1&gt;

&lt;p&gt;To use sam, apart from a working &lt;a href=&#34;/docs/tools/rock/&#34;&gt;rock&lt;/a&gt;, you need &lt;a href=&#34;http://git-scm.com/&#34;&gt;git&lt;/a&gt;.
Also, you have to create a special directory that is writable for you, which will
later contain all ooc packages cloned from their git repositories. This directory
is called the ooc library path &amp;ndash; you also have to specify its location in the special
&lt;code&gt;OOC_LIBS&lt;/code&gt; environment variable. On most unixes, you can do that like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
mkdir ~/development/ooc
export OOC_LIBS=~/development/ooc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step, you can use git to clone sam itself. You should clone sam into
a subdirectory of the newly created directory. Since sam does not have any dependencies
apart from rock, you can just go ahead and compile it &lt;a href=&#34;/docs/tools/rock/usefiles/&#34;&gt;from the usefile&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
cd $OOC_LIBS
git clone https://github.com/nddrylliog/sam.git
cd sam/
rock -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should proeduce a &lt;code&gt;sam&lt;/code&gt; executable. Just add it to the path:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
export PATH=$PATH:$OOC_LIBS/sam
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should now be able to invoke sam just by typing&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
sam
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Concepts&lt;/h1&gt;

&lt;p&gt;All ooc projects known to mankind are hosted on github. Therefore, building a
package manager, it makes sense to focus on git as the primary way of code
distribution.&lt;/p&gt;

&lt;p&gt;In general, sam consists of a simple executable and a collection of package files:
It keeps a &lt;a href=&#34;https://github.com/nddrylliog/sam/tree/master/library&#34;&gt;grimoire&lt;/a&gt; of
package metadata, so-called formulas.
In a way, this is ooc&amp;rsquo;s central package repository, similar to
Python&amp;rsquo;s PyPI, but much simpler. Every package is represented by a single YAML file.
For now, the only supported (and required) option is &lt;code&gt;Origin&lt;/code&gt; containing the URL
of the corresponding git repository.&lt;/p&gt;

&lt;p&gt;For example, the &lt;a href=&#34;https://github.com/nddrylliog/sam/blob/master/library/sdl2.yml&#34;&gt;SDL2 formula&lt;/a&gt;
just says:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Origin: https://github.com/geckojsc/ooc-sdl2.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which tells sam that it can find the current ooc-sdl2 code at the given git repository.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Getting serious&lt;/h1&gt;

&lt;p&gt;sam assumes a few basic things about a package and its repository layout:&lt;/p&gt;

&lt;p&gt;Every package has a unique name and a unique git repository, and every
git repository contains a usefile named exactly like the package. This
enables sam to identify a package by its unique name, clone the right git
repository, find the correct &lt;a href=&#34;/docs/tools/rock/usefiles/&#34;&gt;usefile&lt;/a&gt; and build the package easily.&lt;/p&gt;

&lt;p&gt;Say you are building an ooc project depending on
&lt;a href=&#34;https://github.com/nddrylliog/deadlogger&#34;&gt;deadlogger&lt;/a&gt;
and &lt;a href=&#34;https://github.com/geckojsc/ooc-mxml&#34;&gt;ooc-mxml&lt;/a&gt;. Looking into
the &lt;a href=&#34;https://github.com/nddrylliog/sam/tree/master/library&#34;&gt;grimoire&lt;/a&gt;, you can figure out the package names and
add the following to your usefile (called &lt;code&gt;toast.use&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Name: toast
Description: open toaster firmware
...
Requires: deadlogger, mxml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let sam do the hard work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
sam get toast.use
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will check if you already have deadlogger and mxml installed in your ooc library
path and clone all missing dependencies. Afterwards, you can just type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and rock will read your usefile, find all dependencies (sam just made sure we
have them!) and compile your project.&lt;/p&gt;

&lt;p&gt;Since the formulas reside in a git repository, your local clone will get out of
date from time to time when new formulas are added in the origin repository.
In that case, just run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
sam update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to get the latest formulas and recompile sam automatically.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Developing a package?&lt;/h1&gt;

&lt;p&gt;As mentioned above, the &lt;a href=&#34;https://github.com/nddrylliog/sam/tree/master/library&#34;&gt;grimoire&lt;/a&gt; can be seen as the ooc package index.
Therefore, it is important to include as many packages as possible.&lt;/p&gt;

&lt;p&gt;So, if you&amp;rsquo;re developing some open source ooc project, please go ahead, clone
the &lt;a href=&#34;https://github.com/nddrylliog/sam&#34;&gt;sam repository&lt;/a&gt;, add a formula and file a
&lt;a href=&#34;https://github.com/nddrylliog/sam/pulls&#34;&gt;pull request&lt;/a&gt;. Everybody wins!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use-files</title>
      <link>http://oocmanual.cogneco.com/tools/rock/use-files</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/use-files</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Usefiles explained&lt;/h1&gt;

&lt;p&gt;A usefile describes an ooc package, ie. a collection of modules and contains information
how to compile and link that specific collection of ooc files.
It also denotes if the package should compile to an executable or a shared/static library.&lt;/p&gt;

&lt;p&gt;Usefiles are not a totally novel concept. They are comparable to &lt;code&gt;pkg-config&lt;/code&gt; files or, to
some degree, similar to build system files like CMake or SCons.&lt;/p&gt;

&lt;p&gt;However, in ooc, (and this is a pretty new thing!),
the compiler rock itself reads and handles these usefiles.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Examples&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s start off with some examples. Following is the repository structure of
&lt;a href=&#34;https://github.com/nddrylliog/ooc-zeromq&#34;&gt;ooc-zeromq&lt;/a&gt;, a &lt;a href=&#34;http://zeromq.org&#34;&gt;zeromq&lt;/a&gt; binding
for ooc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── LICENSE
├── README.md
├── samples
│   ├── ...
├── source
│   └── zeromq.ooc
└── zeromq.use
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s assume that you cloned the repository into a subdirectory of your ooc library path
(which consists of the paths in the &lt;code&gt;OOC_LIBS&lt;/code&gt; environment variable).&lt;/p&gt;

&lt;p&gt;And here are the contents of &lt;code&gt;zeromq.use&lt;/code&gt; (shortened for brevity):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Name: zeromq
Description: The 0MQ lightweight messaging kernel
Version: 2010-06-16
SourcePath: source
Includes: zmq.h
Libs: -lzmq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A usefile should always contain the name, description and version of its package.&lt;/p&gt;

&lt;p&gt;In addition, this usefile tells rock that the actual ooc files reside in the subdirectory
&lt;code&gt;source&lt;/code&gt; (which will be added to the so-called sourcepath).&lt;/p&gt;

&lt;p&gt;Also, since this is a C library binding, the zeromq C header needs to be included,
and the &lt;code&gt;-lzmq&lt;/code&gt; flag needs to be passed to the linker.&lt;/p&gt;

&lt;p&gt;So far so good. But what are the benefits of writing such a file?&lt;/p&gt;

&lt;p&gt;If you now want to use this package in any of your projects, you can just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
use zeromq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;at the top of your ooc file, and rock will automatically look through your library path
(the paths in the &lt;code&gt;OOC_LIBS&lt;/code&gt; environment variable) for a file called &lt;code&gt;zeromq.use&lt;/code&gt; and find
the usefile above. Now it parses this usefile and instantly knows not only where it can
find the ooc-zeromq ooc files, but also what C headers need to be included and
what libraries need to be linked.&lt;/p&gt;

&lt;p&gt;As a result, you can now just import the ooc-zeromq ooc file like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import zeromq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and hack away.&lt;/p&gt;

&lt;p&gt;Another simpler example is the &lt;a href=&#34;https://github.com/nddrylliog/sam&#34;&gt;sam&lt;/a&gt; usefile. sam is
different because it compiles to an executable file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Name: sam
Description: Sam keeps your ooc repos up to date
SourcePath: source
Main: sam.ooc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, the usefile contains name and description (no version here, though!) and
the sourcepath.&lt;/p&gt;

&lt;p&gt;The new thing: &lt;code&gt;Main&lt;/code&gt; denotes the entry point for the executable, e.g. the file
containing the &lt;code&gt;main&lt;/code&gt; function. rock looks for a file named this in the source path,
which here contains the subdirectory source/.&lt;/p&gt;

&lt;p&gt;To build sam, you can now just run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which will look for a usefile in your current directory and build the package. As a result,
you get a &lt;code&gt;sam&lt;/code&gt; executable &amp;ndash; and all of that without using a third party build system!&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Fields&lt;/h1&gt;

&lt;p&gt;A list of all currently supported fields in usefiles follows.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Description&lt;/code&gt; and &lt;code&gt;Version&lt;/code&gt; contain metadata about the package
and version&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pkgs&lt;/code&gt; contains a comma-separated list of &lt;code&gt;pkg-config&lt;/code&gt; packages this
package depends on. rock will invoke &lt;code&gt;pkg-config&lt;/code&gt; with these packages
and add the resulting C flags and linker flags to its pipeline&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CustomPkg&lt;/code&gt; can be used to specify the name of a &lt;code&gt;pkg-config&lt;/code&gt;-like tool
that should be used instead. For example, the ooc sdl2 binding sets
this to &lt;code&gt;sdl2-config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Libs&lt;/code&gt; contains a comma-separated list of linker flags like &lt;code&gt;-lSDL2_image&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Frameworks&lt;/code&gt;: OSX-only, specify Frameworks to be linked with (example: &lt;code&gt;OpenGL&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Includes&lt;/code&gt; can be used to specify C headers that should be included
(as a comma-separated list)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PreMains&lt;/code&gt;: List of compiler flags that, if specified from a .pc file or a .use file,
(maybe conditioned by a version block), must appear before the main compilation unit.
Example: &lt;code&gt;-lSDL2main&lt;/code&gt; on Windows.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Linker&lt;/code&gt; can be used to specify a &lt;code&gt;ld&lt;/code&gt; replacement&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LibPaths&lt;/code&gt; and &lt;code&gt;IncludePaths&lt;/code&gt; are comma-separated lists and contain
paths that should be added to the linker or C include paths&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AndroidLibs&lt;/code&gt;, &lt;code&gt;AndroidIncludePaths&lt;/code&gt;: Android-specific properties that are
only used with the Android driver.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Additionals&lt;/code&gt;: can be used to add &lt;code&gt;.c&lt;/code&gt; files to be compiled along with the .ooc code.
Relative paths (starting with &lt;code&gt;./&lt;/code&gt;) will have the .c file be copied locally.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Requires&lt;/code&gt; can be used to specify requirements (denoted by usefile
names), for example for sam&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SourcePath&lt;/code&gt; can be used to add a path to the source path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Imports&lt;/code&gt; contains a comma-separated list of modules that should be
implicitly imported when &lt;code&gt;use yourusefile&lt;/code&gt; is used.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Origin&lt;/code&gt; is ignored by rock, but it traditionally specifies the
git repository url of that package&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Main&lt;/code&gt; is the name of the entrypoint file&lt;/li&gt;
&lt;li&gt;all fields starting with &lt;code&gt;_&lt;/code&gt; are ignored by rock&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Version blocks&lt;/h1&gt;

&lt;p&gt;Similarily to ooc&amp;rsquo;s &lt;a href=&#34;/docs/lang/preprocessor/#version-blocks&#34;&gt;version blocks&lt;/a&gt;, usefile version blocks
can be used to work with different requirements on different platforms.&lt;/p&gt;

&lt;p&gt;The syntax is similar to version blocks in ooc. Here is an example from
&lt;a href=&#34;https://github.com/nddrylliog/isaac-paper&#34;&gt;Paper Isaac&lt;/a&gt;&amp;rsquo;s usefile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Name: isaac
Version: 0.1
Requires: dye, bleep, gnaar
SourcePath: source
Main: isaac

version (windows) {
  Libs: ./isaac.res
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compiling under windows, the linker command line will contain the additional file
&lt;code&gt;./isaac.res&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>