<!DOCTYPE html>
<html>
	<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<title> Tuples &middot; The OOC Manual </title>
	
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/reset.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/text.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/color.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/layout.css">
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://oocmanual.cogneco.com/apple-touch-icon-144-precomposed.png">
	<link rel="shortcut icon" href="http://oocmanual.cogneco.com/favicon.ico">
	
	<link href="" rel="alternate" type="application/rss+xml" title="The OOC Manual" />
</head>

	<body>
		<header>
  <h1><a href="http://oocmanual.cogneco.com">The OOC Manual</a></h1>
  <p></p>
</header>

		<nav>
	<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/introduction">Introduction</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language">Language</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/modules">Modules</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/values">Values</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/tuples">Tuples</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/control-structures">Control Structures</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/collections">Collections</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/functions">Functions</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/first-class-functions">First-class Functions</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/classes">Classes</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/constructors">Constructors</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/properties">Properties</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/operators">Operators</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/interfaces">Interfaces</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/covers">Covers</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/covers-vs-classes">Covers vs Classes</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/enumerations">Enumerations</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/generics">Generics</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/generics2">Generics 2</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/exceptions">Exceptions</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/preprocessor">Preprocessor</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/version-blocks">Version</a>
		
	</li>
	
</ul>


		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools">Tools</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock">Rock</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/basic">Basic Usage</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/drivers">Drivers</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/advanced">Advanced Usage</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/use-files">Use-files</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/use-files2">Use-files 2</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/gc">Garbage Collection</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/debug">Debugging</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/packaging">Packaging</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/sam">Sam</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/editors">Editors</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/troubleshooting">Troubleshooting</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk">sdk</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang">lang</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/types">types</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/string">string</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/numbers">numbers</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/iterators">iterators</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/exceptions">exception</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/memory">memory</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/structs">structs</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/io">io</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/math">math</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os">os</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/process">process</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/jobpool">jobpool</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/coro">coro</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/terminal">terminal</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/pipe">pipe</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/dynlib">dynlib</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/mmap">mmap</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/channel">channel</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/system">system</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/env">env</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/shellutils">shellutils</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/time">time</a>
		
	</li>
	
</ul>


		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/net">net</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/text">text</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/threading">threading</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/native">native</a>
		
	</li>
	
</ul>


		
	</li>
	
</ul>


</nav>


		<main>
			<header>
				<h1>Tuples</h1>
			</header>
			<nav id="TableOfContents">
<ul>
<li><a href="#toc_0">Tuples</a>
<ul>
<li><a href="#toc_1">Intro</a></li>
<li><a href="#toc_2">The problem</a></li>
<li><a href="#toc_3">Using an array - minmax</a></li>
<li><a href="#toc_4">Using a list of cells (ie. a Bag)</a></li>
<li><a href="#toc_5">Using references</a></li>
<li><a href="#toc_6">Multi-return using tuples - the solution</a></li>
<li><a href="#toc_7">Multiple return types</a></li>
<li><a href="#toc_8">Retrieving all values - multi-variable declaration</a></li>
<li><a href="#toc_9">Ignoring all but the first value</a></li>
<li><a href="#toc_10">Ignoring specific values - the &lsquo;_&rsquo; wildcard</a></li>
<li><a href="#toc_11">The importance of return values order</a></li>
<li><a href="#toc_12">The &lsquo;_&rsquo; wildcard in greedy mode</a></li>
<li><a href="#toc_13">Tuples beyond return - multi-declaration and multi-assign</a></li>
</ul></li>
</ul>
</nav>
			<article>
				

<h1 id="toc_0">Tuples</h1>

<h2 id="toc_1">Intro</h2>

<p>This section is rather long, and begins with an explanation of the practical
problem multi-return is supposed to solve.</p>

<p>If you&rsquo;re just looking for reference material, you may jump directly
to the &lsquo;Multi-return using Tuples&rsquo; section.</p>

<p>Also, don&rsquo;t miss the last section on multi-variable declaration and assignment.</p>

<h2 id="toc_2">The problem</h2>

<p>How do we make a function that return several values?</p>

<h2 id="toc_3">Using an array - minmax</h2>

<p>You can use an array:</p>

<pre><code>    // counter-example: don't do that
    minmax: func (list: List&lt;Int&gt;) -&gt; Int[] {
        min := INT_MAX
        max := INT_MIN
        for(i in list) {
            if(i &lt; min) min = i
            if(i &gt; max) max = i
        }

        [min, max]
    }
</code></pre>

<p>But it&rsquo;s not practical, ie. if you want to retrieve min and max, you have to do:</p>

<pre><code>    // counter-example: don't do that
    result := minmax(mylist)
    min := result[0]
    max := result[1]
</code></pre>

<p>We&rsquo;re using three lines only to retrieve results from a function.</p>

<p>And what if minmax is changed to return only one value? The code will still
compile but fail on result[1].</p>

<h2 id="toc_4">Using a list of cells (ie. a Bag)</h2>

<p>Using an array doesn&rsquo;t allow different types, so</p>

<p>Let&rsquo;s try using a list of cells:</p>

<pre><code>    // counter-example: don't do that
    meanAndTotal: func (units: List&lt;Unit&gt;) -&gt; List&lt;Cell&gt; {
        total := 0
        for(unit in units) total += unit weight
        mean := total / units size() as Float

        [Cell new(total), Cell new(mean)] as ArrayList&lt;Cell&gt;
    }
</code></pre>

<p>And to retrieve the values:</p>

<pre><code>    // counter-example: don't do that
    result := meanAndTotal(units)
    total  := result[0] get(Int)
    mean   := result[1] get(Float)
</code></pre>

<p>Again, three lines, looks even uglier, no guarantees, not type-safe at
compile-time. Don&rsquo;t do that.</p>

<h2 id="toc_5">Using references</h2>

<p>And here&rsquo;s the closest we&rsquo;ll come to a tolerable solution without using
tuples: out-parameters. Let&rsquo;s rewrite the minmax example with it</p>

<pre><code>    // counter-example: don't do that
    minmax: func (list: List&lt;Int&gt;, min, max: Int@) {
        min = INT_MAX
        max = INT_MIN
        for(i in list) {
            if(i &lt; min) min = i
            if(i &gt; max) max = i
        }
    }
</code></pre>

<p>And to retrieve the values:</p>

<pre><code>    // counter-example: don't do that
    min, max: Int
    minmax(mylist, min&amp;, max&amp;)
</code></pre>

<p>Two lines is better, but what if we do:</p>

<pre><code>    minmax(mylist, null, null)
</code></pre>

<p>That&rsquo;s valid ooc, won&rsquo;t be caught at compile-time, and yet crash.
So it&rsquo;s not the perfect solution we&rsquo;re looking for.</p>

<h2 id="toc_6">Multi-return using tuples - the solution</h2>

<h2 id="toc_7">Multiple return types</h2>

<p>Tuples can be used to return multiple values from a function. Let&rsquo;s
rewrite our minmax function using that.</p>

<pre><code>    minmax: func (list: List&lt;Int&gt;) -&gt; (Int, Int) {
        (min, max) := (INT_MAX, INT_MIN)
        list each(|i|
            if(i &lt; min) min = i
            if(i &gt; max) max = i
        )
        (min, max)
    }
</code></pre>

<p>The returned tuple and the declared function return type must
match exactly (e.g. same number and types of elements). Any mismatch
will result in a compile error.</p>

<h2 id="toc_8">Retrieving all values - multi-variable declaration</h2>

<p>We can retrieve all values by using a decl-assign with a tuple
on the left and a function call on the right</p>

<pre><code>    (min, max) := minmax(mylist)
</code></pre>

<p>The tuple and the return type of the function call must match exactly
(same numbers of elements). Any mismatch will result in a compile error.</p>

<p>The tuple should only contain variable accesses - any other expression
will result in a compile error.</p>

<p>The type of the variables declared inside the tuples are inferred
from the return type of the called function, just like regular decl-assign.</p>

<p>There are ways to ignore some values, that are described in other sections.</p>

<h2 id="toc_9">Ignoring all but the first value</h2>

<p>In the minmax example above, we can retrieve only min if we want:</p>

<pre><code>    min := minmax(mylist)
</code></pre>

<p>It can even be used as an expression:</p>

<pre><code>    &quot;Minimum is %d&quot; printfln(minmax(mylist))
</code></pre>

<p>Which leads to this rule: <strong>when a function returning multiple values
is used as if it returned only one, the first value is used.</strong></p>

<h2 id="toc_10">Ignoring specific values - the &lsquo;_&rsquo; wildcard</h2>

<p>What if we want only max? We can use &lsquo;_&rsquo; in place of a name, in a
multi-variable declaration:</p>

<pre><code>    (_, max) := minmax(mylist)
</code></pre>

<p>However, there is no way to use it as an expression, it has to be
unwrapped first, with a multi-variable declaration.</p>

<p>For that reason, <strong>it&rsquo;s good design to declare return values from most
interesting to least interesting</strong>.</p>

<h2 id="toc_11">The importance of return values order</h2>

<p>Take for example Process getOutput() in the sdk:</p>

<pre><code>    getOutput: func -&gt; (String, Int) {}
</code></pre>

<p>The first returned value is what the process wrote to stdout, and
the second value is the exit code of the process.</p>

<p>The function used to be declared like that</p>

<pre><code>    getOutput: func -&gt; String {}
</code></pre>

<p>And didn&rsquo;t allow to get the exit code. Adding functionality didn&rsquo;t
hurt compatibility at all though - no code broke, because of careful
design.</p>

<p>Be careful when designing APIs. Plan for growth. Listen to Guy Steele
(and his &lsquo;Growing a Language&rsquo; talk)</p>

<h2 id="toc_12">The &lsquo;_&rsquo; wildcard in greedy mode</h2>

<p>We said above that the tuple and the return type of the function call
on either side of a multi-variable decl-assign should match exactly.</p>

<p>For example, given this:</p>

<pre><code>    plainWhite: func -&gt; (Int, Int, Int, Int) { (1, 2, 3, 4) }
</code></pre>

<p>The following lines are invalid:</p>

<pre><code>    (one, two) := plainWhite()
    (_, two) := plainWhite()
</code></pre>

<p>Why? So that when incompatible changes are made to an API, you&rsquo;re
aware of it at compile-time, not at run-time.</p>

<p>However, both these lines are valid:</p>

<pre><code>    one := plainWhite() // as we've seen before
    (_, two, _) := plainWhite()
</code></pre>

<p>Although plainWhite() returns 4 values, a tuple with only 3 elements
works.</p>

<p><strong>A &lsquo;_&rsquo; used at the end of a tuple will ignore every remaining return value</strong></p>

<p>So that</p>

<pre><code>    one := plainWhite()
</code></pre>

<p>Is actually equivalent to:</p>

<pre><code>    (one, _) := plainWhite()
</code></pre>

<h2 id="toc_13">Tuples beyond return - multi-declaration and multi-assign</h2>

<p>Using tuples on both sides of the decl-assign operator (:=) or
the assign operator (=) is valid.</p>

<p>Examples:</p>

<pre><code>    (x, y, z) := (1, 2, 3)

    (a, b) = (b, a)
</code></pre>

<p>Swapping variables is valid, and should be supported by compliant
ooc compilers/runtimes.</p>

			</article>
			<footer>
				<p><span id="footer-copyright">2009-2014 Amos Wenger</span><span id="footer-license">CC BY-SA 3.0</span></p>
			</footer>
		</main>
		<footer>
  <p></p>
</footer>

	</body>
</html>
