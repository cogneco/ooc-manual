<!DOCTYPE html>
<html>
	<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<title> Generics 2 &middot; The OOC Manual </title>
	
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/reset.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/text.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/color.css">
	<link rel="stylesheet" href="http://oocmanual.cogneco.com/css/layout.css">
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://oocmanual.cogneco.com/apple-touch-icon-144-precomposed.png">
	<link rel="shortcut icon" href="http://oocmanual.cogneco.com/favicon.ico">
	
	<link href="" rel="alternate" type="application/rss+xml" title="The OOC Manual" />
</head>

	<body>
		<header>
  <h1><a href="http://oocmanual.cogneco.com">The OOC Manual</a></h1>
  <p></p>
</header>

		<nav>
	<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/introduction/">Introduction</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/installing/">Installing</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/">Language</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/modules/">Modules</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/values/">Values</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/tuples/">Tuples</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/control-structures/">Control Structures</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/collections/">Collections</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/functions/">Functions</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/first-class-functions/">First-class Functions</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/classes/">Classes</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/constructors/">Constructors</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/properties/">Properties</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/operators/">Operators</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/interfaces/">Interfaces</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/covers/">Covers</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/covers-vs-classes/">Covers vs Classes</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/enumerations/">Enumerations</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/generics/">Generics</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/generics2/">Generics 2</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/exceptions/">Exceptions</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/preprocessor/">Preprocessor</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/language/version-blocks/">Version</a>
		
	</li>
	
</ul>

		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/">sdk</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/">lang</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/types/">types</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/string/">string</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/numbers/">numbers</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/iterators/">iterators</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/exceptions/">exception</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/lang/memory/">memory</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/structs/">structs</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/io/">io</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/math/">math</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/">os</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/process/">process</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/jobpool/">jobpool</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/coro/">coro</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/terminal/">terminal</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/pipe/">pipe</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/dynlib/">dynlib</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/mmap/">mmap</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/channel/">channel</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/system/">system</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/env/">env</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/shellutils/">shellutils</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/os/time/">time</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/net/">net</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/text/">text</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/threading/">threading</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/sdk/native/">native</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/">Tools</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/">Rock</a>
		
		<ul>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/basic/">Basic Usage</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/drivers/">Drivers</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/advanced/">Advanced Usage</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/use-files/">Use-files</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/use-files2/">Use-files 2</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/gc/">Garbage Collection</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/debug/">Debugging</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/rock/packaging/">Packaging</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/sam/">Sam</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/tools/editors/">Editors</a>
		
	</li>
	
</ul>

		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/troubleshooting/">Troubleshooting</a>
		
	</li>
	
	<li>
		<a href="http://oocmanual.cogneco.com/glossary/">Glossary</a>
		
	</li>
	
</ul>

</nav>

		<main>
			<header>
				<h1>Generics 2</h1>
			</header>
			<nav id="TableOfContents">
<ul>
<li><a href="#toc_0">Generics</a>
<ul>
<li><a href="#toc_1">Intro</a></li>
<li><a href="#toc_2">Generic functions and type parameters</a></li>
<li><a href="#toc_3">Generic type inference</a></li>
<li><a href="#toc_4">Generic return types</a></li>
<li><a href="#toc_5">Generic classes</a></li>
<li><a href="#toc_6">Advanced type inference</a></li>
<li><a href="#toc_7">Under the hood</a></li>
</ul></li>
</ul>
</nav>
			<article>
				

<h1 id="toc_0">Generics</h1>

<h2 id="toc_1">Intro</h2>

<p>Generics are one of the most commonly misunderstood features of ooc.</p>

<p>Many people attempt confuse them with templates (like in C++ or D) and are
surprised when things like this don&rsquo;t work:</p>

<pre><code>    Vector2: class &lt;T&gt; {
        x, y: T
	init: func(=x, =y) {}
        add: func (r: This&lt;T&gt;) {
            new(x + r x, y + r y)
        }
    }
</code></pre>

<p>(Don&rsquo;t worry about the syntax for now, I&rsquo;ll get to it later)</p>

<p>Why doesn&rsquo;t this work? It&rsquo;s because you can&rsquo;t do much with generic variables.
The whole point is that <em>we don&rsquo;t know which type they are</em> until we run the
program.</p>

<p>One might instanciate a Vector2&lt;Int&gt; - in which case the + operator
makes sense - but they could also instanciate a Vector2&lt;Carrot&gt;, where Carrot
wouldn&rsquo;t necessarily have a + operator.</p>

<p>Besides, since ooc is statically typed, we wouldn&rsquo;t know which + operator
to use - they&rsquo;re not all the same! We don&rsquo;t add two ints the same manner that
we add two floats, and so on.</p>

<h2 id="toc_2">Generic functions and type parameters</h2>

<p>So, if we can&rsquo;t use any operator on generic variables - nor can we call
methods on them, then what are they good for? Sure looks useless from here.</p>

<p>Well, here&rsquo;s one thing we can do, for example:</p>

<pre><code>    identity: func &lt;T&gt; (val: T) -&gt; T {
        val
    }
</code></pre>

<p>Woha. What just happened here? Let&rsquo;s recap line by line.</p>

<pre><code>    identity: func &lt;T&gt; (val: T) -&gt; T
</code></pre>

<p>Here, we declare a function named &lsquo;identity&rsquo;, with one type parameter named T,
taking one parameter named &lsquo;val&rsquo;, and returning a value of type T.</p>

<p>Type parameters are the names listed between the angular brackets &lt; and &gt;. You
can have as many as you want (although if you have more than few of them,
you&rsquo;re probably doing it wrong)</p>

<p>When you declare a type parameter, it tells the compiler about a new type,
that we know nothing about at compile-time. Well, not nothing. Remember
classes? Here&rsquo;s how we access the class of an object:</p>

<pre><code>    object class
</code></pre>

<p>And if object was of type Carrot, that amounts exactly to doing just:</p>

<pre><code>    Carrot
</code></pre>

<p>What is that, exactly? It&rsquo;s an access to a class. What is a class? An instance
of Class, which is declared in lang/CoreTypes.ooc If you actually go on and open
CoreTypes, here is a simplified version of what you will find:</p>

<pre><code>    Class: class {
        name: String
        size, instanceSize: SizeT
    }
</code></pre>

<p>(Reminder: SizeT can be used to store the size of something. On 32-bits
platforms, it&rsquo;s 32-bits wide. On 64-bits platforms, it&rsquo;s 64-bits wide, and so
on. Basically, it&rsquo;s an integer type that is as wide as a Pointer)</p>

<p>So back to our generic stuff. I said we knew nothing about generic types. And
in fact, it was a downright lie. Please accept my apologies. The reality is -
we know all that matters! If you try to execute the following piece of code:</p>

<pre><code>    test: func &lt;T&gt; (t: T) { T class name println() }
    test(42)
</code></pre>

<p>You&rsquo;ll find out something very strange and puzzling.. it prints &ldquo;Class&rdquo; !</p>

<p>We just discovered that we can access type parameters just like any other
variable. And since T is a class, and we can access various fields of a class,
here&rsquo;s what we can do:</p>

<pre><code>    test2: func &lt;T&gt; (t: T) {
        &quot;name = %s, size = %zd, instanceSize = %zd&quot; printfln(
        T name, T size, T instanceSize)
    }
    test2(42)
</code></pre>

<p>This will likely print something like &ldquo;name = Int, size = 4, instanceSize =
4&rdquo;.</p>

<p>Then you must wonder why is there &lsquo;size&rsquo; and &lsquo;instanceSize&rsquo;, if they&rsquo;re equal?
Well, they&rsquo;re not equal in all cases. Most importantly, for objects (which are
references, remember), &lsquo;object class size&rsquo; is equal to &lsquo;Pointer size&rsquo;, but
&lsquo;object class instanceSize&rsquo; is equal to the actual number of bytes we should
allocate when we create an object of this class.</p>

<p>But I digress. (Then again, you&rsquo;re the curious one - not me.)</p>

<p>So let&rsquo;s analyze the second line of our &lsquo;identity&rsquo; function above:</p>

<pre><code>    val
</code></pre>

<p>Let&rsquo;s see. It&rsquo;s the last line of a non-void function, so it means it&rsquo;s
returned. &lsquo;val&rsquo; refers to a variable declaration which happens to be a
function argument, of a generic type. (<em>phew</em> - at this point, repeat that
last line to yourself two or three times to impreign it into your brain)</p>

<p>So basically what our function does is&hellip; just pass through what we give it as
an argument! Let&rsquo;s try that</p>

<pre><code>    42 toString() println() // just to be sure
    identity(42) toString() println() // still a little trivial
    identity(identity(identity(identity(42)))) toString() println() // whoa.
</code></pre>

<p>Yup, it prints 42 alright.</p>

<p>But wait! I just said above that the compiler <em>couldn&rsquo;t do anything useful
with a generic variable</em>, that is, either use an operator on it or call a
function on it, because it doesn&rsquo;t know its type. And in our example, we
clearly see that the &lsquo;identity&rsquo; function has return type T, which is a generic
type! (Because it&rsquo;s between the &lt; and &gt;, remember?)</p>

<p>Have I lied again? Let&rsquo;s find out.</p>

<h2 id="toc_3">Generic type inference</h2>

<p>Let&rsquo;s do a little experiment:</p>

<pre><code>    a := 42
    b := identity(42)
    &quot;%s and %s&quot; printfln(a class name, b class name)
</code></pre>

<p>What did you get? Int and Int, right? But - but the return type of &lsquo;identity&rsquo;
is T! Shouldn&rsquo;t b&rsquo;s type be T too?</p>

<p>Well, no.</p>

<p>And thank God for that.</p>

<p>In fact, if it was so, generics would be pretty much useless (heh, they&rsquo;re limited enough already!)</p>

<p>So what kind of magic is going on? White magic. Which really isn&rsquo;t magic at
all.</p>

<p>You see, when you call:</p>

<pre><code>    identity(42)
</code></pre>

<p>And the definition of identity is</p>

<pre><code>    identity: func &lt;T&gt; (val: T) -&gt; T
</code></pre>

<p>Here&rsquo;s what the compiler figures out: well, we have one unknown type (that
is, generic type), called &rsquo;T&rsquo;. Also, the first (and only) argument is of that
type. Hey - let&rsquo;s infer what &rsquo;T&rsquo; is from the type of this argument!</p>

<p>And that&rsquo;s exactly what it does. As a result, it figures the type of b to be
Int - since we can know all that at compile-time. It makes b easier to use,
avoid tons of cast, and is good for your karma.</p>

<p>Here&rsquo;s another example.</p>

<pre><code>    printTypeName: func &lt;T&gt; (T: Class) { T name println() }
    printTypeName(Object)
</code></pre>

<p>Then it prints &ldquo;Object&rdquo;. Did we find a way to print strings without having to
enclose them between quotes? Hopefully not. That would be messy, man. Talk
about Perl :/</p>

<p>However, we have just discovered that we can pass types as arguments to
functions. Of course, because types are just instances of &lsquo;Class&rsquo;, right? So
they&rsquo;re objects. So they&rsquo;re values. So we can pass them around.</p>

<p>So here, the compiler figures that, well - we give it the solution to &lsquo;what is
T&rsquo;. It is then not too big a challenge for the compiler to go from here.</p>

<p>Then again, we could have done:</p>

<pre><code>    dumbPrintTypeName: func (T: Class) { T name println() }
    dumbPrintTypeName(Object)
</code></pre>

<p>Since we don&rsquo;t use T as a type anywhere. So why even bother with this &lt;T&gt;
thing, hmm? Why does the compiler even allow it? Read on if you want to find out.</p>

<h2 id="toc_4">Generic return types</h2>

<p>Here&rsquo;s a little riddle for you. How does the compiler figure out the real return
type of this function:</p>

<pre><code>    sackOfUnknown: func &lt;T&gt; -&gt; T { 42 }
    sackOfUnknown()
</code></pre>

<p>Anyone? Ah, I see a hand in the back. What do you say? The type of the return
expression? WRONG. But that was an honest try. One point for effort.</p>

<p>So what&rsquo;s the solution? &ldquo;It doesn&rsquo;t.&rdquo; That&rsquo;s right. The compiler doesn&rsquo;t even
bother. We give absolutely no clue as to the type of T when we&rsquo;re calling it -
and the compiler never tries to infer a generic type from the return
expression (that&rsquo;s useless, I mean - why even make a generic function in the
first place? Too lazy to type out &lsquo;Int&rsquo;? Yeah. Call me back when you have ABI
incompatibilities because you changed a return expression. Or rather - don&rsquo;t.)</p>

<p>So how do we make a function that</p>

<ul>
<li>has a generic return type, let&rsquo;s say &rsquo;T&rsquo;</li>
<li>doesn&rsquo;t take an argument of type T ?</li>
</ul>

<p>Well, that&rsquo;s precisely where that useless thing presented in the previous
section comes in very handy:</p>

<pre><code>    theAnswer: func &lt;T&gt; (T: Class) -&gt; T {
        match T {
            case Int    =&gt; 42
            case Float  =&gt; 42.0
            case String =&gt; &quot;forty-two&quot;
            case        =&gt; Exception new(&quot;You're not worthy.&quot;) throw(); 0
        }
    }
   rational := theAnswer(Int)
   real     := theAnswer(Float)
   text     := theAnswer(String)
   theAnswer(Object) // ka-boom!
</code></pre>

<p>What just happened? We used a match on &rsquo;T&rsquo;, which means we&rsquo;re comparing it.
We&rsquo;re comparing it with the types &lsquo;Int&rsquo;, &lsquo;Float&rsquo;, &lsquo;String&rsquo;, trying to return
expressions. And if it&rsquo;s none of these types, it just blows up.</p>

<p>Note: in that case, our theAnswer function is pretty useless</p>

<h2 id="toc_5">Generic classes</h2>

<p>Now that&rsquo;s all good and fancy - but generic functions aren&rsquo;t actually that
useful. If we can&rsquo;t use operators nor functions on generic types, what can we
do? Well - store them! That&rsquo;s the way all collections work.</p>

<p>Let&rsquo;s start with a simple one:</p>

<pre><code>    Slot: class &lt;T&gt; {
        element: T
        init: func (.element) { set(element) }
        set: func (=element) {}
        get: func -&gt; T { element }
    }

    s := Slot new(3.14)
    s get() toString() println()
    s T name println()
</code></pre>

<p>Not that bad, eh? (It should print 3.14 and Float - or some other type, if
you&rsquo;re in the future and ooc has a proper number tower)</p>

<p>But wait - get is defined like that:</p>

<pre><code>    get: func -&gt; T { element }
</code></pre>

<p>And clearly T is a generic type, ie. it could be anything at runtime, and
<em>yet</em> the compiler figures it out right.</p>

<p>So what happens here? Let&rsquo;s look at the call, since it&rsquo;s the info from which
the compiler works to infer generic types:</p>

<pre><code>    s get()
</code></pre>

<p>Hmmph. Not many types there - except maybe.. the type of s. Which is what
exactly?</p>

<pre><code>    s := Slot new(3.14)
</code></pre>

<p>Well it turns out that Slot new is just a regular method call, the generic
type T is inferred to &lsquo;Float&rsquo;, and so &rsquo;s&rsquo; becomes a Slot&lt;Float&gt;</p>

<p>Hence, the compiler sees the get() call as:</p>

<pre><code>    Slot&lt;Float&gt; get()
</code></pre>

<p>And it sees the get definition as</p>

<pre><code>    Sloat&lt;T&gt; get: func {}
</code></pre>

<p>From here, inferring that T = Float is trivial.</p>

<h2 id="toc_6">Advanced type inference</h2>

<p>One of the most advanced example of type inference in the whole SDK
is probably the List map() function. Here is its signature (ie.
definition without the body) :</p>

<pre><code>    map: func &lt;K&gt; (f: Func (T) -&gt; K) -&gt; This&lt;K&gt;
</code></pre>

<p>So basically it turns a List&lt;T&gt; into a List&lt;K&gt;, by calling f to turn
every T into a K. Makes sense.</p>

<p>The question is now - how does the compiler infer K? The only info we have
about it, is that it&rsquo;s the return type of function we pass as an argument
to the function.</p>

<p>Well - no big deal then, if we do:</p>

<pre><code>    intToString: func (i: Int) -&gt; String { i toString() }
    strings := numbers map(intToString)
</code></pre>

<p>Then we know that K = String from the definition of intToString.</p>

<p>But wait, there&rsquo;s a nice infers-everything syntax for closures, ie.:</p>

<pre><code>    stringsToo := numbers map(|x| x toString())
</code></pre>

<p>And here, we&rsquo;re doomed. The closure insides attempts to infers its whole
signature (argument types, return type, etc.) from the type of the
corresponding argmuent in the map definition. But map doesn&rsquo;t provide
a definitive answer, since the return type is generic.</p>

<p>Hence, the compiler falls back to the only possible resolution of this
madness: it infers K from the return expression inside the closure.</p>

<p>This case is the <em>only case</em> where rock considers the return expression
inside functions to infer any type at all.</p>

<h2 id="toc_7">Under the hood</h2>

<p>How does it work under the hood?</p>

<p>Here is the naive implementation: generic type arguments as passed
as function arguments, ie a call to:</p>

<pre><code>    ArrayList&lt;Int&gt; new()
    identity(42)
</code></pre>

<p>becomes (without mangling):</p>

<pre><code>    ArrayList_new(Int_class());
    identity()
</code></pre>

<p>Type arguments in classes become variables:</p>

<pre><code>    ArrayList: class &lt;T&gt; {}
</code></pre>

<p>is</p>

<pre><code>    ArrayList: class {
        T: Class
    }
</code></pre>

<p>Class type arguments are assigned in the constructor to the appropriate
values.</p>

			</article>
			<footer>
				<p><span id="footer-copyright">2009-2014 Amos Wenger</span><span id="footer-license">CC BY-SA 3.0</span></p>
			</footer>
		</main>
		<footer>
  <p></p>
</footer>

	</body>
</html>
