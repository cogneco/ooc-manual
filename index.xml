<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Glossary</title>
      <link>http://oocmanual.cogneco.com/glossary/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/glossary/</guid>
      <description>&lt;p&gt;{{GLOSSARY}}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installing</title>
      <link>http://oocmanual.cogneco.com/installing/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/installing/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Bootstrapping&lt;/h1&gt;

&lt;p&gt;The OOC compiler Rock is not currently installed but rather bootstrapped from sources.&lt;/p&gt;

&lt;p&gt;Start by creating a folder for all OOC projects and move to that folder.
There you issue the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
sudo apt-get -y -qq install curl make libgc-dev binutils-dev libiberty-dev zlib1g-dev
export PATH=$PATH:$PWD/rock/bin:$PWD/sam
export OOC_LIBS=$PWD
git clone --depth=1 -b master git://github.com/cogneco/rock.git
git clone --depth=1 git://github.com/cogneco/sam.git
(cd rock &amp;amp;&amp;amp; make rescue &amp;amp;&amp;amp; make &amp;amp;&amp;amp; cd extensions &amp;amp;&amp;amp; make)
(cd sam &amp;amp;&amp;amp; rock -v)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Setting Environment Variables&lt;/h1&gt;

&lt;p&gt;It is necessary to set the following environments variables for every terminal session used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
export PATH=$PATH:$PWD/rock/bin:$PWD/sam
export OOC_LIBS=$PWD
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Manual</title>
      <link>http://oocmanual.cogneco.com/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;How to use the documentation&lt;/h1&gt;

&lt;p&gt;The documentation for ooc is structured as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tutorial/&#34;&gt;Tutorial&lt;/a&gt; is a ten minute journey meant for
newcomers to the language. By building a small program, you will learn the
basics of the syntax and even use bits of the SDK.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/lang/&#34;&gt;Language&lt;/a&gt; section explains in detail every feature
of the language: it goes through the syntax and a the main use cases for
every feature. It also contains a full grammar, and a collection of best
practices.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/sdk/&#34;&gt;SDK&lt;/a&gt; section gives an overview of the modules included
with the default ooc distribution. Whether you need access to files, to
measure time, to do some networking, or simply use common data structures,
the SDK is packed with goodness.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/&#34;&gt;Tools&lt;/a&gt; section lists useful tools for ooc development,
along with a typical workflow from the creation, compilation, testing, and
documentation of a project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/kaputt/&#34;&gt;Troubleshooting&lt;/a&gt; section gives advice on how
to address frequently encountered problems.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/glossary/&#34;&gt;Glossary&lt;/a&gt; is a collection of terms you may stumble
upon while using ooc or reading its documentation. If you don&amp;rsquo;t understand
a term, go here!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When you’re stuck with a question or a problem the documentation doesn’t
solve, considering posting to the &lt;a href=&#34;https://groups.google.com/group/ooc-lang&#34;&gt;discussion group&lt;/a&gt; or joining the
&lt;a href=&#34;irc://chat.freenode.net/#ooc-lang&#34;&gt;ooc-lang IRC channel&lt;/a&gt;. We’ll get it sorted out in no time. Check out the
&lt;a href=&#34;/community/&#34;&gt;Community&lt;/a&gt; page for details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Collections</title>
      <link>http://oocmanual.cogneco.com/language/collections/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/collections/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Foreword&lt;/h1&gt;

&lt;p&gt;The array situation in ooc is a bit delicate right now - while
I (Amos) am definitely not happy with it, I am still going to
document the current state of things, if only as a motivation to
make it better.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;C arrays&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;On the heap&lt;/h2&gt;

&lt;p&gt;C arrays are really just pointers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
tenInts := gc_malloc(10 * Int size) as Int*
for (i in 0..10) {
  tenInts[i] = i
}
printInts(tenInts, 10)

printInts: func (arr: Int*, length: Int) {
  for (i in 0..length) {
    &amp;quot;%d&amp;quot; printfln(arr[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;On the stack&lt;/h2&gt;

&lt;p&gt;Above, we are calling &lt;code&gt;gc_malloc&lt;/code&gt; to allocate a block of GC-managed
memory on the heap. If for some reason a stack-allocated C array
is desirable, this syntax will work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
tenInts: Int[10]
for (i in 0..10) {
  tenInts[i] = i
}
printInts(tenInts[0]&amp;amp;, 10)

printInts: func (arr: Int*, length: Int) {
  for (i in 0..length) {
    &amp;quot;%d&amp;quot; printfln(arr[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;ooc arrays&lt;/h1&gt;

&lt;p&gt;ooc arrays are more convenient / safer than C arrays because they:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hold the length (number of elements)&lt;/li&gt;
&lt;li&gt;do bounds checking when accessing / writing to them&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The syntax is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
tenInts := Int[10] new()
for (i in 0..10) {
  tenInts[i] = i
}
printInts(tenInts)

printInts: func (arr: Int[]) {
  for (i in 0..arr length) {
    &amp;quot;%d&amp;quot; printfln(arr[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multidimensional arrays can be declared and used like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
sixInts := Int[3][2] new()
for (i in 0..3) {
  for (j in 0..2) {
    sixInts[i][j] = i*2 + j
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;ArrayList&lt;/h1&gt;

&lt;p&gt;ArrayList is not technically part of the language - it is usually available in
the ooc SDK. Its advantages over ooc arrays are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you can accept an &lt;code&gt;ArrayList&amp;lt;T&amp;gt;&lt;/code&gt; for any &lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;you can query the &lt;code&gt;T&lt;/code&gt; of an ArrayList (ie. match the type)&lt;/li&gt;
&lt;li&gt;you can add and remove elements anywhere in the list
(whereas arrays are fixed-length)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Array-like usage&lt;/h2&gt;

&lt;p&gt;They can be used with array-like operators:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import structs/ArrayList

tenInts := ArrayList&amp;lt;Int&amp;gt; new()
for (i in 0..10) {
  tenInts add(i)
}
printInts(tenInts)

printInts: func (list: ArrayList&amp;lt;Int&amp;gt;) {
  for (i in 0..list size) {
    &amp;quot;%d&amp;quot; printfln(list[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Foreach usage&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;printInts&lt;/code&gt; method above can be rewritten using a
foreach to iterate over the list&amp;rsquo;s elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printInts: func (list: ArrayList&amp;lt;Int&amp;gt;) {
  for (i in list) {
    &amp;quot;%d&amp;quot; printfln(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Iterator usage&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s say we want to remove every odd number from the list.&lt;/p&gt;

&lt;p&gt;Since we are modifying it while iterating through it, the best
device for that is an iterator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
removeOdds: func (list: ArrayList&amp;lt;Int&amp;gt;) {
  iter := list iterator()
  while (iter hasNext?()) {
    if (iter next() % 2 == 1) {
      // removes the element we just got.
      // NOTE: we are calling it on the iterator,
      // not on the list itself.
      iter remove()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Generics usage&lt;/h2&gt;

&lt;p&gt;Example usage of &lt;a href=&#34;/docs/lang/generics/&#34;&gt;generics&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import structs/ArrayList

printList(ArrayList&amp;lt;Int&amp;gt; new())
printList(ArrayList&amp;lt;String&amp;gt; new())

printList: func &amp;lt;T&amp;gt; (list: ArrayList&amp;lt;T&amp;gt;) {
  &amp;quot;Got a list of %s&amp;quot; printfln(list T name)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, &lt;code&gt;list T&lt;/code&gt; is just a &lt;a href=&#34;/docs/lang/classes/#classes&#34;&gt;class&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Literals&lt;/h2&gt;

&lt;p&gt;Simple array literals will give ooc arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
tenInts := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
printInts(tenInts)

printInts: func (arr: Int[]) {
  for (i in 0..arr length) {
    &amp;quot;%d&amp;quot; printfln(arr[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Specifying the type the array literal is supposed to be allows
C array literals:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
tenInts := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] as Int*
printInts(tenInts, 10)

printInts: func (arr: Int*, length: Int) {
  for (i in 0..length) {
    &amp;quot;%d&amp;quot; printfln(arr[i])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the same fashion, ArrayList literals exist:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import structs/ArrayList

tenInts := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] as ArrayList&amp;lt;Int&amp;gt;
printInts(tenInts)

printInts: func (list: ArrayList&amp;lt;Int&amp;gt;) {
  for (elem in list) {
    &amp;quot;%d&amp;quot; printfln(elem)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;Others&lt;/h1&gt;

&lt;p&gt;The ooc sdk is full of other data structures, such as &lt;code&gt;LinkedList&lt;/code&gt;,
&lt;code&gt;HashMap&lt;/code&gt; (an dictionary associating keys and values), etc.&lt;/p&gt;

&lt;p&gt;For more information, read up on the &lt;a href=&#34;/docs/sdk/structs/&#34;&gt;structs package&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Constructors</title>
      <link>http://oocmanual.cogneco.com/language/constructors/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/constructors/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Constructors&lt;/h1&gt;

&lt;p&gt;In ooc, unlike Java/Scala/C++/C#, &amp;lsquo;new&amp;rsquo; isn&amp;rsquo;t a keyword, but a static method.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    dog := Dog new(&amp;quot;Pif&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However it&amp;rsquo;s uncommon to directly define a new method. Instead, an init method is
defined, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func (=name) {}

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an &amp;lsquo;init&amp;rsquo; method is defined, a corresponding &amp;lsquo;new&amp;rsquo; static method is defined, in our case,
the code above is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func (name: String) {
            this name = name
        }

        new: static func (name: String) -&amp;gt; This {
            this := This alloc() as This
            this init()
            this
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;alloc&amp;rsquo; is a method of Class, which can be defined like this, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /// Create a new instance of the object of type defined by this class
    alloc: final func ~_class -&amp;gt; Object {
        object := gc_malloc(instanceSize) as Object
        if(object) {
            object class = this
        }
        return object
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In ooc implementations, Object and Class are often classes defined in .ooc source
files, so you can easily study their source code. You can typically find their definitions
in sdk/lang/ (because everything in the lang/ package is automatically imported)&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Reminder: member-arguments and assign-arguments&lt;/h2&gt;

&lt;p&gt;This:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the equivalent of this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (.value) {
            this value = value
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is the equivalent of this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (value: Int) {
            this value = value
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ie &amp;lsquo;.&amp;rsquo; allows &amp;lsquo;value&amp;rsquo;s type to be inferred from the member variable
of the same name, and &amp;lsquo;=&amp;rsquo; does the same plus assigns it in the constructor.&lt;/p&gt;

&lt;p&gt;This works for any method, not only for constructors. However, if you&amp;rsquo;re using
it for setters, you probably want to use properties instead.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Multiple constructors&lt;/h2&gt;

&lt;p&gt;As any method, constructors can be overloaded with suffixes.&lt;/p&gt;

&lt;p&gt;Suffixes may seem annoying at first, seen as a sort of &amp;lsquo;manual name mangling&amp;rsquo;,
but aside from helping to debug, they&amp;rsquo;re also a way to document the purpose of your
different constructors. For that reason, it&amp;rsquo;s always a good idea to give meaningful
suffixes that lets one hint the reason for existence of a constructor.&lt;/p&gt;

&lt;p&gt;From a constructor, you can call another constructor with init(), just like a regular
method.&lt;/p&gt;

&lt;p&gt;You can also call a super-constructor with super()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func ~defaultName {
            init(&amp;quot;The Man&amp;quot;)
        }

        init: func (=name) {}

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Inheritance&lt;/h2&gt;

&lt;p&gt;A common mistake is to think that constructor are inherited, because they are standard
methods. However, this behavior would be harmful, as explained in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Logger: class {
        prefix: String

        init: func (=prefix) {}

        log: func (msg: String) {
            &amp;quot;%s%s&amp;quot; printfln(prefix, msg)
        }
    }

    FileLogger: class extends Logger {
        output: FileWriter

        init: func ~withPath (path: String) {
            super(prefix)
            output = FileWriter new(path)
        }

        log: func (msg: String) {
            output write(prefix). write(msg). write(&#39;\n&#39;)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What would happen if the first constructor defined in Logger was available
for FileLogger? Let&amp;rsquo;s find out&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    warn := FileLogger new(&amp;quot;WARN&amp;quot;)
    warn log(&amp;quot;Somebody set us up the stacktrace&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The constructor call, if it was valid, would either return a Logger, which is
not what we want, or by some miracle trick, return a FileLogger - but one
that wouldn&amp;rsquo;t be properly initialized, so that log() would crash.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Super func (and beyond)&lt;/h2&gt;

&lt;p&gt;However, there are times when one truly wants to relay a constructor
in an inherited class, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Expression: abstract class {
        eval: abstract func -&amp;gt; Int
    }

    BinaryOp: abstract class extends Expression {
        left, right: Expression

        init: func ~lr (=left, =right) {}
    }

    Add: class extends BinaryOp {
        init: func ~lr (=left, =right) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeating the &amp;lsquo;init~lr&amp;rsquo; definition in Add violates the Don&amp;rsquo;t Repeat Yourself (DRY)
principle. Besides, if functionality is added to the base BinaryOp init~lr, it
wouldn&amp;rsquo;t be replicated in Add init~lr.&lt;/p&gt;

&lt;p&gt;For this precise case, the &amp;lsquo;super func&amp;rsquo; construct exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Add: class extends BinaryOp {
        init: super func ~lr
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This behaves exactly as if we had written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Add: class extends BinaryOp {
        init: func ~lr (.left, .right) {
            super(left, right)
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Control Structures</title>
      <link>http://oocmanual.cogneco.com/language/control-structures/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/control-structures/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Conditionals&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;if / else&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s your traditional if, else if, else structure. The body should be either
a single statement, or a scope.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
if (off) turnOn()

if (stressed) {
    breatheIn()
    breatheOut()
} else if (tired) {
    rest()
} else {
    allGood()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The condition can be of type &lt;code&gt;Bool&lt;/code&gt; or a Pointer, in which case it will evaluate to
&lt;code&gt;true&lt;/code&gt; if it is non-null.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;match / case&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; is ooc&amp;rsquo;s &lt;code&gt;switch&lt;/code&gt;, loosely modelled after Scala&amp;rsquo;s. In its simplest form, it tests for equality between an expression and several values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match (numFeets) {
    case 1 =&amp;gt; &amp;quot;Ouch&amp;quot;
    case 2 =&amp;gt; &amp;quot;Normal&amp;quot;
    case =&amp;gt;
        // what?
        raise(&amp;quot;Too many feet&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each case is a scope of its own - it doesn&amp;rsquo;t require braces. A case with no
expression is a catch-all.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; also works with any class T that implements the method &lt;code&gt;matches?: func
-&amp;gt; (other: T) -&amp;gt; Bool&lt;/code&gt;. Another way to get complex types to work in matches
is simply to override the &lt;code&gt;==&lt;/code&gt; operator. Hence, Strings work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match keyword {
    case &amp;quot;if&amp;quot; =&amp;gt;
        Keyword IF
    case &amp;quot;match&amp;quot; =&amp;gt;
        Keyword MATCH
    case =&amp;gt;
        Keyword UNKNOWN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; is also a good way to avoid explicit casting, by matching an object
against variable declarations, one can use its specific form directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
result := match (op) {
    case plus: Plus =&amp;gt;
        plus lhs + plus rhs
    case minus: Minus =&amp;gt;
        minus lhs - minus rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;match&lt;/code&gt; is an expression, if every case ends with an expression. Hence, a
match can be used as a return value, or in a function call, on the right hand
side of a declaration-assignment (&lt;code&gt;:=&lt;/code&gt;), as demonstrated above.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Loops&lt;/h1&gt;

&lt;p&gt;Loops are structures that control the repetition of a body of code.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;break / continue&lt;/h2&gt;

&lt;p&gt;Two particular keywords are of interest when writing loops:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; immediately exits the loop, skipping the rest of the body
and not executing any further iteration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; skips over the rest of the body and begins the next
iteration immediately&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;while&lt;/h2&gt;

&lt;p&gt;Checks the condition - if false, skips the body. If true, runs the body,
then checks the condition again, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (!satisfied) {
    buyStuff()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;for&lt;/h2&gt;

&lt;p&gt;There is no C-like &lt;code&gt;for&lt;/code&gt; in ooc, only a foreach. It can iterate through
values like ranges:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (i in 1..10) {
    &amp;quot;Counting to %d&amp;quot; printfln(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or more complex data structures:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (element in list) {
    &amp;quot;Element = %s&amp;quot; printfln(element toString())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an object to be iterable, it has to implement the
&lt;code&gt;iterator: func &amp;lt;T&amp;gt; -&amp;gt; Iterator&amp;lt;T&amp;gt;&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;A variant of foreach allows one to get the index of the current element:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for ((index, element) in list) {
    &amp;quot;list[%d] = %s&amp;quot; printfln(index, element toString())
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Covers</title>
      <link>http://oocmanual.cogneco.com/language/covers/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/covers/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Covers&lt;/h1&gt;

&lt;p&gt;One selling point of ooc is that it makes it easy to use C libraries which
design is object-oriented. Covers are one way to do that.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Struct-like covers&lt;/h1&gt;

&lt;p&gt;Covers are a by-value, lighter, lower-level alternative to classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Vec2: cover {
  x, y: Float

  norm: func -&amp;gt; Float {
    sqrt(x * x + y * y)
  }
}

v: Vec2
v x = 1.5
v y = 4
&amp;quot;Norm = %.2f&amp;quot; printfln(v norm())
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Covers from&lt;/h1&gt;

&lt;p&gt;Covers from are based on an external, C type, and provide a way to access
members of the external type (if it&amp;rsquo;s a struct), and to call methods on it -
either existing, external functions, or adding whole new methods.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Int: cover from int
UInt8: cover from uint8_t
LLong: cover from long long
UInt: cover from unsigned int
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Members&lt;/h1&gt;

&lt;p&gt;Members can be declared extern, like functions - which means they are defined
somewhere else and need to be accessed from ooc code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
CpFloat: cover from cpFloat

CpVect: cover from cpVect {
  x, y: extern CpFloat
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Members can be aliased by using the &lt;code&gt;extern(original_name)&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Rectangle: cover from bar_rectangle_t {
  width: extern(Width)
  height: extern(Height)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Methods&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;extern&lt;/code&gt; function can be used to describe cover methods as well. Aliasing is
often good practice, as it allows to get rid of the unnecessary prefixes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FooContext: cover from foo_context_t {
  // extern constructor
  new: static extern(foo_context_new) func (CString, Int) -&amp;gt; This

  // extern method
  doSomething: extern(foo_context_do_something) -&amp;gt; CString

  // additional method
  doSomethingTwice: func {
    doSomething()
    doSomething()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so, a properly covered C struct with methods can be used as if it was an object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
context := FooContext new()
context doSomething()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Enumerations</title>
      <link>http://oocmanual.cogneco.com/language/enumerations/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/enumerations/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Enums&lt;/h1&gt;

&lt;p&gt;A set of values that a variable of that type can take. Useful when there are
three values or more, so a &lt;code&gt;Bool&lt;/code&gt; doesn&amp;rsquo;t make sense.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
DoorState: enum {
  OPEN
  CLOSED
  UNKNOWN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One can think of enum values as static members. Enums have their own types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
state: DoorState
state = DoorState OPEN

// or, simply
state := DoorState OPEN

match state {
  case DoorState OPEN =&amp;gt;
    &amp;quot;It&#39;s open!&amp;quot;
  case DoorState CLOSED =&amp;gt;
    &amp;quot;It&#39;s closed.&amp;quot;
  case =&amp;gt; &amp;quot;Who knows...&amp;quot;
} println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More example code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
isOpen?: func (state: DoorState) -&amp;gt; Bool {
  state == DoorState OPEN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Members&lt;/h2&gt;

&lt;p&gt;Enums can&amp;rsquo;t have members - they are just values without any added metadata.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Methods&lt;/h2&gt;

&lt;p&gt;Enums, however, can have methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
DoorState: enum {
  OPEN
  CLOSED
  UNKNOWN

  chance: func -&amp;gt; Float {
    match this {
      case This OPEN =&amp;gt; 1.0
      case This CLOSED =&amp;gt; 0.0
      case =&amp;gt; 0.5
    }
  }

  random: static func -&amp;gt; Float {
    Random randInt(0, 3) as This
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They can be used like regular objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
state := DoorState random()

&amp;quot;Generated a random door.&amp;quot; println()
&amp;quot;Chance we&#39;re passing through = %.2f&amp;quot; printfln(state chance())
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Backing type&lt;/h1&gt;

&lt;p&gt;By defaults, enums are backed by ints. That&amp;rsquo;s why they can be cast to
&lt;code&gt;Int&lt;/code&gt;, and vice versa.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Custom values&lt;/h2&gt;

&lt;p&gt;Custom values are specified with the assignment operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Number: enum {
  ONE
  TWO
  FOUR = 4
  FIVE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Values are computed like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the first value is &lt;code&gt;increment(0)&lt;/code&gt; if unspecified&lt;/li&gt;
&lt;li&gt;every value after that is &lt;code&gt;increment(previousValue)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;by default, the increment is &lt;code&gt;+1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read below for more on increments&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Custom increment&lt;/h2&gt;

&lt;p&gt;Custom increments can be specified after the &lt;code&gt;enum&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Odds: enum (+2) {
  ONE = 1
  THREE
  FIVE
  SEVEN
  NINE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiplication increments are valid as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Powers: enum (*2) {
  ONE = 1
  TWO
  FOUR
  EIGHT
  SIXTEEN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And multiplication increments are actually quite handy for things like bitsets.&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Extern enums&lt;/h1&gt;

&lt;p&gt;Enums can be extern, in which case every element will be a bare symbol, which should
be defined externally, in C code for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
ShutdownParam: extern enum {
  SHUT_RD    // generate C name SHUT_RD
  SHUT_WR    // generate C name SHUT_WR
  SHUT_RDWR  // generate C name SHUT_RDWR
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, each element can be aliased individually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
ShutdownParam: extern enum {
  extern(SHUT_RD) read
  extern(SHUT_WR) write
  extern(SHUT_RDWR) readWrite
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Covers vs Classes</title>
      <link>http://oocmanual.cogneco.com/language/covers-vs-classes/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/covers-vs-classes/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;When to use covers and classes&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Whenever possible, use classes.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re new to ooc, don&amp;rsquo;t use covers because you&amp;rsquo;ve heard they
are &amp;ldquo;faster&amp;rdquo;. Covers are powerful. Great power comes with great responsibility.
The sword cut both ways&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;By-reference, by-value&lt;/h2&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Classes&lt;/h2&gt;

&lt;p&gt;Classes are by-references. Which means every object is a reference. Doing that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: class {
        value: Int
        init: func (=value) {}
    }

    modifyRef: func (n: Number) {
        n = Number new(-1)
    }

    modifyInside: func (n: Number) {
        n value = -1
    }

    answer := Number new(42)
    modifyRef(answer) // does nothing
    modifyInside(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens in &amp;lsquo;modifyRef&amp;rsquo; is that we change the value of the parameter &amp;lsquo;n&amp;rsquo;.
The code does not modify what &amp;lsquo;n&amp;rsquo; was a reference to in the first place.
In the example above the variable &amp;lsquo;answer&amp;rsquo; is given as the argument and &amp;lsquo;modifyRef&amp;rsquo; has
no effect at all on &amp;lsquo;answer&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;However, in &amp;lsquo;modifyInside&amp;rsquo;, we actually modify the content of what &amp;lsquo;n&amp;rsquo; refers to.
Since &amp;lsquo;n&amp;rsquo; refers to &amp;lsquo;answer&amp;rsquo;, the code will modify its member &amp;lsquo;value&amp;rsquo; and set it to -1.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Covers&lt;/h2&gt;

&lt;p&gt;Covers are trickier. There are two types of covers: primitive covers and compound covers&lt;/p&gt;

&lt;p&gt;Primitive covers allow to us to add methods to an existing underlying type. For implementations
of ooc on top of C this means you can do stuff like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Int: cover from int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is actually the way all C types are used within ooc.&lt;/p&gt;

&lt;p&gt;As a consequence, covers are by-value. Which means that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    modify: func (i: Int) {
        i = -1
    }

    answer := 42
    modify(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doesn&amp;rsquo;t modify answer.&lt;/p&gt;

&lt;p&gt;But compound covers (you can think of them as structs) are also by value,
which means that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
    }

    modifyInside: func (n: Number) {
        n value = -1
    }

    answer: Number
    answer value = 42

    modifyInside(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Won&amp;rsquo;t modify &amp;lsquo;answer&amp;rsquo; at all, but a &lt;em&gt;copy&lt;/em&gt; of it that has been
passed to &amp;lsquo;modifyInside&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;As an interesting side effect, a &amp;lsquo;clone&amp;rsquo; method is futile for covers.&lt;/p&gt;

&lt;p&gt;It also means that this won&amp;rsquo;t work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
        init: func (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because init will be working on a &lt;em&gt;copy&lt;/em&gt; of the object, thus leaving
the original object unmodified. That&amp;rsquo;s why func@ exists, ie.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
        init: func@ (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &amp;lsquo;this&amp;rsquo; will be passed by reference. Same goes for any cover method
that modifies its content.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Heap allocation, stack allocation&lt;/h2&gt;

&lt;p&gt;When you do&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NumberClass: class {}
    n := NumberClass new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n may be allocated on the heap or on the stack, however the compiler sees fit.&lt;/p&gt;

&lt;p&gt;However, with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NumberCover: cover {}
    n: NumberCover
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n is allocated on the stack.&lt;/p&gt;

&lt;p&gt;Choosing whether to allocate an object on the stack or on the heap is a
non-trivial decision. In C++ for example, it is the role of the programmer
to decide whether to allocate on the stack or on the heap.&lt;/p&gt;

&lt;p&gt;In ooc, it&amp;rsquo;s the role of the compiler. Until the language is properly
standardized and annotations are added for extern functions to allow
escape analysis, the compiler may choose to only allocate on the heap.&lt;/p&gt;

&lt;p&gt;Allocating on the stack is much faster (since it only involves moving
the stack pointer), and the stack is always hot, the memory you get when
allocating is much more likely to be in cache than any far heap allocated
memory.&lt;/p&gt;

&lt;p&gt;So why don&amp;rsquo;t we always allocate on the stack? Why do we even bother about
heap allocation, which involves all kinds of housekeeping to know which
memory blocks are reserved and which are free?&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Why stack allocation isn&amp;rsquo;t a silver bullet&lt;/h2&gt;

&lt;p&gt;A typical stack size for C programs on desktop OSes is between 1MB and 2MB.
Therefore, if you need to allocate big objects, you may run out of stack space.&lt;/p&gt;

&lt;p&gt;Running out of stack space is really something to be avoided. It&amp;rsquo;s a lot
harder to debug than heap allocation failures. When heap allocation fails,
you usually get back a null pointer, and tools (GDB, Valgrind) help figuring
out the cause.&lt;/p&gt;

&lt;p&gt;However, when you run out of stack space, the program usually crashes violently
with very little information about the situation that lead to the crash.
Even worse, it could corrupt data without crashing.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s more, often, when a program crashes because of a stack allocation failure,
the call stack is overwritten with random data, making it impossible to trace back
the origin of the problem.&lt;/p&gt;

&lt;p&gt;To add insult to injury, as far as I know, there is no reliable and portable way
to know how much free memory is left on the stack.&lt;/p&gt;

&lt;p&gt;For all those reasons, stack allocation is sometimes entirely avoided,
because it&amp;rsquo;s tricky to deal with manually.&lt;/p&gt;

&lt;p&gt;The following IBM DeveloperWorks article goes more in-depth into the issue:
&lt;a href=&#34;http://www.ibm.com/developerworks/java/library/j-jtp09275.html&#34;&gt;http://www.ibm.com/developerworks/java/library/j-jtp09275.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Stack and scope&lt;/h2&gt;

&lt;p&gt;But wait, there&amp;rsquo;s more! (assuming you&amp;rsquo;re still reading at that point)&lt;/p&gt;

&lt;p&gt;Stack-allocated variables are deallocated when they go out of scope.&lt;/p&gt;

&lt;p&gt;What does that mean? It means that this code is wrong.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    getAnswer: func -&amp;gt; Int* {
        // answer is allocated on the stack
        answer := 42
        // we&#39;re returning the address of a local variable
        // this is WRONG, don&#39;t do it.
        answer&amp;amp;
        // when the function returns, &#39;answer&#39; goes out of scope
        // and is deallocated
    }

    answerPtr := getAnswer()
    &amp;quot;answer = %d&amp;quot; printfln(answerPtr@)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas this one will work perfectly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    getAnswer: func -&amp;gt; Int* {
        // answer is allocated on the heap
        answer := gc_malloc(Int size)
        answer@ = 42
        // we&#39;re returning the address of a heap-allocated variable
        // no problem with that. the memory will be freed on a garbage
        // collector sweep phase, when it will have detected that
        // it&#39;s unused
        answer
    }

    answerPtr := getAnswer()
    &amp;quot;answer = %d&amp;quot; printfln(answerPtr@)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the first version (returning the address of a local variable)
might work sometimes: don&amp;rsquo;t be surprised. If the memory address (on the stack
or in a register) where the local variable was stored isn&amp;rsquo;t overwritten
between the return from the function and the time when it&amp;rsquo;s used, it might
still contain the original value. But, again - it&amp;rsquo;s wrong and unreliable.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;When to use stack allocation&lt;/h2&gt;

&lt;p&gt;For small objects for which you need by-value behavior and of which you use
gazillions in your application.&lt;/p&gt;

&lt;p&gt;Each project is a unique situation - as a rule, I&amp;rsquo;d always advise to begin
with a class, and turn it into a cover later if the situation requires it.&lt;/p&gt;

&lt;p&gt;However, keep in mind that allocation is often not the first place to look
if you want to optimize your application. Remember to always use a profiler
(I find that valgrind + KCachegrind work particularly well with ooc code)
to figure out where the hotspots are in your code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>http://oocmanual.cogneco.com/language/exceptions/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/exceptions/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Error handling&lt;/h1&gt;

&lt;p&gt;The C way to do error handling is usually via return codes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
openFile: (path: String) -&amp;gt; Int {
  if (error) {
    return -1
  }
  return someFileDescriptor
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, it relies on the user correctly checking the return value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
fd := openFile(&amp;quot;/etc/hosts&amp;quot;)
doSomethingWithFile(fd) // forgot to check, things might go bad!
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Exceptions&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;raise&lt;/h2&gt;

&lt;p&gt;Another way to handle that would be with exceptions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
openFile: (path: String) -&amp;gt; File {
  if (error) {
    raise(&amp;quot;Could not open %s&amp;quot; format(path))
  }
  return someFile
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That way, even if the user doesn&amp;rsquo;t explicitly check for the error, it&amp;rsquo;ll
still interrupt the flow of the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file := openFile(&amp;quot;/dev/does/not/exist&amp;quot;)
doSomethingWithFile(file) // we are never even going to reach there
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Throwing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;raise&lt;/code&gt; function above is a quick method to raise an exception. What
it really does is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Exception new(message) throw()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no special keyword to throw exceptions, it&amp;rsquo;s just a method on the
&lt;code&gt;Exception&lt;/code&gt; class.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Catching exceptions&lt;/h2&gt;

&lt;p&gt;Catching exceptions is done through the &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  openFile(&amp;quot;dev/does/not/exist&amp;quot;)
} catch (e: Exception) {
  // something wrong happened
  &amp;quot;Error: %s&amp;quot; printfln(e message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Exception sub-classes&lt;/h2&gt;

&lt;p&gt;It is possible to sub-class exceptions to have several exception types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FileNotFoundException: class extends Exception {
  init: func (path: String) {
    super(&amp;quot;File not found: %s&amp;quot; format(path))
  }
}

openFile: func (path: String) {
  if (error) {
    FileNotFoundException new(path) throw()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which makes it easy to catch a specific type of exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  file := openFile(&amp;quot;/dev/does/not/exist&amp;quot;)
  doSomethingWithFile(file)
} catch (e1: FileNotFoundException) {
  // The file wasn&#39;t found
} catch (e2: Exception) {
  // Something else went wrong.
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>First-class Functions</title>
      <link>http://oocmanual.cogneco.com/language/first-class-functions/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/first-class-functions/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;First-class functions&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Functions are pieces of code that can take arguments, and return values.&lt;/p&gt;

&lt;p&gt;Named functions are declared with this syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;name&amp;gt; : func &amp;lt;arguments&amp;gt; &amp;lt;return type&amp;gt; {
        &amp;lt;body&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where arguments are comma-separated, enclosed between parenthesis, and return type
is prefixed with a right arrow -&amp;gt;.&lt;/p&gt;

&lt;p&gt;Arguments may be omitted if the function doesn&amp;rsquo;t take any, and return type
may be omitted too, if the function is void.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max: func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this is a valid expression too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    func &amp;lt;arguments&amp;gt; &amp;lt;return type&amp;gt; {
        &amp;lt;body&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with decl-assign, we can declare a variable named &amp;lsquo;max&amp;rsquo;, equal
to this expression. And then use it very much like a function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max := func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
    answer := max(-1, 42)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Differences between function and first-class functions&lt;/h2&gt;

&lt;p&gt;The first difference is: functions are immutable. First-class functions
are variables, and thus can be overwritten by simple assignment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // this is invalid: don&#39;t do that.
    someFunc: func {}
    someFunc = someOtherFunc

    // this, on the other hand, is valid
    someFunc := func {}
    someFunc = someOtherFunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second difference is: first-class functions can capture context.
Closures are first-class functions that capture context.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // here&#39;s a normal function
    clone: func (l: List&amp;lt;Int&amp;gt;) -&amp;gt; List&amp;lt;Int&amp;gt; {
        copy := ArrayList&amp;lt;Int&amp;gt; new(l size())
        l each(func(element: Int) {
            copy add(element)
        })
        copy
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, our anonymous, first-class function which also happens to be a closure, is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    func(element: Int) {
        copy add(element)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It captures the context because we access &amp;lsquo;copy&amp;rsquo; in it - which isn&amp;rsquo;t an
argument of the function, nor a variable declared inside the function.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s declared outside, and still we can access it - that&amp;rsquo;s what capturing
context is.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s sum up: first-class functions may be overwritten by assignment,
and may capture context.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;The type of first-class functions&lt;/h2&gt;

&lt;p&gt;So, when we do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max := func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What exactly is the type of &amp;lsquo;max&amp;rsquo; ?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s declare it in two steps  instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max : Func (Int, Int) -&amp;gt; Int
    max = func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Func&lt;/code&gt; is a type that has a special syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Func &amp;lt;argument types&amp;gt; &amp;lt;return type&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with regular functions declaration, both argument types and return types
can be omitted.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Type inference - ACS&lt;/h2&gt;

&lt;p&gt;Declaring the type of first-class functions is mostly useful in function arguments.&lt;/p&gt;

&lt;p&gt;For example, in the SDK, the declaration of each goes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    List: class &amp;lt;T&amp;gt; {
        each: func(f: Func (T)) {
            // ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it takes a function that takes one argument of type T&lt;/p&gt;

&lt;p&gt;Hence, clearly doing that in our clone function above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    l each(func(element: Int) {
        copy add(element)
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is unnecessary. Since we know that l is a List&lt;Int&gt;, and that each takes
a Func (T) then we know that element is of type Int.&lt;/p&gt;

&lt;p&gt;And thus, we can write that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    l each(|element|
        copy add(elements)
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The proper syntax for that is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(|&amp;lt;name of arguments&amp;gt;|
        &amp;lt;body&amp;gt;
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are no arguments, this is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(||
        &amp;lt;body&amp;gt;
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And is then equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(func {
        &amp;lt;body&amp;gt;
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return type is inferred as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Other differences - member functions vs member first-class functions&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        shout: func {
            &amp;quot;Woof woof&amp;quot; println()
        }

    }

    d := Dog new()
    d shout()

    Dog shout = func {
        &amp;quot;Ruff ruff&amp;quot; println()
    }
    d2 := Dog new()
    d shout()
    d2 shout()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Woof woof
    Ruff ruff
    Ruff ruff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When assigning &amp;lsquo;Dog shout&amp;rsquo;, we change the member method of &lt;em&gt;all&lt;/em&gt; past and
future Dog instances. This happens because &amp;lsquo;shout&amp;rsquo; is actually stored in the meta-class&lt;/p&gt;

&lt;p&gt;Consider the differences with that instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        shout := func {
            &amp;quot;Woof woof&amp;quot; println()
        }

    }

    d := Dog new()
    d shout()

    d shout = func {
        &amp;quot;Ruff ruff&amp;quot; println()
    }
    d2 := Dog new()
    d shout()
    d2 shout()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Woof woof
    Ruff ruff
    Woof woof
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &amp;lsquo;shout&amp;rsquo; is a member variable. Assigning to &amp;rsquo;d shout&amp;rsquo; changes it
only for that instance, so d2 shout isn&amp;rsquo;t changed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>http://oocmanual.cogneco.com/language/functions/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/functions/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Functions&lt;/h1&gt;

&lt;p&gt;A parameterized piece of code is often packaged into a function.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example function that adds two numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func (a: Int, b: Int) -&amp;gt; Int {
  return a + b
}

add(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The syntax for function signatures is &lt;code&gt;NAME: func (ARG1, ARG2, ...) -&amp;gt; RETURNTYPE&lt;/code&gt;.
Both the argument definition list and the arrow return type parts are optional, in case
a function takes no argument, or returns nothing. Hence, the following definitions are
all perfectly equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func () -&amp;gt; Void {}
f: func -&amp;gt; Void {}
f: func () {}
f: func {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments of the same type may be listed in short form: &lt;code&gt;name1, name2, name3: Type&lt;/code&gt;.
Also, the &lt;code&gt;return&lt;/code&gt; keyword is optional - it is only required to exit of the normal
function flow early. Hence, the first example can be rewritten like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func (a, b: Int) -&amp;gt; Int {
  a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the absence of a &lt;code&gt;return&lt;/code&gt; keyword in the body of a non-void function, the last
expression will be returned. This works with ifs, matches, etc.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Main&lt;/h1&gt;

&lt;p&gt;Perhaps the most interesting function at first is the &lt;code&gt;main&lt;/code&gt; function, aka the
entry point of a program. If not defined, one will be implicitly created. For
example, the following is a valid ooc program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Hi, world!&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we don&amp;rsquo;t need to process command-line arguments, we can define the main function
simply like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func {
  &amp;quot;Hi, world!&amp;quot; println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that any could outside the main function (and outside class definitions, etc.)
will get executed before the code in the main function is. This gives a chance for
module to run initialization code (e.g. C libraries that need some routine to be called
before anything else, to set up stuff).&lt;/p&gt;

&lt;p&gt;If we do want command-line arguments, we can do it the C way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func (argv: Int, argc: CString*) {
  for (i in 0..argv) {
    arg = argc[i]
    &amp;quot;Got argument: %s&amp;quot; printfln(arg toString())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, we can use an array of strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func (args: String[]) {
  // and so on..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, we can use an ArrayList of Strings, if more convenient:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import structs/ArrayList
main: func (args: ArrayList&amp;lt;String&amp;gt;) {
  // etc.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that command line arguments might not be relevant for all ooc implementations.
One could imagine an ooc implementation that compiles down to JavaScript - in which
case, running in a browser, the command line arguments would always be empty.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Suffixes / overloading&lt;/h1&gt;

&lt;p&gt;Functions can have the same name, but different signatures (argument lists and
return type), as long as they have different suffixes. They can be called without
suffix, in which case the compiler will infer the right function to call, or
explicitly by specifying the suffix by hand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func ~ints (a, b: Int) -&amp;gt; Int { a + b }
add: func ~floats (a, b: Float) -&amp;gt; Float { a + b }

add(1, 2) // calls ~ints variant
add(3.14, 5.0) // calls ~floats variant
add~floats(3, 5) // explicit call
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Variable arguments&lt;/h1&gt;

&lt;p&gt;Special slot in the argument list, can only be at the end, purpose is to accept
any number of arguments.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;ooc varargs&lt;/h2&gt;

&lt;p&gt;Store the number of arguments, and the types of each argument. Syntax is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func (args: ...) {
  // body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Access &lt;code&gt;args count&lt;/code&gt; to know how many arguments were passed.
Use &lt;code&gt;args iterator()&lt;/code&gt; to be able to iterate through the arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAll: func (things: ...) {
  &amp;quot;Printing %d things&amp;quot; printfln(things count)
  iter := things iterator()

  while (iter hasNext?()) {
    T := iter getNextType()
    &amp;quot;The next argument is a %s&amp;quot; printfln(T name)

    match T {
      case Int =&amp;gt; &amp;quot;%d&amp;quot; printfln(iter next(Int))
      case Float =&amp;gt; &amp;quot;%.2f&amp;quot; printfln(iter next(Float))
      case =&amp;gt; &amp;quot;Unsupported type&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More simply, &lt;code&gt;each&lt;/code&gt; can be used on a &lt;code&gt;VarArgs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAll: func (things: ...) {
  things each(|thing|
    match thing {
      case i: Int =&amp;gt; &amp;quot;%d&amp;quot; printfln(i)
      case f: Float =&amp;gt; &amp;quot;%.2f&amp;quot; printfln(f)
      case =&amp;gt; &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;C varargs&lt;/h2&gt;

&lt;p&gt;Used by writing simply &lt;code&gt;...&lt;/code&gt; in the argument list, not &lt;code&gt;args: ...&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func (firstArg: Type, ...) {
  // body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only accessible through &lt;code&gt;va_start&lt;/code&gt;, &lt;code&gt;va_next&lt;/code&gt;, &lt;code&gt;va_end&lt;/code&gt;. See &lt;a href=&#34;http://en.wikipedia.org/wiki/Variadic_function&#34;&gt;Variadic
function&lt;/a&gt; on Wikipedia.&lt;/p&gt;

&lt;p&gt;Useful only to relay a variable number of arguments to an extern C function,
since &lt;code&gt;va_arg&lt;/code&gt; couldn&amp;rsquo;t work (can&amp;rsquo;t quote raw C types in ooc).&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
vprintf: extern (s: CString, ...)

printf: func (s: String, ...) -&amp;gt; This {
  list: VaList
  va_start(list, this)
  vprintf(s toCString(), list)
  va_end(list)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Extern functions&lt;/h1&gt;

&lt;p&gt;To call a function defined elsewhere, for example in a C library, its prototype
needs to be defined&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exit: extern func (Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lazy way: type-only args, thorough way: variable-decl-args.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exit: extern func (exitCode: Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;By-ref parameters&lt;/h1&gt;

&lt;p&gt;Instead of having to dereference each time the parameter is accessed, just declare
it as a reference type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
increment: func (a: Int*) { a@ += 1 }
// vs
increment: func (a: Int@) { a += 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saves typing, saves error, clearer code. Can still access the address via &lt;code&gt;argument&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Closures&lt;/h1&gt;

&lt;p&gt;A very concise way to pass a function as an argument. &lt;code&gt;each&lt;/code&gt; is a typical
example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// definition
List: class &amp;lt;T&amp;gt; {
  each: func (f: Func (T)) { /* ... */ }
}

// usage
list := List&amp;lt;Int&amp;gt; new()
list each(|elem|
  // do something with elem, of type Int
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also works with several parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// definition
Map: class &amp;lt;K, V&amp;gt; {
  each: func (f: Func (K, V)) { /* ... */ }
}

// usage
map := Map&amp;lt;String, Horse&amp;gt; new()
map each(|key, value|
  // key is of type String, value is of type Horse
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Argument types are inferred, hence, the code is very short.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generics</title>
      <link>http://oocmanual.cogneco.com/language/generics/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/generics/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Generic functions&lt;/h1&gt;

&lt;p&gt;Since ooc is strongly typed, usually when definining a function,
it will only accept one type of argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printInt: func (value: Int) {
  value toString() println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But what if a function is meant to accept various types and react
accordingly? Generics can be used for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAnything: func &amp;lt;T&amp;gt; (value: T) {
  value toString() println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that&amp;rsquo;s a step in the right direction. But it won&amp;rsquo;t work, because
you can&amp;rsquo;t call methods on generics types. Since &lt;code&gt;T&lt;/code&gt; could be anything,
from a String to an array to an Int, we can&amp;rsquo;t make sure it even has a
&lt;code&gt;toString&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;What we can do is match on &lt;code&gt;T&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAnything: func &amp;lt;T&amp;gt; (value: T) {
  match T {
    case Int =&amp;gt;
      value as Int toString() println()
    case =&amp;gt;
      &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot; println()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s not very convenient - here&amp;rsquo;s another way to write it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAnything: func &amp;lt;T&amp;gt; (value: T) {
  match value {
    case i: Int =&amp;gt;
      i toString()
    case =&amp;gt;
      &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;
  } println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Inference&lt;/h2&gt;

&lt;p&gt;Notice how we didn&amp;rsquo;t have to specify &lt;code&gt;T&lt;/code&gt; when calling &lt;code&gt;printAnything&lt;/code&gt;,
above? That&amp;rsquo;s because the type of &lt;code&gt;T&lt;/code&gt; is inferred. More complex inference
is supported as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map := HashMap&amp;lt;String, Int&amp;gt; new()
map put(&amp;quot;one&amp;quot;, 1)
printMap(map)

printMap: func &amp;lt;K, V&amp;gt; (list: HashMap&amp;lt;K, V&amp;gt;) {
  // when called from above, K == String, and V == Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works for closures as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import structs/[ArrayList, List]

map: func &amp;lt;T, U&amp;gt; (list: List&amp;lt;T&amp;gt;, f: Func (T) -&amp;gt; U) -&amp;gt; List&amp;lt;U&amp;gt; {
  copy := ArrayList&amp;lt;U&amp;gt; new()
  for (elem in list) {
    copy add(f(elem))
  }
  copy
}

a := [1, 2, 3] as ArrayList&amp;lt;Int&amp;gt;
b := map(a, |i| i toString())
b join(&amp;quot;, &amp;quot;) println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;U&lt;/code&gt; is inferred from the return type of the closure.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Generic classes&lt;/h1&gt;

&lt;p&gt;Above, we have used generic types, such as &lt;code&gt;ArrayList&amp;lt;T&amp;gt;&lt;/code&gt; and
&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; - how can they be defined? Just like functions, by
putting generic type arguments in-between chevrons (&lt;code&gt;&amp;lt;Type1, Type2&amp;gt;&lt;/code&gt;)
in the class definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Container: class &amp;lt;T&amp;gt; {
  t: T

  init: func (=t)
  get: func -&amp;gt; T { t }
  set: func (=t)
}

c := Container&amp;lt;Int&amp;gt; new(24)
c set(12)
c get() toString() println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that inference works here too - since we are passing
a &lt;code&gt;T&lt;/code&gt; to the constructor, the instanciation part could be
simply rewritten as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
c := Container new(24)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Inheritance&lt;/h2&gt;

&lt;p&gt;Generic types can have subtypes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
ContainerToo: class &amp;lt;T&amp;gt; extends Container&amp;lt;T&amp;gt; {
  print: func {
    match t {
      case i: Int =&amp;gt; i toString()
      case =&amp;gt; &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;
    } print()
  }
}

c := ContainerToo new(24)
c print()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Specialization&lt;/h2&gt;

&lt;p&gt;Specialization happens when a sub-type has fewer type parameters
than its super-type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
IntContainer: class extends Container&amp;lt;Int&amp;gt; {
  print: func {
    get() toString() println()
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Language</title>
      <link>http://oocmanual.cogneco.com/language/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The OOC Language&lt;/h1&gt;

&lt;p&gt;The language has grown over the years, but it&amp;rsquo;s still relatively tidy.
Here&amp;rsquo;s a list of sections of the language documentation:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;modules&#34;&gt;Modules&lt;/a&gt; chapter discusses &lt;code&gt;.ooc&lt;/code&gt; files, what
a module is, what a package is, how imports and includes work.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;values&#34;&gt;Values&lt;/a&gt; chapter talks number literals, string
literals, operators, variable declarations, and a few built-in types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;control-structures&#34;&gt;Control Structures&lt;/a&gt; chapter describes
mundane constructs like if, else, for, while, break, continue, but also
match.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;collections&#34;&gt;Collections&lt;/a&gt; chapter talks about
arrays and maps, among other things.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;functions&#34;&gt;Functions&lt;/a&gt; chapter will teach you anything
from declaring function to calling them, to using external functions
(from a C library, for example), but also variable arguments, default
arguments, first-class functions and a nice syntax for closures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;classes&#34;&gt;Classes&lt;/a&gt; chapter is here to help you realize
that ooc classes are a lot like Java classes, except when they are not.
Constructors, inheritance, abstract methods, initializers, and even
interfaces have found their way in here.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;operators&#34;&gt;Operators&lt;/a&gt; chapter lists various mathematic
and logic operators, their priorities, how to overload them, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;covers&#34;&gt;Covers&lt;/a&gt; chapter discusses a construct halfway
between C structs and ooc classes, that is a major actor in making C
libraries easier to use.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;enumerations&#34;&gt;Enumerations&lt;/a&gt; chapter goes over the last kind of ooc
types - an enumeration of things. How to define them, use them, you
name it. (No, seriously, anonymous enums don&amp;rsquo;t exist)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;tuples&#34;&gt;Tuples&lt;/a&gt; chapter explains what tuples are and
what they aren&amp;rsquo;t. It covers multi-return, multi-declaration, variable
swapping, and cover literals.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;generics&#34;&gt;Generics&lt;/a&gt; chapter talks about parameterized
types, how to define them, how to use them, what are their strong points
and their shortcomings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;exceptions&#34;&gt;Exceptions&lt;/a&gt; chapter talks about error
handling, how to throw and catch Exceptions, and how to create your own
exception types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;preprocessor&#34;&gt;Preprocessor&lt;/a&gt; describes what happens to
the code before it is even compiled.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://oocmanual.cogneco.com/introduction/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/introduction/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Once Upon A Time&amp;hellip;&lt;/h1&gt;

&lt;p&gt;Once upon a time, there was a sysadmin who wanted to make sure her website
was always online. However, she figured that she was pretty good at compiling,
installing, and configuring software, but that her programming skills were a bit
rusty.&lt;/p&gt;

&lt;p&gt;Oh, sure, she remembered her days at university where she learned a bit of Java,
and C++, and the cool mind-bending exercises in LISP, but today she felt like trying
something new. She followed the &lt;a href=&#34;/install/&#34;&gt;installation instructions&lt;/a&gt; carefully, and then
jumped in without waiting.&lt;/p&gt;

&lt;p&gt;After fishing online for information, she decided to start with the following
program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;The website may or may not be online.&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saving it as &lt;code&gt;watchcorgi.ooc&lt;/code&gt; and running &lt;code&gt;rock -v watchcorgi&lt;/code&gt; sure produced a lot
of output. And - as a token of its appreciation, the compiler even left an executable
on the hard drive. What a promising relationship, she thought.&lt;/p&gt;

&lt;p&gt;However, not one to be overly chatty, she decided that instead of having to type
&lt;code&gt;rock watchcorgi&lt;/code&gt; every time she wanted to compile her new program, she was going
to write a &lt;a href=&#34;/docs/tools/rock/usefiles&#34;&gt;usefile&lt;/a&gt; for it, and put them both together in a directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!yaml
Name: Watch Corgi
Description: Tells on the bad websites that go down
Version: 0.1.0
SourcePath: source
Main: watchcorgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saving it as &lt;code&gt;watchcorgi.use&lt;/code&gt;, she realized that, if she wanted her usefile to be
valid, she needed to move her ooc module into &lt;code&gt;source/watchcorgi.ooc&lt;/code&gt;. So then, her
folder hierarchy now looked like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── source
│   └── watchcorgi.ooc
└── watchcorgi.use
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, all she had to do was type &lt;code&gt;rock&lt;/code&gt; to have her program compiled. If she felt
like reading a bit, all she had to do was &lt;code&gt;rock -v&lt;/code&gt; - it reminded her of the countless
hours spent installing packages on Gentoo.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;The Great Illusion&lt;/h1&gt;

&lt;p&gt;However, that program was not quite as useful as she had hoped so far. While it was
technically correct — the best kind of correct — it did not, in fact, bring any new
information to the table.&lt;/p&gt;

&lt;p&gt;That was not meant to last, though, as she quickly devised a devious scheme. Before
the era of watchcorgi, she was using &lt;code&gt;curl&lt;/code&gt;, a command-line utility, to check if the
website was still online. It looked a little something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
curl -I http://example.org/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Of course, that wasn&amp;rsquo;t her website&amp;rsquo;s actual URL, which we have sneakingly substituted
with something a tad more common, in order to protect our heroine&amp;rsquo;s privacy.)&lt;/p&gt;

&lt;p&gt;Running that simple command was enough to let her know, with a simple look, whether
the website was up and running or down in the ground — in which case prompt maintenance
was needed as soon as humanly possible.&lt;/p&gt;

&lt;p&gt;She decided that if she could run that command herself, there was no reason why her
program couldn&amp;rsquo;t do so as well. After a second documentation hunt, she quickly jotted
down a few more lines, replacing the contents of &lt;code&gt;source/watchcorgi.ooc&lt;/code&gt; with this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Process

exitCode := Process new([&amp;quot;curl&amp;quot;, &amp;quot;-I&amp;quot;, &amp;quot;http://example.org/&amp;quot;]) execute()
&amp;quot;Sir Curl exited with: %d&amp;quot; printfln(exitCode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And sure enough, after a quick recompilation, she saw the expected result: &lt;code&gt;Sir Curl
exited with: 0&lt;/code&gt;. Curious, she disconnected from the internet, and tried launching
&lt;code&gt;./watchcorgi&lt;/code&gt; again. This time, she saw: &lt;code&gt;Sir Curl exited with: 6&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;It&amp;rsquo;s just like it always is with Unix-like tools&amp;rdquo; she thought. &amp;ldquo;An exit code of 0
is a good sign, anything else&amp;hellip; not so much. It sure is convenient to be able
to import another ooc module for almost everything. Apparently, this &lt;code&gt;Process&lt;/code&gt; class
takes an array with the command arguments. And this &lt;code&gt;execute&lt;/code&gt; method returns the
exit code. Neato!&amp;rdquo; And so it was.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Form Follows Function&lt;/h1&gt;

&lt;p&gt;She was starting to be happy with her program. For all intents and purposes, was doing
its job, and it was doing its job well. However, she could not deny that her program
could have put a little more effort in the presentation. Just because a program does
not have a will of its own, doesn&amp;rsquo;t mean it&amp;rsquo;s okay for it to be rude.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Time to get to work&amp;rdquo;, she said out loud, forgetting that it was past 2 in the morning,
and that nobody could probably hear her - and even if they could, there was no
certainty that they would agree. While she thought about that, her fingers had kept
tapping on the keyboard. Her program now looked a little bit like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Process, Terminal]

exitCode := Process new([&amp;quot;curl&amp;quot;, &amp;quot;-I&amp;quot;, &amp;quot;http://example.org/&amp;quot;]) execute()

match (exitCode) {
  case 0 =&amp;gt;
    &amp;quot;Everything is fine.&amp;quot; println()

  case =&amp;gt;
    Terminal setFgColor(Color red)
    &amp;quot;[ERROR] The website is down!&amp;quot; println()
    Terminal reset()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It didn&amp;rsquo;t blink, and there were no 3D effects: disappointing maybe for a sci-fi
fan like her little brother, but having alerts in red, and a human-readable message
was fine enough for her.&lt;/p&gt;

&lt;p&gt;While carefully proofreading her code to check if she hadn&amp;rsquo;t missed anything, she
thought about the syntax of the &lt;code&gt;match&lt;/code&gt; construct. &amp;ldquo;It&amp;rsquo;s pretty smart, in fact.
Cases are tested from top to bottom - the first that matches, wins. And a case with
no value simply matches everything&amp;rdquo;. It just made sense.&lt;/p&gt;

&lt;p&gt;She was also particularly happy with the way she was able to import both &lt;code&gt;os/Process&lt;/code&gt;
and &lt;code&gt;os/Terminal&lt;/code&gt; from the same line. Sure, she could have written two different
&lt;code&gt;import&lt;/code&gt; directives, but she had been promised a concise programming language and it
was about time it delivered.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Corgi Ever Watching&lt;/h1&gt;

&lt;p&gt;Now that the program was polite, our programmer felt good enough to take a
small break. As she was looking out the window, waiting for her 3rd cup of
nocturnal coffee to brew, it came to her: &amp;ldquo;Wait a minute&amp;hellip; what good is my
program if I have to keep running it manually?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;A quick sip out of her coffee cup finished to clear her mind completely.
&amp;ldquo;I am going to need some sort of loop. And I think watchcorgi should shut
up if everything is fine, and only complain if something goes wrong.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;As she looked at her timer, waiting for it to run out and allow her to go back
to hacking (self-discipline is important, after all), she came to a second
realization: that there were two main tasks in her program - the checking, and
the notifying. Surely there must be some way to write that in a more modular
way?&lt;/p&gt;

&lt;p&gt;She decided to go for broke, and split her program into three different ooc
modules. She started with &lt;code&gt;source/watchcorgi/checker.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Process]

Checker: class {
  url: String

  init: func (=url)

  /**
   * @return true if the url is reachable, false otherwise
   */
  check: func -&amp;gt; Bool {
    0 == Process new([&amp;quot;curl&amp;quot;, &amp;quot;-I&amp;quot;, url]) execute()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then went on with &lt;code&gt;source/watchcorgi/notifier.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Terminal]

Notifier: class {
  quiet: Bool

  init: func

  notify: func (online: Bool, url: String) {
    if (online) {
      if (quiet) return

      Terminal setFgColor(Color green)
      &amp;quot;[ OK  ] %s is online.&amp;quot; printfln(url)
      Terminal reset()
    } else {
      Terminal setFgColor(Color red)
      &amp;quot;[ERROR] %s is not reachable! You may panic now.&amp;quot; printfln(url)
      Terminal reset()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, thought it was better to rewrite &lt;code&gt;source/watchcorgi.ooc&lt;/code&gt; from
scratch using those new modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import watchcorgi/[checker, notifier]
import os/Time

notifier := Notifier new()
notifier quiet = true // only bother me if something goes wrong
checker := Checker new(&amp;quot;http://example.org/&amp;quot;)

while (true) {
  notifier notify(checker check(), checker url)
  Time sleepSec(5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There. All good. Not only was her program now constantly vigilant, checking
for potential problems every five seconds, she felt that the various components
were just as flexible as needed, small enough, and that it made the main program
file short and sweet.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;The Littlest Things&lt;/h1&gt;

&lt;p&gt;There was one area of the code she wasn&amp;rsquo;t entirely happy with - in the
notifier, she was using the same pattern twice. First &lt;code&gt;Terminal setFgColor&lt;/code&gt;,
then &lt;code&gt;String printfln&lt;/code&gt;, then &lt;code&gt;Terminal reset&lt;/code&gt;.  She decided to extract that
pattern into a function instead, and added it to the end of the the &lt;code&gt;Notifier&lt;/code&gt;
class definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
say: func (color: Color, message: String) {
  Terminal setFgColor(color)
  message println()
  Terminal reset()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With that new neighbor, the notify function was happy to be reduced to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
notify: (online: Bool, url: String) {
  if (online) {
    if (quiet) return
    say(Color green, &amp;quot;[ OK  ] %s is online&amp;quot; format(url))
  } else {
    say(Color red, &amp;quot;[ERROR] %s is not reachable! You may panic now.&amp;quot; \
      format(url))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this was better, she wasn&amp;rsquo;t satisfied yet - calling &lt;code&gt;format&lt;/code&gt; like this
(she thought of it as a version of &lt;code&gt;printfln&lt;/code&gt; that returned the formatted string
instead of printing it) wasn&amp;rsquo;t particularly pretty.&lt;/p&gt;

&lt;p&gt;Like with everything that bothered her, she decided to do something about it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
say: func (color: Color, message: String, args: ...) {
  Terminal setFgColor(color)
  message printfln(args)
  Terminal reset()
}

notify: func (online: Bool, url: String) {
  if (online) {
    if (quiet) return
    say(Color green, &amp;quot;[ OK  ] %s is online&amp;quot;, url)
  } else {
    say(Color red, &amp;quot;[ERROR] %s is not reachable! You may panic now.&amp;quot;, url)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It was subtle, but for her, it made all the difference. Being able to relay
any number of arguments like that? This language might actually be comfortable
after all.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;All Together Now&lt;/h1&gt;

&lt;p&gt;&amp;ldquo;So, that was nice. For the life of me, I can&amp;rsquo;t think of a single thing my program
is missing.&amp;rdquo; Her eyes closed gently, and she leaned back, as if overwhelmed by bliss.&lt;/p&gt;

&lt;p&gt;Wait. Her eyes, suddenly inquisitive, were perfectly open now. &amp;ldquo;What if I want
to monitor several websites? Then I would need a config file so that I could modify
the list of websites to monitor&amp;hellip; and it would need to check them in parallel, so
it doesn&amp;rsquo;t get stuck on any one of them.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;She decided she needed one more module: &lt;code&gt;source/watchcorgi/config.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import io/File
import os/Env
import structs/List
import text/StringTokenizer

DEFAULT_PATH := Env get(&amp;quot;HOME&amp;quot;) + &amp;quot;/.config/corgirc&amp;quot;

Config: class {
  websites: List&amp;lt;String&amp;gt;

  init: func (path := DEFAULT_PATH) {
    content := File new(path) read()
    websites = content split(&#39;\n&#39;) \
               map(|line| line trim(&amp;quot;\t &amp;quot;)) \
               filter(|line| !line empty?())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Armed with that new weapon, checking multiple websites in parallel was just a
matter of making threads behave. Since she didn&amp;rsquo;t have much experience in the
domain, and the documentation seemed a little bit obscure, she decided to ask
for help in the &lt;a href=&#34;https://groups.google.com/group/ooc-lang&#34;&gt;ooc discussion group&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Almost immediately, a response sprung with numerous code examples she could use
as inspiration for her own endeavor. And so she embarked courageously,
rewriting &lt;code&gt;source/watchcorgi.ooc&lt;/code&gt; once again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import watchcorgi/[config, checker, notifier]
import os/Time
import threading/Thread
import structs/[ArrayList]

threads := ArrayList&amp;lt;Thread&amp;gt; new()
config := Config new()

for (url in config websites) {
  threads add(Thread new(||
    guard := Guard new(url, 5)
    guard run()
  ))
}

// start all the threads
for (thread in threads) {
  thread start()
}

// wait for all threads to complete
threads each(|thread| thread wait())

Guard: class {
    delay: Int
    checker: Checker
    notifier: Notifier

    init: func (url: String, =delay) {
      checker = Checker new(url)
      notifier = Notifier new()
      notifier quiet = true
    }

    run: func {
      while (true) {
        notifier notify(checker check(), checker url)
        Time sleepSec(delay)
      }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As she began to write down a list of websites to check in &lt;code&gt;~/.config/corgirc&lt;/code&gt;,
she started to list the new things she had learned during that last refactoring:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;That classes can be used before they are defined - in order word, the order
in which classes are defined does not matter!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That threads, while really old fashioned, were quite easy to use - all you
had to do was create a new &lt;code&gt;Thread&lt;/code&gt; object and pass a function that takes
zero arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That some functions are anonymous - and that they can be defined as an
argument to a function call like this: &lt;code&gt;[1, 2, 3] reduce(|a, b| a + b)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That using a foreach, such as &lt;code&gt;for (element in iterable) { /* code */ }&lt;/code&gt; or
using the each method, like so &lt;code&gt;iterable each(|element| /* code */ )&lt;/code&gt;, where
pretty much equivalent.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;When Features Creep&lt;/h1&gt;

&lt;p&gt;As magnificent as the program was, she couldn&amp;rsquo;t shake an eerie feeling. It
seemed so perfect, so concise, so damn practical - what could possibly go
wrong?&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Oh, right!&amp;rdquo; she whispered. The program assumes that the &lt;code&gt;curl&lt;/code&gt; command-line
utility is installed and in the &lt;code&gt;$PATH&lt;/code&gt;. While on most Linux distributions,
that&amp;rsquo;s a safe bet, it might not be there on OSX. Or, god forbid, on Windows.&lt;/p&gt;

&lt;p&gt;But it was almost 6AM, and rays of sunlight would soon come and disturb the
oh so peaceful (yet eventful) night of coding. Obviously, she could not afford
to write her own HTTP library.&lt;/p&gt;

&lt;p&gt;Sure, in theory, a simple usage of &lt;code&gt;net/TCPSocket&lt;/code&gt; from the SDK, writing
something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HEAD / HTTP/1.0\r\n\r\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..and seeing if you get a non-empty response, would suffice. But what about
parsing empty, yet worrying responses, like an HTTP 404, or an HTTP 502? What
about HTTP 1.1 and the Host header, essential when several websites are running
on the same IP address? And most importantly, what about HTTPS, which runs on a
different port, and what&amp;rsquo;s more, over SSL?&lt;/p&gt;

&lt;p&gt;No, definitely, writing an HTTP library was not part of the plan. But maybe
there was something she could use&amp;hellip; maybe curl existed also as a library. A
quick search for &lt;code&gt;ooc curl&lt;/code&gt; revealed the existence of
&lt;a href=&#34;https://github.com/nddrylliog/ooc-curl&#34;&gt;nddrylliog/ooc-curl&lt;/a&gt;. Jackpot!&lt;/p&gt;

&lt;p&gt;A quick clone and.. wait. She knew better. Why not use &lt;a href=&#34;/docs/tools/sam/&#34;&gt;sam&lt;/a&gt; instead?
A simple &lt;code&gt;sam clone curl&lt;/code&gt; would suffice. Or, better yet, she could add the
dependency in the .use file, and run &lt;code&gt;sam get&lt;/code&gt; from the watchcorgi folder
afterwards.&lt;/p&gt;

&lt;p&gt;Her .use file now looked a little bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!yaml
Name: Watch Corgi
Description: Multi-threaded website monitoring system
Version: 0.2.0

SourcePath: source
Main: watchcorgi
Requires: curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And sure enough, after &lt;code&gt;sam get&lt;/code&gt;, she saw the &lt;code&gt;ooc-curl&lt;/code&gt; folder appear in her
&lt;code&gt;$OOC_LIBS&lt;/code&gt; directory. It was time to rewrite &lt;code&gt;source/watchcorgi/checker.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
use curl
import curl/Highlevel

Checker: class {
    url: String

    init: func (=url)

    /**
     * @return true if the url is reachable, false otherwise
     */
    check: func -&amp;gt; Bool {
      200 == (HTTPRequest new(url). perform(). getResponseCode())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code was one of her favorites yet. She had used one of the
features she had just learned about - call chaining. &amp;ldquo;In fact&amp;rdquo;, she would
later explain to a colleague, &amp;ldquo;you can think of the dot as a comma - it
separates several method calls, but they all happen on the same object,
sequentially&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Recompiling the program after this change was exciting. There was no
configuration dialog to fill out. No complicated command-line option to add
when compiling. As a matter of fact, the single line added to the use file was
enough to make sam happy - and rock itself seemed pretty content with the &lt;code&gt;use
curl&lt;/code&gt; directive now sitting at the top of the checker module.&lt;/p&gt;

&lt;p&gt;A simple &lt;code&gt;rock -v&lt;/code&gt; did the trick. And there she had it. The perfect website
monitoring system. At last. Oh, sure, part of her brain fully realized that
the impression of perfectness would fade out over the days, but as far as
discovering a new language goes, she thought this was a pretty good run.&lt;/p&gt;

&lt;p&gt;There was just one thing left to do&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;To Give Back&lt;/h1&gt;

&lt;p&gt;At this point, she felt that watchcorgi it was worth it to publish her program
somewhere. Of course, all along, she had been keeping track of it using
&lt;a href=&#34;http://git-scm.org/&#34;&gt;git&lt;/a&gt;. In this case, she was using &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; as a host.&lt;/p&gt;

&lt;p&gt;She decided to make it easy for other people who might want to use
&lt;code&gt;watchcorgi&lt;/code&gt;, to get it. After a quick search, it quickly became evident that
the process itself was trivial. She just had to send a pull request to the
&lt;a href=&#34;https://github.com/nddrylliog/sam&#34;&gt;sam repository&lt;/a&gt; that added a formula for her new pet project.&lt;/p&gt;

&lt;p&gt;So, after forking sam on GitHub, changing the origin of her sam repository,
she opened a new file in &lt;code&gt;$OOC_LIBS/sam/library/watchcorgi.yml&lt;/code&gt;, and wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!yaml
Origin: https://github.com/example/watchcorgi.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then, she &lt;a href=&#34;https://help.github.com/articles/creating-a-pull-request&#34;&gt;submitted the pull request&lt;/a&gt;. The sun was rising.
It felt warm. I think - she thought - I just might like it here.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>