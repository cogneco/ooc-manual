<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Glossary</title>
      <link>http://oocmanual.cogneco.com/glossary</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/glossary</guid>
      <description>&lt;p&gt;{{GLOSSARY}}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Manual</title>
      <link>http://oocmanual.cogneco.com/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;How to use the documentation&lt;/h1&gt;

&lt;p&gt;The documentation for ooc is structured as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tutorial/&#34;&gt;Tutorial&lt;/a&gt; is a ten minute journey meant for
newcomers to the language. By building a small program, you will learn the
basics of the syntax and even use bits of the SDK.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/lang/&#34;&gt;Language&lt;/a&gt; section explains in detail every feature
of the language: it goes through the syntax and a the main use cases for
every feature. It also contains a full grammar, and a collection of best
practices.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/sdk/&#34;&gt;SDK&lt;/a&gt; section gives an overview of the modules included
with the default ooc distribution. Whether you need access to files, to
measure time, to do some networking, or simply use common data structures,
the SDK is packed with goodness.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/&#34;&gt;Tools&lt;/a&gt; section lists useful tools for ooc development,
along with a typical workflow from the creation, compilation, testing, and
documentation of a project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/kaputt/&#34;&gt;Troubleshooting&lt;/a&gt; section gives advice on how
to address frequently encountered problems.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/glossary/&#34;&gt;Glossary&lt;/a&gt; is a collection of terms you may stumble
upon while using ooc or reading its documentation. If you don&amp;rsquo;t understand
a term, go here!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When you’re stuck with a question or a problem the documentation doesn’t
solve, considering posting to the &lt;a href=&#34;https://groups.google.com/group/ooc-lang&#34;&gt;discussion group&lt;/a&gt; or joining the
&lt;a href=&#34;irc://chat.freenode.net/#ooc-lang&#34;&gt;ooc-lang IRC channel&lt;/a&gt;. We’ll get it sorted out in no time. Check out the
&lt;a href=&#34;/community/&#34;&gt;Community&lt;/a&gt; page for details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mmap</title>
      <link>http://oocmanual.cogneco.com/sdk/os/mmap</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/mmap</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/mmap module&lt;/h1&gt;

&lt;p&gt;As it stands, the &lt;code&gt;os/mmap&lt;/code&gt; module just exposes the *nix functions for memory
mapping: &lt;code&gt;mmap&lt;/code&gt;, &lt;code&gt;munmap&lt;/code&gt;, &lt;code&gt;mprotect&lt;/code&gt;, &lt;code&gt;madvise&lt;/code&gt;, &lt;code&gt;mincore&lt;/code&gt;, &lt;code&gt;minherit&lt;/code&gt;,
&lt;code&gt;msync&lt;/code&gt;, &lt;code&gt;mlock&lt;/code&gt;, and &lt;code&gt;munlock&lt;/code&gt;, along with the associated constants.&lt;/p&gt;

&lt;p&gt;It also contains prototypes / covers for the Windows equivalent,
&lt;code&gt;VirtualProtect&lt;/code&gt;, and its constants as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;This module is not a high-level or cross-platform interface and is not
documented extensively here.&lt;/p&gt;

&lt;p&gt;However, to find more information on memory mapping for various platform
see here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap on Wikipedia&lt;/a&gt; (for *nix platforms)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/windows/desktop/aa366898(v=vs.85).aspx&#34;&gt;VirtualProtect on MSDN&lt;/a&gt; (for Windows)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On a historical note, this module was originally included in the SDK as support
code for the closure implementation, which back then implied generating
bytecode at runtime and thus marking some memory regions as executable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>system</title>
      <link>http://oocmanual.cogneco.com/sdk/os/system</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/system</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/System module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;System&lt;/code&gt; module allows to get information about the system, such
as the number of processors, as an &lt;code&gt;Int&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cores := System numProcessors()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the hostname of the machine, as a &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
hostname := System hostname()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>shellutils</title>
      <link>http://oocmanual.cogneco.com/sdk/os/shellutils</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/shellutils</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/ShellUtils module&lt;/h1&gt;

&lt;p&gt;The entire purpose of the &lt;code&gt;ShellUtils&lt;/code&gt; module is to find an
executable in the PATH environment variable.&lt;/p&gt;

&lt;p&gt;It can be used to implement functionality usually found in the
*nix &lt;code&gt;which&lt;/code&gt; command-line utility.&lt;/p&gt;

&lt;p&gt;For example, to know where &lt;code&gt;autoconf&lt;/code&gt; is hiding, one can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/ShellUtils
file := ShellUtils findExecutable(&amp;quot;autoconf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the executable is not found, &lt;code&gt;file&lt;/code&gt; here will be null. Otherwise,
it&amp;rsquo;ll correspond to the executable first found in the path:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match file {
    case null =&amp;gt; &amp;quot;autoconf not found&amp;quot;
    case =&amp;gt; &amp;quot;found: %s&amp;quot; format(file path)
} println()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Cross-platform&lt;/h2&gt;

&lt;p&gt;Adding the &lt;code&gt;.exe&lt;/code&gt; suffix is not necessary on Windows - it&amp;rsquo;ll be
added automatically on this platform when searching.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Crucial&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;findExecutable&lt;/code&gt; can be made to throw an exception in case an
executable is not found, instead of returning null. For this, pass
&lt;code&gt;true&lt;/code&gt; as its second argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// if we can&#39;t find make, don&#39;t even bother
make := ShellUtils findExecutable(&amp;quot;make&amp;quot;, true)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>pipe</title>
      <link>http://oocmanual.cogneco.com/sdk/os/pipe</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/pipe</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Pipe module&lt;/h1&gt;

&lt;p&gt;The Pipe module allows one to deal with pipes. Pipes are basically a pair of
read and write file descriptors.&lt;/p&gt;

&lt;p&gt;The writer writes into the write file descriptor and the reader reads into the
read file descriptor.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Reading&lt;/h2&gt;

&lt;p&gt;A read call may either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;successfully read, if there&amp;rsquo;s data in the pipe&lt;/li&gt;
&lt;li&gt;block to wait for some more data (in blocking mode)&lt;/li&gt;
&lt;li&gt;return immediately with no data (in non-blocking mode)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In non-blocking mode, one has to be careful to distinguish between the &amp;lsquo;no
data&amp;rsquo; condition and the &amp;lsquo;end of pipe&amp;rsquo; condition. OS pipes don&amp;rsquo;t have a proper
&amp;lsquo;eof&amp;rsquo; marker, but reading from a closed pipe will mark the Pipe class as eof
anyway, accessible with &lt;code&gt;Pipe eof?()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;os/Pipe&lt;/code&gt; package contains a &lt;code&gt;PipeReader&lt;/code&gt; class, which extends the
&lt;code&gt;io/Reader&lt;/code&gt; class, for convenience.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Writing&lt;/h2&gt;

&lt;p&gt;A write call may either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;return immediately if there&amp;rsquo;s room in the pipe&lt;/li&gt;
&lt;li&gt;block to wait for some data to be read, making room to write something (in
blocking mode)&lt;/li&gt;
&lt;li&gt;return immediately, having written as much as it can (in non-blocking mode)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;os/Pipe&lt;/code&gt; package contains a &lt;code&gt;PipeWriter&lt;/code&gt; class, which extends the
&lt;code&gt;io/Writer&lt;/code&gt; class, for convenience.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Buffering considerations&lt;/h2&gt;

&lt;p&gt;Note that a pipe&amp;rsquo;s user has to do its own buffering when writing: in blocking
mode, writing something too large will hang forever, and in non-blocking mode,
only the part that fits will be written, leaving the rest unwritten.&lt;/p&gt;

&lt;p&gt;As a result, using a &lt;code&gt;PipeReader&lt;/code&gt; or a &lt;code&gt;PipeReader&lt;/code&gt; in non-blocking mode is
unreliable.  Instead, using blocking mode inside a thread is preferrable.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;Here&amp;rsquo;s a not so useful pipe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe := Pipe new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can write a string into it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe write(&amp;quot;Hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then read the result back:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
str := pipe read(128)
str println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though we requested 128 bytes from the pipe, only 5 bytes have been written,
so we the call immediately returns with a String of size 5.&lt;/p&gt;

&lt;p&gt;We could have also read into our own buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
b := Buffer new(128)
pipe read(b)
b println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same here, the buffer has 128 bytes capacity, but only 5 bytes have been read, and
the buffer&amp;rsquo;s length has been set accordingly. Using a buffer is more efficient
because fewer allocations are being done.&lt;/p&gt;

&lt;p&gt;Then, we shouldn&amp;rsquo;t forget to close both the reading and the writing end of the pipe&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe close(&#39;r&#39;)
pipe close(&#39;w&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Communication&lt;/h1&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Inter-thread communication&lt;/h2&gt;

&lt;p&gt;Pipes can be used to communicate between threads.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a pipe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe := Pipe new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a thread that is going to read out of it until it&amp;rsquo;s closed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
reader := Thread new(||
    while (!pipe eof?()) {
        result := pipe read(128)
        if (result) result print()
    }
    pipe close(&#39;r&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a writer path which is going to write ten hellos, one every 100
milliseconds:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
writer := Thread new(||
    for (i in 0..10) {
        pipe write(&amp;quot;Hello %d\n&amp;quot; format(i))
        Time sleepMilli(100)
    }
    pipe close(&#39;w&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s start them both:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
reader start(); writer start()
reader wait();  writer wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Inter-process communication&lt;/h2&gt;

&lt;p&gt;Similarly, pipes can be (and are mostly) used to communicate with other
processes. This is covered in the &lt;a href=&#34;/docs/sdk/os/process/&#34;&gt;Process&lt;/a&gt; section.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Non-blocking I/O&lt;/h2&gt;

&lt;p&gt;A pipe can be set to non-blocking mode to use non-blocking read operations.
This is used in the streaming example in the &lt;a href=&#34;/docs/sdk/os/process/&#34;&gt;Process&lt;/a&gt; section.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a pipe in non-blocking mode for reading only:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe := Pipe new()
pipe setNonBlocking(&#39;r&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a state variable that&amp;rsquo;ll be shared by both threads:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
done := false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we&amp;rsquo;ll make a writer thread that never closes the pipe itself (much like a
process launched in the background that you never blockingly wait on):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
t := Thread new(||
  for (i in 0..10) {
    Time sleepSec(1)
    pipe write(&amp;quot;Hello %d&amp;quot; format(i))
  }
  done = true
)

t start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It does set done to true after it&amp;rsquo;s done, though - much like you could know if
a background process is still running with &lt;code&gt;waitNoHang&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then we&amp;rsquo;ll read, from the main thread, as much as we can, and when we don&amp;rsquo;t receive
anything, we&amp;rsquo;ll check if we&amp;rsquo;re done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (true) {
  res := pipe read(128)
  if (res) {
    &amp;quot;Received: %s&amp;quot; printfln(res)
  } else if (done) break
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And let&amp;rsquo;s not forget to clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pipe close()
t wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That behaves as expected. Note that in the main thread loop we could be doing anything
really, without blocking on the read.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Pipes disclaimer&lt;/h1&gt;

&lt;p&gt;If you have read all the way down, and you&amp;rsquo;re thinking of doing some complex
stuff with pipes, you probably want some queuing library instead of using raw
pipes, both for cross-platform support, performance, and ease of use.
&lt;a href=&#34;http://zeromq.org/&#34;&gt;zeromq&lt;/a&gt; is an interesting library and it has &lt;a href=&#34;https://github.com/nddrylliog/ooc-zeromq&#34;&gt;ooc bindings&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>terminal</title>
      <link>http://oocmanual.cogneco.com/sdk/os/terminal</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/terminal</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Terminal module&lt;/h1&gt;

&lt;p&gt;Terminal is used to control the terminal output, mostly by setting colors and
attributes on there.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Colors&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Color&lt;/code&gt; enum contains colors that are possible to set on the terminal:&lt;/p&gt;

&lt;p&gt;To change the foreground color, use &lt;code&gt;setFgColor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setFgColor(Color black)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To change the background color, use &lt;code&gt;setBgColor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setBgColor(Color white)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;List of colors&lt;/h2&gt;

&lt;p&gt;Here are the colors defined in the Color enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;black&lt;/li&gt;
&lt;li&gt;red&lt;/li&gt;
&lt;li&gt;green&lt;/li&gt;
&lt;li&gt;yellow&lt;/li&gt;
&lt;li&gt;blue&lt;/li&gt;
&lt;li&gt;magenta&lt;/li&gt;
&lt;li&gt;cyan&lt;/li&gt;
&lt;li&gt;grey&lt;/li&gt;
&lt;li&gt;white&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that depending on your terminal emulator, these colors
might not map to their actual names.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Attributes&lt;/h1&gt;

&lt;p&gt;Attributes can be set using &lt;code&gt;setAttr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setAttr(Attr bright)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;List of attributes&lt;/h2&gt;

&lt;p&gt;Here are the attributes defined in the &lt;code&gt;Attr&lt;/code&gt; enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reset&lt;/li&gt;
&lt;li&gt;bright&lt;/li&gt;
&lt;li&gt;dim&lt;/li&gt;
&lt;li&gt;under&lt;/li&gt;
&lt;li&gt;blink&lt;/li&gt;
&lt;li&gt;reverse&lt;/li&gt;
&lt;li&gt;hidden&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Resetting&lt;/h1&gt;

&lt;p&gt;Reset all color and attribute settings to default by using the
&lt;code&gt;reset&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal reset()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Cross-platform considerations&lt;/h1&gt;

&lt;p&gt;On *nix platforms, all attributes are supposed. On Windows, only
the &lt;code&gt;reset&lt;/code&gt; attribute is supported.&lt;/p&gt;

&lt;p&gt;On *nix, the &lt;code&gt;Terminal&lt;/code&gt; module outputs ANSI escape sequences to
stdout, whereas on Windows it uses the console text attribute API.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why there is no cross-platform way to transform a string
into a &amp;ldquo;colored string&amp;rdquo;, because it would make no sense on Windows.&lt;/p&gt;

&lt;p&gt;Also, on *nix, color escapes will only be outputted if stdout is
a terminal and not if it&amp;rsquo;s redirected to a file or a pipe.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>memory</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/memory</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/memory</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Memory&lt;/h1&gt;

&lt;p&gt;Sometimes, you just have to handle memory yourself. None of that class
or cover stuff, just give me a raw block of memory any day.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll see the &lt;code&gt;gc_&lt;/code&gt; prefix being used in the following page: that stands
for Garbage Collection, which is enabled by default in ooc. However, when
the GC is disabled, those will point to non-GC version of the functions.&lt;/p&gt;

&lt;p&gt;So that your code remains flexible, do yourself a favor and use the &lt;code&gt;gc_&lt;/code&gt;
variants regardless.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Allocating memory&lt;/h2&gt;

&lt;p&gt;Use &lt;code&gt;gc_malloc&lt;/code&gt; to get a chunk of memory all to yourself.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves a slice of 4 bytes
block := gc_malloc(4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, you&amp;rsquo;ll get a &lt;code&gt;Pointer&lt;/code&gt; back - which is a little bit pointless.
Plus you&amp;rsquo;ll probably want to determine how much you are allocating as
a function of the size of some other type instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves room to store 4 doubles.
doubles := gc_malloc(4 * Double size) as Double*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s better. Now you can index that, like any pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
doubles[0] = 3.14    
doubles[1] = 6.28    
// etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pointer arithmetic works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
addressOfSecondDouble := doubles + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then again, why not write it the explicit way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
addressOfSecondDouble := doubles[1]&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;gc_malloc&lt;/code&gt; returns zeroed memory (even when the GC is disabled),
just like the C function &lt;code&gt;calloc&lt;/code&gt; does. While a small performance hit, a
little additional safety can&amp;rsquo;t hurt.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Allocating in bulks&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;calloc&lt;/code&gt; is typically used in C to get zeroed memory (e.g. all null bytes).
This is unnecessary in ooc, since &lt;code&gt;gc_malloc&lt;/code&gt; returns zeroed memory anyway.&lt;/p&gt;

&lt;p&gt;In the rare cases where you do mean to allocate &lt;code&gt;num&lt;/code&gt; members of size &lt;code&gt;size&lt;/code&gt;,
use &lt;code&gt;gc_calloc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
members := gc_calloc(num, size)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Re-allocating memory&lt;/h2&gt;

&lt;p&gt;Didn&amp;rsquo;t get enough the first time around? Misjudged your budget needs?&lt;/p&gt;

&lt;p&gt;Fear not, &lt;code&gt;gc_realloc&lt;/code&gt; is here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// get ourselves 4 bytes
block := gc_malloc(4)

// woops, make that 8
block = gc_realloc(block, 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Duplicating memory&lt;/h2&gt;

&lt;p&gt;In our family of memory-related functions, &lt;code&gt;gc_strdup&lt;/code&gt;, nostalgically
named as if it was only used with strings, is here. It&amp;rsquo;ll make a copy of
a block of memory so that the original may be disposed of.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
someCallback: func (word: CString) {
  // CString is a pointer to a memory block that will get
  // overriden sometimes after this function returns - hence,
  // we want to make a copy so that the data we got doesn&#39;t
  // get tampered with.
  storeString(String new(gc_strdup(word)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The block of code above shows the typical use case, anyway.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Freeing memory&lt;/h2&gt;

&lt;p&gt;Technically, since we are using a garbage collector, you don&amp;rsquo;t need to
free explicitly. Should you feel the need to do so, however, &lt;code&gt;gc_free&lt;/code&gt; is
here to do the job:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// you know what, I&#39;m good for now, thanks.
gc_free(block)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Basic Usage</title>
      <link>http://oocmanual.cogneco.com/tools/rock/basic</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/basic</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Using rock, the basic way&lt;/h1&gt;

&lt;p&gt;If you have a usefile, calling rock is pretty easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will look for usefiles in your current directory and, if possible, build them.&lt;/p&gt;

&lt;p&gt;Since the world is not always perfect, it&amp;rsquo;s also possible to pass an &lt;code&gt;.ooc&lt;/code&gt; file directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock mmorpg.ooc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sadly, it&amp;rsquo;s possible that rock thinks your ooc code is alright and passes the C files to your
C compiler which then prints pages of errors and explodes subsequently.
In that case, you&amp;rsquo;ll need to increase rock&amp;rsquo;s verbosity to see the compiler output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -v ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Building an executable and tired of typing &lt;code&gt;./mmorpg&lt;/code&gt; all over again?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -r ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will run your executable after having built it successfully.&lt;/p&gt;

&lt;p&gt;To speed up the compilation process and to save you some time, rock caches compiled dependencies
in a hidden subdirectory called &lt;code&gt;.libs&lt;/code&gt;. In most cases, this is awesome, but sometimes, something
goes wrong and you get pretty strange unexplainable error messages. Just to be sure, you can just&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then, recompile and see if it works.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>text</title>
      <link>http://oocmanual.cogneco.com/sdk/text</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/text</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The text package&lt;/h1&gt;

&lt;p&gt;This package contains various helper classes to work with text
and JSON.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Escape sequences&lt;/h1&gt;

&lt;p&gt;The module &lt;code&gt;text/EscapeSequence&lt;/code&gt; contains a class &lt;code&gt;EscapeSequence&lt;/code&gt; which defines
some methods to work with backslash escape sequences. In the real world, you probably
just need the two following methods:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;escape&lt;/code&gt; takes a string and converts all special characters to escape sequences.
In this context, special characters are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;non-printable characters&lt;/li&gt;
&lt;li&gt;single and double quotes&lt;/li&gt;
&lt;li&gt;backslashes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
escaped := EscapeSequence escape(&amp;quot;This is\na &#39;String&#39;&amp;quot;)
// now, `escaped` looks like this:
escaped == &amp;quot;This is \\n a \\&#39;String\\&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that is only one half of the truth: You can additionally pass a
string of all characters that should not be escaped as the
second argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
escaped := EscapeSequence escape(&amp;quot;This is\na &#39;String&#39;&amp;quot;, &amp;quot;&#39;\n&amp;quot;)
// The method did not escape anything now.
escaped == &amp;quot;This is\na &#39;String&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;unescape&lt;/code&gt; is useful if you have a string containing escape sequences
and you need a string with these sequences converted to their real character
counterparts. This method supports one-character escape sequences like
&amp;ldquo;\n&amp;rdquo;, &amp;ldquo;\r&amp;rdquo; or &amp;ldquo;\t&amp;rdquo;, but also hexadecimal sequences like &amp;ldquo;\x34&amp;rdquo;.
Usage is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;\\x27\\163up\\t\\x62ro\\n\\x3f&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which will print&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
&#39;sup    bro
?
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;StringTokenizer&lt;/h1&gt;

&lt;p&gt;Sometimes, one needs to split a string at a special character and turn
it into an array. In ooc, the &lt;code&gt;text/StringTokenizer&lt;/code&gt; module adds
every desirable variation of the good old &lt;code&gt;split&lt;/code&gt; method to &lt;code&gt;Buffer&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;,
each returning an &lt;code&gt;ArrayList&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/StringTokenizer
import structs/ArrayList

// split at a specific character
&amp;quot;A|simple and stupid|example&amp;quot; split(&#39;|&#39;)
// This creates an ArrayList:
//  [&amp;quot;A&amp;quot;, &amp;quot;simple and stupid&amp;quot;, &amp;quot;example&amp;quot;]

// split until a specific number of tokens is reached.
// This will produce an ArrayList like
//    [&amp;quot;A&amp;quot;, &amp;quot;simple and stupid|example&amp;quot;]
&amp;quot;A|simple and stupid|example&amp;quot; split(&#39;|&#39;, 2)

// There is also a function to split at delimiters longer
// than one char:
&amp;quot;:-)A case :-)of intimidating:-)smiley abuse :-)&amp;quot; split(&amp;quot;:-&amp;quot;)
// ... produces
//  [&amp;quot;&amp;quot;, &amp;quot;A case &amp;quot;, &amp;quot;of intimidating&amp;quot;, &amp;quot;smiley abuse &amp;quot;, &amp;quot;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;StringTemplate&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;io/StringTemplate&lt;/code&gt; module adds a lightweight &lt;code&gt;formatTemplate&lt;/code&gt; string interpolation
function to strings, which can be used in cases where &lt;code&gt;format&lt;/code&gt; is not enough. This function
uses a hashmap to access items by value:&lt;/p&gt;

&lt;p&gt;{{=&amp;lt;% %&amp;gt;=}}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/StringTemplate
import structs/HashMap

values := HashMap&amp;lt;String, String&amp;gt; new()
values put(&amp;quot;day&amp;quot;, &amp;quot;Saturday&amp;quot;) \
      .put(&amp;quot;weather&amp;quot;, &amp;quot;cloudy&amp;quot;)

&amp;quot;Hi! Today&#39;s {{day}}, and it is a pretty {{  weather   }} {{ day }}!&amp;quot; formatTemplate(values) println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lt;%={{ }}=%&amp;gt;&lt;/p&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi! Today&#39;s Saturday, and it is a pretty cloudy Saturday!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, you can access the values by their keys, order isn&amp;rsquo;t important
and you can interpolate one value multiple times.&lt;br /&gt;
However, this is still pretty basic, since it does not support filters or control
structures, but this is often enough.&lt;/p&gt;

&lt;p&gt;In case a key is referenced that does not exist in the hashmap, it will be
replaced by an empty string.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Shell-like Lexer&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;text/Shlex&lt;/code&gt; module implements a basic lexer for strings containing
quoted strings and backslash escape sequences. Basically, it splits an input
string into an Array, using whitespace characters as delimiters. Single and double
quotes can be used to include whitespace in the string items.&lt;/p&gt;

&lt;p&gt;The public API can be accessed like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/Shlex
import structs/ArrayList
Shlex split(&amp;quot;&#39;This is a \\&#39;quoted\\&#39; string&#39;     and I \&amp;quot;like \\x69\\x74.\&amp;quot;&amp;quot;)
// This produces the following ArrayList:
// [&amp;quot;This is a &#39;quoted&#39; string&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;like it.&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can be useful to parse command-line arguments. However, be careful, since
this module was not designed with security in mind.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Regular Expressions&lt;/h1&gt;

&lt;p&gt;The SDK provides a simple cover for the &lt;a href=&#34;http://www.pcre.org/&#34;&gt;Perl Compatible Regular Expressions&lt;/a&gt;
library. Its use is pretty straightforward. First, you need to compile a regular
expression pattern, passing some options as a bitmask if you want to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/Regexp

pattern := Regexp compile(&amp;quot;on (?P&amp;lt;year&amp;gt;[0-9]{4})-?P&amp;lt;month&amp;gt;[0-9]{1,2})-(?P&amp;lt;day&amp;gt;[0-9]{1,2})&amp;quot;, RegexOptions CASELESS)
pattern matches(&amp;quot;foo&amp;quot;) // this will return null, since the pattern could not be matched

someDate := pattern matches(&amp;quot;On 2013-08-07&amp;quot;)
// `someDate` is now a `Match` object. You can access groups by index or by name:
someDate group(1)
someDate group(&amp;quot;year&amp;quot;)
// ... both return &amp;quot;2013&amp;quot;.
// Group zero is the whole matched string:
someDate group(0) // is &amp;quot;On 2013-08-07&amp;quot;

// You can also iterate over the matches. This will include
// group 0 (the whole string), though.
for(group in someDate) {
    // `group` is now a String.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information about the Perl regular expression syntax, take a look
at the &lt;a href=&#34;http://perldoc.perl.org/perlre.html&#34;&gt;Perl documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;JSON&lt;/h1&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Basic reading and writing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;text/json/&lt;/code&gt; package contains a JSON parser and generator, written in ooc
without external dependencies, which is able to deal with basic JSON. However,
if you care about speed or compliance (especially when dealing with numbers),
you should check out &lt;a href=&#34;https://github.com/nddrylliog/ooc-yaml&#34;&gt;ooc-yaml&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The JSON classes operate on nested &lt;a href=&#34;/docs/sdk/structs/#bag-variants&#34;&gt;HashBags and Bags&lt;/a&gt;,
so if you parse JSON, you get some (Hash)Bags, and if you want to generate JSON, you need
to pass the data as (Hash)Bags.&lt;/p&gt;

&lt;p&gt;To parse or generate JSON, you can just use the convenience &lt;code&gt;text/json&lt;/code&gt; module.
Every function exists in two flavours: Normally, you need to pass the class
of your expected base value. So, for example, if you want to parse JSON like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!json
[&amp;quot;Hi&amp;quot;, &amp;quot;World&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to pass &lt;code&gt;Bag&lt;/code&gt; as the base value class. However, since most of the time
you will parse JSON objects that will represented by a &lt;code&gt;HashBag&lt;/code&gt;, &lt;code&gt;HashBag&lt;/code&gt; is
used by default if you do not pass a class explicitly.&lt;/p&gt;

&lt;p&gt;Here are some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/json
import structs/HashBag

// if you have a `Reader` (to read directly from a file, for example):
import io/FileReader
myObject := JSON parse(FileReader new(&amp;quot;package.json&amp;quot;))

// ... and if your base value is not a JSON object:
import structs/Bag
myArray := JSON parse(FileReader new(&amp;quot;myarray.json&amp;quot;), Bag)

// reading directly from strings is also supported:
JSON parse(&amp;quot;{\&amp;quot;hello\&amp;quot;: \&amp;quot;world\&amp;quot;}&amp;quot;)
JSON parse(&amp;quot;\&amp;quot;just a string\&amp;quot;&amp;quot;, String)

// and to generate JSON, there is:
myBag := HashBag new()
myBag put(&amp;quot;integer&amp;quot;, 1234) \
     .put(&amp;quot;string&amp;quot;, &amp;quot;Yes&amp;quot;)

import io/FileWriter
JSON generate(FileWriter new(&amp;quot;output.json&amp;quot;), myBag)

myJSONString := JSON generateString(myBag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When dealing with the &lt;code&gt;HashBag&lt;/code&gt; class, you should take a look at its
&lt;a href=&#34;/docs/sdk/structs/#hashbag&#34;&gt;getPath&lt;/a&gt; function, which will save you
a lot of typing.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;A JSON generation DSL&lt;/h2&gt;

&lt;p&gt;If you find yourself generating a lot of JSON, you might find
the &lt;code&gt;HashBag&lt;/code&gt;/&lt;code&gt;Bag&lt;/code&gt; objects create a lot of syntactic noise. For this
reason, the SDK contains another convenience module implementing
a small DSL for JSON generation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// Let&#39;s import the module into a namespace, since `make`
// is a bit ambiguous.
import text/json/DSL into JSON

data := JSON make(|j|
    j object(
        &amp;quot;some-key&amp;quot;,
            &amp;quot;some-value&amp;quot;,
        &amp;quot;here comes a list&amp;quot;,
            j array(
                1, 2, &amp;quot;three&amp;quot;, 4
            ),
        &amp;quot;and a nested object&amp;quot;,
            j object(
                &amp;quot;true&amp;quot;, true
            )
    )
)
data println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt; creates a helper object with &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;array&lt;/code&gt; functions and passes
it to the function you provide; using a closure is the most convenient way here.
You can use &lt;code&gt;object&lt;/code&gt; to create JSON objects, passing as many key-value pairs
as you want, and &lt;code&gt;array&lt;/code&gt; for JSON arrays.&lt;/p&gt;

&lt;p&gt;When it&amp;rsquo;s done, it returns the JSON data as a string.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Control Structures</title>
      <link>http://oocmanual.cogneco.com/language/control-structures</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/control-structures</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Conditionals&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;if / else&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s your traditional if, else if, else structure. The body should be either
a single statement, or a scope.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
if (off) turnOn()

if (stressed) {
    breatheIn()
    breatheOut()
} else if (tired) {
    rest()
} else {
    allGood()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The condition can be of type &lt;code&gt;Bool&lt;/code&gt; or a Pointer, in which case it will evaluate to
&lt;code&gt;true&lt;/code&gt; if it is non-null.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;match / case&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; is ooc&amp;rsquo;s &lt;code&gt;switch&lt;/code&gt;, loosely modelled after Scala&amp;rsquo;s. In its simplest form, it tests for equality between an expression and several values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match (numFeets) {
    case 1 =&amp;gt; &amp;quot;Ouch&amp;quot;
    case 2 =&amp;gt; &amp;quot;Normal&amp;quot;
    case =&amp;gt;
        // what?
        raise(&amp;quot;Too many feet&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each case is a scope of its own - it doesn&amp;rsquo;t require braces. A case with no
expression is a catch-all.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; also works with any class T that implements the method &lt;code&gt;matches?: func
-&amp;gt; (other: T) -&amp;gt; Bool&lt;/code&gt;. Another way to get complex types to work in matches
is simply to override the &lt;code&gt;==&lt;/code&gt; operator. Hence, Strings work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match keyword {
    case &amp;quot;if&amp;quot; =&amp;gt;
        Keyword IF
    case &amp;quot;match&amp;quot; =&amp;gt;
        Keyword MATCH
    case =&amp;gt;
        Keyword UNKNOWN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; is also a good way to avoid explicit casting, by matching an object
against variable declarations, one can use its specific form directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
result := match (op) {
    case plus: Plus =&amp;gt;
        plus lhs + plus rhs
    case minus: Minus =&amp;gt;
        minus lhs - minus rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;match&lt;/code&gt; is an expression, if every case ends with an expression. Hence, a
match can be used as a return value, or in a function call, on the right hand
side of a declaration-assignment (&lt;code&gt;:=&lt;/code&gt;), as demonstrated above.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Loops&lt;/h1&gt;

&lt;p&gt;Loops are structures that control the repetition of a body of code.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;break / continue&lt;/h2&gt;

&lt;p&gt;Two particular keywords are of interest when writing loops:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; immediately exits the loop, skipping the rest of the body
and not executing any further iteration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; skips over the rest of the body and begins the next
iteration immediately&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;while&lt;/h2&gt;

&lt;p&gt;Checks the condition - if false, skips the body. If true, runs the body,
then checks the condition again, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (!satisfied) {
    buyStuff()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;for&lt;/h2&gt;

&lt;p&gt;There is no C-like &lt;code&gt;for&lt;/code&gt; in ooc, only a foreach. It can iterate through
values like ranges:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (i in 1..10) {
    &amp;quot;Counting to %d&amp;quot; printfln(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or more complex data structures:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (element in list) {
    &amp;quot;Element = %s&amp;quot; printfln(element toString())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an object to be iterable, it has to implement the
&lt;code&gt;iterator: func &amp;lt;T&amp;gt; -&amp;gt; Iterator&amp;lt;T&amp;gt;&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;A variant of foreach allows one to get the index of the current element:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for ((index, element) in list) {
    &amp;quot;list[%d] = %s&amp;quot; printfln(index, element toString())
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rock</title>
      <link>http://oocmanual.cogneco.com/tools/rock</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;About Rock&lt;/h1&gt;

&lt;p&gt;Rock is the main ooc compiler. It parses ooc files using nagaqueen, does some
checking and inference, produces .c files, and then drives the C compilation process
to produce either an executable or a library.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/basic/&#34;&gt;Basic usage&lt;/a&gt; section explains how to quickly get
up and running, using rock to compile ooc projects.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/drivers/&#34;&gt;Drivers&lt;/a&gt; section gives an overview of rock&amp;rsquo;s various
drivers, akin to compiling strategies, like the sequence driver (default), the make
driver, and the android driver.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/advanced/&#34;&gt;Advanced usage&lt;/a&gt; section covers some less-often used
options like using a different C compiler, keeping source files, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/usefiles/&#34;&gt;Usefiles&lt;/a&gt; section describes the format of &lt;code&gt;.use&lt;/code&gt; files,
which define the characteristics of an ooc app or library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/gc/&#34;&gt;Garbage Collection&lt;/a&gt; section talks about the Garbage Collection
strategy in rock, how to make sure things work well on different plaforms, how the
Boehm GC is bundled, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/debug/&#34;&gt;Debugging&lt;/a&gt; section talks about what to do when a program
doesn&amp;rsquo;t behave correctly. Debug symbols, stack traces, debugging on particularly painful
platforms like Windows.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/rock/packaging/&#34;&gt;Packaging&lt;/a&gt; section talks about releasing standalone
applications coded in ooc, such as games — when you don&amp;rsquo;t want to have users install
dependencies on their own, but would rather bundle everything together.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>http://oocmanual.cogneco.com/language/exceptions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/exceptions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Error handling&lt;/h1&gt;

&lt;p&gt;The C way to do error handling is usually via return codes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
openFile: (path: String) -&amp;gt; Int {
  if (error) {
    return -1
  }
  return someFileDescriptor
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, it relies on the user correctly checking the return value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
fd := openFile(&amp;quot;/etc/hosts&amp;quot;)
doSomethingWithFile(fd) // forgot to check, things might go bad!
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Exceptions&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;raise&lt;/h2&gt;

&lt;p&gt;Another way to handle that would be with exceptions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
openFile: (path: String) -&amp;gt; File {
  if (error) {
    raise(&amp;quot;Could not open %s&amp;quot; format(path))
  }
  return someFile
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That way, even if the user doesn&amp;rsquo;t explicitly check for the error, it&amp;rsquo;ll
still interrupt the flow of the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file := openFile(&amp;quot;/dev/does/not/exist&amp;quot;)
doSomethingWithFile(file) // we are never even going to reach there
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Throwing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;raise&lt;/code&gt; function above is a quick method to raise an exception. What
it really does is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Exception new(message) throw()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no special keyword to throw exceptions, it&amp;rsquo;s just a method on the
&lt;code&gt;Exception&lt;/code&gt; class.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Catching exceptions&lt;/h2&gt;

&lt;p&gt;Catching exceptions is done through the &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  openFile(&amp;quot;dev/does/not/exist&amp;quot;)
} catch (e: Exception) {
  // something wrong happened
  &amp;quot;Error: %s&amp;quot; printfln(e message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Exception sub-classes&lt;/h2&gt;

&lt;p&gt;It is possible to sub-class exceptions to have several exception types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FileNotFoundException: class extends Exception {
  init: func (path: String) {
    super(&amp;quot;File not found: %s&amp;quot; format(path))
  }
}

openFile: func (path: String) {
  if (error) {
    FileNotFoundException new(path) throw()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which makes it easy to catch a specific type of exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  file := openFile(&amp;quot;/dev/does/not/exist&amp;quot;)
  doSomethingWithFile(file)
} catch (e1: FileNotFoundException) {
  // The file wasn&#39;t found
} catch (e2: Exception) {
  // Something else went wrong.
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lang</title>
      <link>http://oocmanual.cogneco.com/sdk/lang</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The lang package&lt;/h1&gt;

&lt;p&gt;The lang package is considered built-in: it is imported by default in ooc
modules. There is a reason for that, however - the SDK is distributed as
an ooc library itself, and as such, it has a .use file that specifies which
modules should be imported.&lt;/p&gt;

&lt;p&gt;Some of the lang package is essential, like &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Class&lt;/code&gt;, which
means that the compiler, &lt;a href=&#34;../tools/rock/&#34;&gt;rock&lt;/a&gt;, will expect them to be present,
have certain names, fields and methods. However, using a custom sdk is
possible, where the implementation for these can be swapped to something
lighter, for example.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;types&#34;&gt;Types&lt;/a&gt; section describes how Object,
 Class, and other types such as Void, Pointer, Bool, None,
 Cell are defined. It also discusses variable arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;string&#34;&gt;String&lt;/a&gt; section talks about string
 handling, the mutable variant Buffer, and formatting&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;numbers&#34;&gt;Numbers&lt;/a&gt; section talks about number
 types, either integers or floats, and the various functions available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;iterators&#34;&gt;Iterators&lt;/a&gt; section discusses
 how iterators are implemented, and what goes on behind a foreach.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;exceptions&#34;&gt;Exceptions&lt;/a&gt; section talks about
 default properties of exceptions, and how to extend them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;memory&#34;&gt;Memory&lt;/a&gt; section talks about memory
 management, mostly just how to deal with blocks of memory rather
 than more high-level data structures.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Version</title>
      <link>http://oocmanual.cogneco.com/language/version-blocks</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/version-blocks</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Version blocks&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Syntax&lt;/h2&gt;

&lt;p&gt;Version blocks use the following syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    version (&amp;lt;version expression&amp;gt;) {
        &amp;lt;body&amp;gt;
    } else {
        &amp;lt;alternative body&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;version expression&gt; can be any of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;version name&amp;gt;
    !&amp;lt;version expression&amp;gt;
    &amp;lt;version expression&amp;gt; &amp;amp;&amp;amp; &amp;lt;version expression&amp;gt;
    &amp;lt;version expression&amp;gt; || &amp;lt;version expression&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Semantics&lt;/h2&gt;

&lt;p&gt;Version blocks aren&amp;rsquo;t if-else blocks - they aren&amp;rsquo;t evaluated at runtime.
In rock, version blocks aren&amp;rsquo;t evaluated at ooc-compile-time either.
They&amp;rsquo;re evaluated at C compile time. Which means the C code generated by rock
should be the same on any platform.&lt;/p&gt;

&lt;p&gt;Practically, in rock, version blocks are an abstraction for #ifdef / #endif blocks.
The syntax makes it harder to forget to close a version block than an #ifdef / #endif block,
and a few handy aliases (listed below) for commonly used version names are standard, so that developers
don&amp;rsquo;t have to remember the convoluted corresponding C defines.&lt;/p&gt;

&lt;p&gt;For other compilers not based on the C language, version block handling may happen at any
stage of the compilation (if any), as long as the version expressions are correctly evaluated
and have the correct meaning (for example, a &amp;lsquo;windows&amp;rsquo; version block should be ignored on OSX)&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Built-in version names&lt;/h2&gt;

&lt;p&gt;C defines are included here for completeness, but are only relevant for people who want
to implement ooc on top of C.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;corresponding C define&lt;/td&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;windows&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;WIN32&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;linux&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;linux&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;solaris&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;__sun&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;unix&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;unix&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;beos&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;BEOS&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;haiku&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;HAIKU&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;apple&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;APPLE&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;gnuc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;GNUC&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;i386&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;i386&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;x86&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;X86&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;x86_64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;x86_64&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ppc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;ppc&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ppc64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;ppc64&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;x86_64&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;gc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;OOC_USE_GC&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Custom version names&lt;/h2&gt;

&lt;p&gt;Most of the standard version names above depend on your building environment, and the &amp;lsquo;gc&amp;rsquo; name depends
on the compiler setting -gc=[off,static,dynamic].&lt;/p&gt;

&lt;p&gt;Custom version names can be used, and turned on/off with the -D and -U compiler flags, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    version(debug) {
        &amp;quot;[%d] Saving database %s&amp;quot; println(timestamp(), db name)
    }
    db save()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code inside the version(debug) block will be compiled if -Ddebug is used. It is common practise for ooc developers
to use the -Ddebug switch to debug their applications.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Semantics continued&lt;/h2&gt;

&lt;p&gt;Version blocks can be used in function bodies, to make certain parts of the code OS-specific, or
they can be used at the mdule-level to make functions or types OS-specific.&lt;/p&gt;

&lt;p&gt;If different types are defined in different version blocks, make sure they expose the same interface.
It&amp;rsquo;s not necessary for them to have the exact same class layout, but they should at least have all the
methods/fields that are used in every OS.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Examples&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    version(windows) {
        &amp;quot;Hi, Bill!&amp;quot; println()
    }
    version(apple) {
        &amp;quot;Hi, Steve!&amp;quot; println()
    }
    version(linux) {
        &amp;quot;Hi, Linus!&amp;quot; println()
    }
    version(!windows &amp;amp;&amp;amp; !apple &amp;amp;&amp;amp; !linux) {
        &amp;quot;Who are you, and what did you do to my OS?&amp;quot;
    }

    version(apple) {
        &amp;quot;Nice Hardware!&amp;quot; println()
    } else {
        &amp;quot;So you like your computer made of plastic then!&amp;quot; println()
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See also io/File and os/Time in the SDK for real-world examples of heavily versioned code.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Pattern for OS-specific classes&lt;/h2&gt;

&lt;p&gt;In ooc, &amp;lsquo;new&amp;rsquo; isn&amp;rsquo;t a keyword but a static method. As a result, you can define new yourself.
This allows an interesting pattern for OS-specific classes in ooc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // io/File
    import io/[FileUnix, FileWin32]
    
    File: class {
        path: String
    
        new: static func (.path) -&amp;gt; This {
            version(windows) { return FileWin32 new(path) }
            version(unix)    { return FileUnix  new(path) }
            Exception new(This, &amp;quot;Unsupported platform&amp;quot;) throw()
        }
        
        // abstract methods
    }

    // io/FileUnix
    FileUnix: class extends File {
        init: func (=path) {}
        
        // implement abstract methods for unix
    }
    
    // io/FileWin32
    FileWin32: class extends File {
        init: func (=path) {}
        
        // implement abstract methods for Win32
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>