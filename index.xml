<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Glossary</title>
      <link>http://oocmanual.cogneco.com/glossary</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/glossary</guid>
      <description>&lt;p&gt;{{GLOSSARY}}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Manual</title>
      <link>http://oocmanual.cogneco.com/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;How to use the documentation&lt;/h1&gt;

&lt;p&gt;The documentation for ooc is structured as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tutorial/&#34;&gt;Tutorial&lt;/a&gt; is a ten minute journey meant for
newcomers to the language. By building a small program, you will learn the
basics of the syntax and even use bits of the SDK.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/lang/&#34;&gt;Language&lt;/a&gt; section explains in detail every feature
of the language: it goes through the syntax and a the main use cases for
every feature. It also contains a full grammar, and a collection of best
practices.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/sdk/&#34;&gt;SDK&lt;/a&gt; section gives an overview of the modules included
with the default ooc distribution. Whether you need access to files, to
measure time, to do some networking, or simply use common data structures,
the SDK is packed with goodness.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/&#34;&gt;Tools&lt;/a&gt; section lists useful tools for ooc development,
along with a typical workflow from the creation, compilation, testing, and
documentation of a project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/kaputt/&#34;&gt;Troubleshooting&lt;/a&gt; section gives advice on how
to address frequently encountered problems.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/glossary/&#34;&gt;Glossary&lt;/a&gt; is a collection of terms you may stumble
upon while using ooc or reading its documentation. If you don&amp;rsquo;t understand
a term, go here!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When you’re stuck with a question or a problem the documentation doesn’t
solve, considering posting to the &lt;a href=&#34;https://groups.google.com/group/ooc-lang&#34;&gt;discussion group&lt;/a&gt; or joining the
&lt;a href=&#34;irc://chat.freenode.net/#ooc-lang&#34;&gt;ooc-lang IRC channel&lt;/a&gt;. We’ll get it sorted out in no time. Check out the
&lt;a href=&#34;/community/&#34;&gt;Community&lt;/a&gt; page for details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>channel</title>
      <link>http://oocmanual.cogneco.com/sdk/os/channel</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/channel</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Channel module&lt;/h1&gt;

&lt;p&gt;Channels are another way to think about data flow in the program.
Perhaps most famous in their Go implementation, &amp;lsquo;goroutines&amp;rsquo;, can
communicate via channels.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;os/Channel&lt;/code&gt; module contains a trivial implementation of channels
which may be used like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By importing this module, a scheduler is set to run before the program
exits. Let&amp;rsquo;s start by making a channel by which Ints can travel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
chan := make(Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then let&amp;rsquo;s make a data producer coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 0..5) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And another one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 5..10) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
    chan &amp;lt;&amp;lt; -1
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-1 will be used as a stopping signal here. &lt;code&gt;go&lt;/code&gt; create a new
coroutine, and &lt;code&gt;chan &amp;lt;&amp;lt; value&lt;/code&gt; sends a value down a channel.
&lt;code&gt;yield&lt;/code&gt; switches from the current coroutine back to the scheduler.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now make a consumer channel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    while (true) match (i := !chan) {
        case -1 =&amp;gt; break
        case =&amp;gt; &amp;quot;%d&amp;quot; printfln(i)
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re reading from the channel with the not operator: &lt;code&gt;!chan&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will print 0, 5, 1, 6, 2, 7, 3, 8, 4, 9, and then exit, as
expected.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>os</title>
      <link>http://oocmanual.cogneco.com/sdk/os</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os package&lt;/h1&gt;

&lt;p&gt;The os packages contains various modules pertaining to Operating System functionality such as:&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Concurrency&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;process&#34;&gt;Process&lt;/a&gt;, to launch child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;jobpool&#34;&gt;JobPool&lt;/a&gt;, to easily control a pool of child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[Coro](coro, which provides a basic coroutine implementation&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;I/O&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;terminal&#34;&gt;Terminal&lt;/a&gt;, used to control terminal text output (color, etc.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;pipe&#34;&gt;Pipe&lt;/a&gt;, to open, read from, and write to pipes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;dynlib&#34;&gt;Dynlib&lt;/a&gt;, which deals with dynamic library loading&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;mmap&#34;&gt;mmap&lt;/a&gt;, which exposes memory mapping capabilities&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;channel&#34;&gt;Channel&lt;/a&gt;, which implements channels&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;System&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;system&#34;&gt;System&lt;/a&gt;, to get information such as the number of processors,
the hostname, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;env&#34;&gt;Env&lt;/a&gt;, to deal with environment variables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;shellutils&#34;&gt;ShellUtils&lt;/a&gt;, used mostly to find executables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;time&#34;&gt;Time&lt;/a&gt;, to get the current time and date, and sleep&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Covers vs Classes</title>
      <link>http://oocmanual.cogneco.com/language/covers-vs-classes</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/covers-vs-classes</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;When to use covers and classes&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Whenever possible, use classes.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re new to ooc, don&amp;rsquo;t use covers because you&amp;rsquo;ve heard they
are &amp;ldquo;faster&amp;rdquo;. Covers are powerful. Great power comes with great responsibility.
The sword cut both ways&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;By-reference, by-value&lt;/h2&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Classes&lt;/h2&gt;

&lt;p&gt;Classes are by-references. Which means every object is a reference. Doing that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: class {
        value: Int
        init: func (=value) {}
    }

    modifyRef: func (n: Number) {
        n = Number new(-1)
    }

    modifyInside: func (n: Number) {
        n value = -1
    }

    answer := Number new(42)
    modifyRef(answer) // does nothing
    modifyInside(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens in &amp;lsquo;modifyRef&amp;rsquo; is that we change the value of the parameter &amp;lsquo;n&amp;rsquo;.
The code does not modify what &amp;lsquo;n&amp;rsquo; was a reference to in the first place.
In the example above the variable &amp;lsquo;answer&amp;rsquo; is given as the argument and &amp;lsquo;modifyRef&amp;rsquo; has
no effect at all on &amp;lsquo;answer&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;However, in &amp;lsquo;modifyInside&amp;rsquo;, we actually modify the content of what &amp;lsquo;n&amp;rsquo; refers to.
Since &amp;lsquo;n&amp;rsquo; refers to &amp;lsquo;answer&amp;rsquo;, the code will modify its member &amp;lsquo;value&amp;rsquo; and set it to -1.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Covers&lt;/h2&gt;

&lt;p&gt;Covers are trickier. There are two types of covers: primitive covers and compound covers&lt;/p&gt;

&lt;p&gt;Primitive covers allow to us to add methods to an existing underlying type. For implementations
of ooc on top of C this means you can do stuff like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Int: cover from int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is actually the way all C types are used within ooc.&lt;/p&gt;

&lt;p&gt;As a consequence, covers are by-value. Which means that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    modify: func (i: Int) {
        i = -1
    }

    answer := 42
    modify(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doesn&amp;rsquo;t modify answer.&lt;/p&gt;

&lt;p&gt;But compound covers (you can think of them as structs) are also by value,
which means that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
    }

    modifyInside: func (n: Number) {
        n value = -1
    }

    answer: Number
    answer value = 42

    modifyInside(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Won&amp;rsquo;t modify &amp;lsquo;answer&amp;rsquo; at all, but a &lt;em&gt;copy&lt;/em&gt; of it that has been
passed to &amp;lsquo;modifyInside&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;As an interesting side effect, a &amp;lsquo;clone&amp;rsquo; method is futile for covers.&lt;/p&gt;

&lt;p&gt;It also means that this won&amp;rsquo;t work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
        init: func (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because init will be working on a &lt;em&gt;copy&lt;/em&gt; of the object, thus leaving
the original object unmodified. That&amp;rsquo;s why func@ exists, ie.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
        init: func@ (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &amp;lsquo;this&amp;rsquo; will be passed by reference. Same goes for any cover method
that modifies its content.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Heap allocation, stack allocation&lt;/h2&gt;

&lt;p&gt;When you do&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NumberClass: class {}
    n := NumberClass new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n may be allocated on the heap or on the stack, however the compiler sees fit.&lt;/p&gt;

&lt;p&gt;However, with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NumberCover: cover {}
    n: NumberCover
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n is allocated on the stack.&lt;/p&gt;

&lt;p&gt;Choosing whether to allocate an object on the stack or on the heap is a
non-trivial decision. In C++ for example, it is the role of the programmer
to decide whether to allocate on the stack or on the heap.&lt;/p&gt;

&lt;p&gt;In ooc, it&amp;rsquo;s the role of the compiler. Until the language is properly
standardized and annotations are added for extern functions to allow
escape analysis, the compiler may choose to only allocate on the heap.&lt;/p&gt;

&lt;p&gt;Allocating on the stack is much faster (since it only involves moving
the stack pointer), and the stack is always hot, the memory you get when
allocating is much more likely to be in cache than any far heap allocated
memory.&lt;/p&gt;

&lt;p&gt;So why don&amp;rsquo;t we always allocate on the stack? Why do we even bother about
heap allocation, which involves all kinds of housekeeping to know which
memory blocks are reserved and which are free?&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Why stack allocation isn&amp;rsquo;t a silver bullet&lt;/h2&gt;

&lt;p&gt;A typical stack size for C programs on desktop OSes is between 1MB and 2MB.
Therefore, if you need to allocate big objects, you may run out of stack space.&lt;/p&gt;

&lt;p&gt;Running out of stack space is really something to be avoided. It&amp;rsquo;s a lot
harder to debug than heap allocation failures. When heap allocation fails,
you usually get back a null pointer, and tools (GDB, Valgrind) help figuring
out the cause.&lt;/p&gt;

&lt;p&gt;However, when you run out of stack space, the program usually crashes violently
with very little information about the situation that lead to the crash.
Even worse, it could corrupt data without crashing.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s more, often, when a program crashes because of a stack allocation failure,
the call stack is overwritten with random data, making it impossible to trace back
the origin of the problem.&lt;/p&gt;

&lt;p&gt;To add insult to injury, as far as I know, there is no reliable and portable way
to know how much free memory is left on the stack.&lt;/p&gt;

&lt;p&gt;For all those reasons, stack allocation is sometimes entirely avoided,
because it&amp;rsquo;s tricky to deal with manually.&lt;/p&gt;

&lt;p&gt;The following IBM DeveloperWorks article goes more in-depth into the issue:
&lt;a href=&#34;http://www.ibm.com/developerworks/java/library/j-jtp09275.html&#34;&gt;http://www.ibm.com/developerworks/java/library/j-jtp09275.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Stack and scope&lt;/h2&gt;

&lt;p&gt;But wait, there&amp;rsquo;s more! (assuming you&amp;rsquo;re still reading at that point)&lt;/p&gt;

&lt;p&gt;Stack-allocated variables are deallocated when they go out of scope.&lt;/p&gt;

&lt;p&gt;What does that mean? It means that this code is wrong.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    getAnswer: func -&amp;gt; Int* {
        // answer is allocated on the stack
        answer := 42
        // we&#39;re returning the address of a local variable
        // this is WRONG, don&#39;t do it.
        answer&amp;amp;
        // when the function returns, &#39;answer&#39; goes out of scope
        // and is deallocated
    }

    answerPtr := getAnswer()
    &amp;quot;answer = %d&amp;quot; printfln(answerPtr@)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas this one will work perfectly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    getAnswer: func -&amp;gt; Int* {
        // answer is allocated on the heap
        answer := gc_malloc(Int size)
        answer@ = 42
        // we&#39;re returning the address of a heap-allocated variable
        // no problem with that. the memory will be freed on a garbage
        // collector sweep phase, when it will have detected that
        // it&#39;s unused
        answer
    }

    answerPtr := getAnswer()
    &amp;quot;answer = %d&amp;quot; printfln(answerPtr@)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the first version (returning the address of a local variable)
might work sometimes: don&amp;rsquo;t be surprised. If the memory address (on the stack
or in a register) where the local variable was stored isn&amp;rsquo;t overwritten
between the return from the function and the time when it&amp;rsquo;s used, it might
still contain the original value. But, again - it&amp;rsquo;s wrong and unreliable.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;When to use stack allocation&lt;/h2&gt;

&lt;p&gt;For small objects for which you need by-value behavior and of which you use
gazillions in your application.&lt;/p&gt;

&lt;p&gt;Each project is a unique situation - as a rule, I&amp;rsquo;d always advise to begin
with a class, and turn it into a cover later if the situation requires it.&lt;/p&gt;

&lt;p&gt;However, keep in mind that allocation is often not the first place to look
if you want to optimize your application. Remember to always use a profiler
(I find that valgrind + KCachegrind work particularly well with ooc code)
to figure out where the hotspots are in your code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>process</title>
      <link>http://oocmanual.cogneco.com/sdk/os/process</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/process</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Process module&lt;/h1&gt;

&lt;p&gt;The Process module deals with everything related to launching a child process, waiting for
its status or signals, and communicating with it.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;A process can be launched by providing an array or a list of arguments to the &lt;code&gt;Process&lt;/code&gt; constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Process

p := Process new([&amp;quot;cat&amp;quot;, &amp;quot;/etc/hosts&amp;quot;])
exitCode := p execute()

// at this point, the process has ended
// and &#39;exitCode&#39; contains the value returned by the program
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of running execute, one might want to run &lt;code&gt;getOutput&lt;/code&gt; directly, to get
the standard output of the process as a string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;cat&amp;quot;, &amp;quot;/etc/hosts&amp;quot;])
out := p getOutput()
// out now contains the contents of the /etc/hosts file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or getErrOutput to get the standard error output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;cat&amp;quot;, &amp;quot;/etc/hosts&amp;quot;])
err := p getErrOutput()
// err is empty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve the result of both stderr and stdout, see the &amp;lsquo;Redirecting&amp;rsquo; section
below.&lt;/p&gt;

&lt;p&gt;However, depending on your use case, that might not be the best way to do it.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Manual wait and pid&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;execute&lt;/code&gt; will start the child process, wait for it to finish, and print the output.&lt;/p&gt;

&lt;p&gt;However, we can do things manually if we want:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;curl&amp;quot;, &amp;quot;example.org&amp;quot;])
p executeNoWait()
p wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wait&lt;/code&gt; method will wait until the child process has exited or errored. If you
just want to check if a process is still running, &lt;code&gt;waitNoHang&lt;/code&gt; can be used instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;curl&amp;quot;, &amp;quot;example.org&amp;quot;])
p executeNoWait()
while (p waitNoHang() == -1) {
    Time sleepMilli(20)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To execute a bunch of processes in parallel, using a &lt;a href=&#34;/docs/sdk/os/jobpool&#34;&gt;JobPool&lt;/a&gt; is easier and
more suitable.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Process settings&lt;/h1&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Current working directory&lt;/h2&gt;

&lt;p&gt;By default, a process will inherit from the current working directory. To make
the child process run in a specified directory, use the &lt;code&gt;setCwd&lt;/code&gt; method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;cat&amp;quot;, &amp;quot;hosts&amp;quot;])
p setCwd(&amp;quot;/etc&amp;quot;)
p execute()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Environment&lt;/h2&gt;

&lt;p&gt;To specify custom environment variables for a process, use the &lt;code&gt;setEnv&lt;/code&gt; method
with a &lt;code&gt;HashMap&amp;lt;String, String&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;bash&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $MYVAR&amp;quot;])

env := HashMap&amp;lt;String, String&amp;gt; new()
env put(&amp;quot;MYVAR&amp;quot;, &amp;quot;42&amp;quot;)
p setEnv(env)

// prints 42
p execute()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Communicating with a process&lt;/h1&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Redirecting stdin, stdout, stderr&lt;/h2&gt;

&lt;p&gt;One may use &lt;a href=&#34;/docs/sdk/os/pipe/&#34;&gt;pipes&lt;/a&gt; to redirect the standard input, output, or error stream of
a process.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Process, Pipe, PipeReader]

p := Process new([&amp;quot;some&amp;quot;, &amp;quot;process&amp;quot;])

(out, err) := (Pipe new(), Pipe new())
p setStdout(out)
p setStderr(err)

exitCode := p execute()

outString := PipeReader new(out) toString()
errString := PipeReader new(err) toString()

out close(&#39;r&#39;). close(&#39;w&#39;)
err close(&#39;r&#39;). close(&#39;w&#39;)

// we now have the exit code in exitCode, the
// stdout in outString, and the stderr in errString
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Streaming output&lt;/h2&gt;

&lt;p&gt;This can be used to stream stdout to the output of our main program, if the launched
process is interactive. If blinkenlights is still up and running when you try this, it
should display star wars scene in ASCII art:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;nc&amp;quot;, &amp;quot;towel.blinkenlights.nl&amp;quot;, &amp;quot;23&amp;quot;])

out := Pipe new()
out setNonBlocking()
p setStdout(out)

p executeNoWait()

while (true) {
    chr := out read()
    if (chr != &#39;\0&#39;) {
        chr print()
    } else if(p waitNoHang() &amp;gt; 0) {
        // process is done
        break
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Terminate or kill a process&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;terminate&lt;/code&gt; method will send a process the &lt;code&gt;SIGTERM&lt;/code&gt; message, while the &lt;code&gt;kill&lt;/code&gt; method
will send a process the &lt;code&gt;SIGKILL&lt;/code&gt; message.&lt;/p&gt;

&lt;p&gt;This can be used to gracefully end a process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p terminate()
if (p waitNoHang() != -1) {
    // give a few seconds of grace..
    Time sleepSec(3)
}

if (p waitNoHang() != -1) {
    // still not finished? alright, that&#39;s enough
    p kill()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Control Structures</title>
      <link>http://oocmanual.cogneco.com/language/control-structures</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/control-structures</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Conditionals&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;if / else&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s your traditional if, else if, else structure. The body should be either
a single statement, or a scope.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
if (off) turnOn()

if (stressed) {
    breatheIn()
    breatheOut()
} else if (tired) {
    rest()
} else {
    allGood()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The condition can be of type &lt;code&gt;Bool&lt;/code&gt; or a Pointer, in which case it will evaluate to
&lt;code&gt;true&lt;/code&gt; if it is non-null.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;match / case&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; is ooc&amp;rsquo;s &lt;code&gt;switch&lt;/code&gt;, loosely modelled after Scala&amp;rsquo;s. In its simplest form, it tests for equality between an expression and several values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match (numFeets) {
    case 1 =&amp;gt; &amp;quot;Ouch&amp;quot;
    case 2 =&amp;gt; &amp;quot;Normal&amp;quot;
    case =&amp;gt;
        // what?
        raise(&amp;quot;Too many feet&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each case is a scope of its own - it doesn&amp;rsquo;t require braces. A case with no
expression is a catch-all.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; also works with any class T that implements the method &lt;code&gt;matches?: func
-&amp;gt; (other: T) -&amp;gt; Bool&lt;/code&gt;. Another way to get complex types to work in matches
is simply to override the &lt;code&gt;==&lt;/code&gt; operator. Hence, Strings work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match keyword {
    case &amp;quot;if&amp;quot; =&amp;gt;
        Keyword IF
    case &amp;quot;match&amp;quot; =&amp;gt;
        Keyword MATCH
    case =&amp;gt;
        Keyword UNKNOWN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; is also a good way to avoid explicit casting, by matching an object
against variable declarations, one can use its specific form directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
result := match (op) {
    case plus: Plus =&amp;gt;
        plus lhs + plus rhs
    case minus: Minus =&amp;gt;
        minus lhs - minus rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;match&lt;/code&gt; is an expression, if every case ends with an expression. Hence, a
match can be used as a return value, or in a function call, on the right hand
side of a declaration-assignment (&lt;code&gt;:=&lt;/code&gt;), as demonstrated above.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Loops&lt;/h1&gt;

&lt;p&gt;Loops are structures that control the repetition of a body of code.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;break / continue&lt;/h2&gt;

&lt;p&gt;Two particular keywords are of interest when writing loops:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; immediately exits the loop, skipping the rest of the body
and not executing any further iteration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; skips over the rest of the body and begins the next
iteration immediately&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;while&lt;/h2&gt;

&lt;p&gt;Checks the condition - if false, skips the body. If true, runs the body,
then checks the condition again, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (!satisfied) {
    buyStuff()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;for&lt;/h2&gt;

&lt;p&gt;There is no C-like &lt;code&gt;for&lt;/code&gt; in ooc, only a foreach. It can iterate through
values like ranges:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (i in 1..10) {
    &amp;quot;Counting to %d&amp;quot; printfln(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or more complex data structures:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (element in list) {
    &amp;quot;Element = %s&amp;quot; printfln(element toString())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an object to be iterable, it has to implement the
&lt;code&gt;iterator: func &amp;lt;T&amp;gt; -&amp;gt; Iterator&amp;lt;T&amp;gt;&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;A variant of foreach allows one to get the index of the current element:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for ((index, element) in list) {
    &amp;quot;list[%d] = %s&amp;quot; printfln(index, element toString())
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://oocmanual.cogneco.com/introduction</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/introduction</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Once Upon A Time&amp;hellip;&lt;/h1&gt;

&lt;p&gt;Once upon a time, there was a sysadmin who wanted to make sure her website
was always online. However, she figured that she was pretty good at compiling,
installing, and configuring software, but that her programming skills were a bit
rusty.&lt;/p&gt;

&lt;p&gt;Oh, sure, she remembered her days at university where she learned a bit of Java,
and C++, and the cool mind-bending exercises in LISP, but today she felt like trying
something new. She followed the &lt;a href=&#34;/install/&#34;&gt;installation instructions&lt;/a&gt; carefully, and then
jumped in without waiting.&lt;/p&gt;

&lt;p&gt;After fishing online for information, she decided to start with the following
program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;The website may or may not be online.&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saving it as &lt;code&gt;watchcorgi.ooc&lt;/code&gt; and running &lt;code&gt;rock -v watchcorgi&lt;/code&gt; sure produced a lot
of output. And - as a token of its appreciation, the compiler even left an executable
on the hard drive. What a promising relationship, she thought.&lt;/p&gt;

&lt;p&gt;However, not one to be overly chatty, she decided that instead of having to type
&lt;code&gt;rock watchcorgi&lt;/code&gt; every time she wanted to compile her new program, she was going
to write a &lt;a href=&#34;/docs/tools/rock/usefiles&#34;&gt;usefile&lt;/a&gt; for it, and put them both together in a directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!yaml
Name: Watch Corgi
Description: Tells on the bad websites that go down
Version: 0.1.0
SourcePath: source
Main: watchcorgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saving it as &lt;code&gt;watchcorgi.use&lt;/code&gt;, she realized that, if she wanted her usefile to be
valid, she needed to move her ooc module into &lt;code&gt;source/watchcorgi.ooc&lt;/code&gt;. So then, her
folder hierarchy now looked like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── source
│   └── watchcorgi.ooc
└── watchcorgi.use
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, all she had to do was type &lt;code&gt;rock&lt;/code&gt; to have her program compiled. If she felt
like reading a bit, all she had to do was &lt;code&gt;rock -v&lt;/code&gt; - it reminded her of the countless
hours spent installing packages on Gentoo.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;The Great Illusion&lt;/h1&gt;

&lt;p&gt;However, that program was not quite as useful as she had hoped so far. While it was
technically correct — the best kind of correct — it did not, in fact, bring any new
information to the table.&lt;/p&gt;

&lt;p&gt;That was not meant to last, though, as she quickly devised a devious scheme. Before
the era of watchcorgi, she was using &lt;code&gt;curl&lt;/code&gt;, a command-line utility, to check if the
website was still online. It looked a little something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
curl -I http://example.org/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Of course, that wasn&amp;rsquo;t her website&amp;rsquo;s actual URL, which we have sneakingly substituted
with something a tad more common, in order to protect our heroine&amp;rsquo;s privacy.)&lt;/p&gt;

&lt;p&gt;Running that simple command was enough to let her know, with a simple look, whether
the website was up and running or down in the ground — in which case prompt maintenance
was needed as soon as humanly possible.&lt;/p&gt;

&lt;p&gt;She decided that if she could run that command herself, there was no reason why her
program couldn&amp;rsquo;t do so as well. After a second documentation hunt, she quickly jotted
down a few more lines, replacing the contents of &lt;code&gt;source/watchcorgi.ooc&lt;/code&gt; with this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Process

exitCode := Process new([&amp;quot;curl&amp;quot;, &amp;quot;-I&amp;quot;, &amp;quot;http://example.org/&amp;quot;]) execute()
&amp;quot;Sir Curl exited with: %d&amp;quot; printfln(exitCode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And sure enough, after a quick recompilation, she saw the expected result: &lt;code&gt;Sir Curl
exited with: 0&lt;/code&gt;. Curious, she disconnected from the internet, and tried launching
&lt;code&gt;./watchcorgi&lt;/code&gt; again. This time, she saw: &lt;code&gt;Sir Curl exited with: 6&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;It&amp;rsquo;s just like it always is with Unix-like tools&amp;rdquo; she thought. &amp;ldquo;An exit code of 0
is a good sign, anything else&amp;hellip; not so much. It sure is convenient to be able
to import another ooc module for almost everything. Apparently, this &lt;code&gt;Process&lt;/code&gt; class
takes an array with the command arguments. And this &lt;code&gt;execute&lt;/code&gt; method returns the
exit code. Neato!&amp;rdquo; And so it was.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Form Follows Function&lt;/h1&gt;

&lt;p&gt;She was starting to be happy with her program. For all intents and purposes, was doing
its job, and it was doing its job well. However, she could not deny that her program
could have put a little more effort in the presentation. Just because a program does
not have a will of its own, doesn&amp;rsquo;t mean it&amp;rsquo;s okay for it to be rude.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Time to get to work&amp;rdquo;, she said out loud, forgetting that it was past 2 in the morning,
and that nobody could probably hear her - and even if they could, there was no
certainty that they would agree. While she thought about that, her fingers had kept
tapping on the keyboard. Her program now looked a little bit like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Process, Terminal]

exitCode := Process new([&amp;quot;curl&amp;quot;, &amp;quot;-I&amp;quot;, &amp;quot;http://example.org/&amp;quot;]) execute()

match (exitCode) {
  case 0 =&amp;gt;
    &amp;quot;Everything is fine.&amp;quot; println()

  case =&amp;gt;
    Terminal setFgColor(Color red)
    &amp;quot;[ERROR] The website is down!&amp;quot; println()
    Terminal reset()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It didn&amp;rsquo;t blink, and there were no 3D effects: disappointing maybe for a sci-fi
fan like her little brother, but having alerts in red, and a human-readable message
was fine enough for her.&lt;/p&gt;

&lt;p&gt;While carefully proofreading her code to check if she hadn&amp;rsquo;t missed anything, she
thought about the syntax of the &lt;code&gt;match&lt;/code&gt; construct. &amp;ldquo;It&amp;rsquo;s pretty smart, in fact.
Cases are tested from top to bottom - the first that matches, wins. And a case with
no value simply matches everything&amp;rdquo;. It just made sense.&lt;/p&gt;

&lt;p&gt;She was also particularly happy with the way she was able to import both &lt;code&gt;os/Process&lt;/code&gt;
and &lt;code&gt;os/Terminal&lt;/code&gt; from the same line. Sure, she could have written two different
&lt;code&gt;import&lt;/code&gt; directives, but she had been promised a concise programming language and it
was about time it delivered.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Corgi Ever Watching&lt;/h1&gt;

&lt;p&gt;Now that the program was polite, our programmer felt good enough to take a
small break. As she was looking out the window, waiting for her 3rd cup of
nocturnal coffee to brew, it came to her: &amp;ldquo;Wait a minute&amp;hellip; what good is my
program if I have to keep running it manually?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;A quick sip out of her coffee cup finished to clear her mind completely.
&amp;ldquo;I am going to need some sort of loop. And I think watchcorgi should shut
up if everything is fine, and only complain if something goes wrong.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;As she looked at her timer, waiting for it to run out and allow her to go back
to hacking (self-discipline is important, after all), she came to a second
realization: that there were two main tasks in her program - the checking, and
the notifying. Surely there must be some way to write that in a more modular
way?&lt;/p&gt;

&lt;p&gt;She decided to go for broke, and split her program into three different ooc
modules. She started with &lt;code&gt;source/watchcorgi/checker.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Process]

Checker: class {
  url: String

  init: func (=url)

  /**
   * @return true if the url is reachable, false otherwise
   */
  check: func -&amp;gt; Bool {
    0 == Process new([&amp;quot;curl&amp;quot;, &amp;quot;-I&amp;quot;, url]) execute()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then went on with &lt;code&gt;source/watchcorgi/notifier.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Terminal]

Notifier: class {
  quiet: Bool

  init: func

  notify: func (online: Bool, url: String) {
    if (online) {
      if (quiet) return

      Terminal setFgColor(Color green)
      &amp;quot;[ OK  ] %s is online.&amp;quot; printfln(url)
      Terminal reset()
    } else {
      Terminal setFgColor(Color red)
      &amp;quot;[ERROR] %s is not reachable! You may panic now.&amp;quot; printfln(url)
      Terminal reset()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, thought it was better to rewrite &lt;code&gt;source/watchcorgi.ooc&lt;/code&gt; from
scratch using those new modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import watchcorgi/[checker, notifier]
import os/Time

notifier := Notifier new()
notifier quiet = true // only bother me if something goes wrong
checker := Checker new(&amp;quot;http://example.org/&amp;quot;)

while (true) {
  notifier notify(checker check(), checker url)
  Time sleepSec(5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There. All good. Not only was her program now constantly vigilant, checking
for potential problems every five seconds, she felt that the various components
were just as flexible as needed, small enough, and that it made the main program
file short and sweet.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;The Littlest Things&lt;/h1&gt;

&lt;p&gt;There was one area of the code she wasn&amp;rsquo;t entirely happy with - in the
notifier, she was using the same pattern twice. First &lt;code&gt;Terminal setFgColor&lt;/code&gt;,
then &lt;code&gt;String printfln&lt;/code&gt;, then &lt;code&gt;Terminal reset&lt;/code&gt;.  She decided to extract that
pattern into a function instead, and added it to the end of the the &lt;code&gt;Notifier&lt;/code&gt;
class definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
say: func (color: Color, message: String) {
  Terminal setFgColor(color)
  message println()
  Terminal reset()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With that new neighbor, the notify function was happy to be reduced to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
notify: (online: Bool, url: String) {
  if (online) {
    if (quiet) return
    say(Color green, &amp;quot;[ OK  ] %s is online&amp;quot; format(url))
  } else {
    say(Color red, &amp;quot;[ERROR] %s is not reachable! You may panic now.&amp;quot; \
      format(url))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this was better, she wasn&amp;rsquo;t satisfied yet - calling &lt;code&gt;format&lt;/code&gt; like this
(she thought of it as a version of &lt;code&gt;printfln&lt;/code&gt; that returned the formatted string
instead of printing it) wasn&amp;rsquo;t particularly pretty.&lt;/p&gt;

&lt;p&gt;Like with everything that bothered her, she decided to do something about it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
say: func (color: Color, message: String, args: ...) {
  Terminal setFgColor(color)
  message printfln(args)
  Terminal reset()
}

notify: func (online: Bool, url: String) {
  if (online) {
    if (quiet) return
    say(Color green, &amp;quot;[ OK  ] %s is online&amp;quot;, url)
  } else {
    say(Color red, &amp;quot;[ERROR] %s is not reachable! You may panic now.&amp;quot;, url)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It was subtle, but for her, it made all the difference. Being able to relay
any number of arguments like that? This language might actually be comfortable
after all.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;All Together Now&lt;/h1&gt;

&lt;p&gt;&amp;ldquo;So, that was nice. For the life of me, I can&amp;rsquo;t think of a single thing my program
is missing.&amp;rdquo; Her eyes closed gently, and she leaned back, as if overwhelmed by bliss.&lt;/p&gt;

&lt;p&gt;Wait. Her eyes, suddenly inquisitive, were perfectly open now. &amp;ldquo;What if I want
to monitor several websites? Then I would need a config file so that I could modify
the list of websites to monitor&amp;hellip; and it would need to check them in parallel, so
it doesn&amp;rsquo;t get stuck on any one of them.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;She decided she needed one more module: &lt;code&gt;source/watchcorgi/config.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import io/File
import os/Env
import structs/List
import text/StringTokenizer

DEFAULT_PATH := Env get(&amp;quot;HOME&amp;quot;) + &amp;quot;/.config/corgirc&amp;quot;

Config: class {
  websites: List&amp;lt;String&amp;gt;

  init: func (path := DEFAULT_PATH) {
    content := File new(path) read()
    websites = content split(&#39;\n&#39;) \
               map(|line| line trim(&amp;quot;\t &amp;quot;)) \
               filter(|line| !line empty?())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Armed with that new weapon, checking multiple websites in parallel was just a
matter of making threads behave. Since she didn&amp;rsquo;t have much experience in the
domain, and the documentation seemed a little bit obscure, she decided to ask
for help in the &lt;a href=&#34;https://groups.google.com/group/ooc-lang&#34;&gt;ooc discussion group&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Almost immediately, a response sprung with numerous code examples she could use
as inspiration for her own endeavor. And so she embarked courageously,
rewriting &lt;code&gt;source/watchcorgi.ooc&lt;/code&gt; once again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import watchcorgi/[config, checker, notifier]
import os/Time
import threading/Thread
import structs/[ArrayList]

threads := ArrayList&amp;lt;Thread&amp;gt; new()
config := Config new()

for (url in config websites) {
  threads add(Thread new(||
    guard := Guard new(url, 5)
    guard run()
  ))
}

// start all the threads
for (thread in threads) {
  thread start()
}

// wait for all threads to complete
threads each(|thread| thread wait())

Guard: class {
    delay: Int
    checker: Checker
    notifier: Notifier

    init: func (url: String, =delay) {
      checker = Checker new(url)
      notifier = Notifier new()
      notifier quiet = true
    }

    run: func {
      while (true) {
        notifier notify(checker check(), checker url)
        Time sleepSec(delay)
      }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As she began to write down a list of websites to check in &lt;code&gt;~/.config/corgirc&lt;/code&gt;,
she started to list the new things she had learned during that last refactoring:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;That classes can be used before they are defined - in order word, the order
in which classes are defined does not matter!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That threads, while really old fashioned, were quite easy to use - all you
had to do was create a new &lt;code&gt;Thread&lt;/code&gt; object and pass a function that takes
zero arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That some functions are anonymous - and that they can be defined as an
argument to a function call like this: &lt;code&gt;[1, 2, 3] reduce(|a, b| a + b)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That using a foreach, such as &lt;code&gt;for (element in iterable) { /* code */ }&lt;/code&gt; or
using the each method, like so &lt;code&gt;iterable each(|element| /* code */ )&lt;/code&gt;, where
pretty much equivalent.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;When Features Creep&lt;/h1&gt;

&lt;p&gt;As magnificent as the program was, she couldn&amp;rsquo;t shake an eerie feeling. It
seemed so perfect, so concise, so damn practical - what could possibly go
wrong?&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Oh, right!&amp;rdquo; she whispered. The program assumes that the &lt;code&gt;curl&lt;/code&gt; command-line
utility is installed and in the &lt;code&gt;$PATH&lt;/code&gt;. While on most Linux distributions,
that&amp;rsquo;s a safe bet, it might not be there on OSX. Or, god forbid, on Windows.&lt;/p&gt;

&lt;p&gt;But it was almost 6AM, and rays of sunlight would soon come and disturb the
oh so peaceful (yet eventful) night of coding. Obviously, she could not afford
to write her own HTTP library.&lt;/p&gt;

&lt;p&gt;Sure, in theory, a simple usage of &lt;code&gt;net/TCPSocket&lt;/code&gt; from the SDK, writing
something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HEAD / HTTP/1.0\r\n\r\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..and seeing if you get a non-empty response, would suffice. But what about
parsing empty, yet worrying responses, like an HTTP 404, or an HTTP 502? What
about HTTP 1.1 and the Host header, essential when several websites are running
on the same IP address? And most importantly, what about HTTPS, which runs on a
different port, and what&amp;rsquo;s more, over SSL?&lt;/p&gt;

&lt;p&gt;No, definitely, writing an HTTP library was not part of the plan. But maybe
there was something she could use&amp;hellip; maybe curl existed also as a library. A
quick search for &lt;code&gt;ooc curl&lt;/code&gt; revealed the existence of
&lt;a href=&#34;https://github.com/nddrylliog/ooc-curl&#34;&gt;nddrylliog/ooc-curl&lt;/a&gt;. Jackpot!&lt;/p&gt;

&lt;p&gt;A quick clone and.. wait. She knew better. Why not use &lt;a href=&#34;/docs/tools/sam/&#34;&gt;sam&lt;/a&gt; instead?
A simple &lt;code&gt;sam clone curl&lt;/code&gt; would suffice. Or, better yet, she could add the
dependency in the .use file, and run &lt;code&gt;sam get&lt;/code&gt; from the watchcorgi folder
afterwards.&lt;/p&gt;

&lt;p&gt;Her .use file now looked a little bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!yaml
Name: Watch Corgi
Description: Multi-threaded website monitoring system
Version: 0.2.0

SourcePath: source
Main: watchcorgi
Requires: curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And sure enough, after &lt;code&gt;sam get&lt;/code&gt;, she saw the &lt;code&gt;ooc-curl&lt;/code&gt; folder appear in her
&lt;code&gt;$OOC_LIBS&lt;/code&gt; directory. It was time to rewrite &lt;code&gt;source/watchcorgi/checker.ooc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
use curl
import curl/Highlevel

Checker: class {
    url: String

    init: func (=url)

    /**
     * @return true if the url is reachable, false otherwise
     */
    check: func -&amp;gt; Bool {
      200 == (HTTPRequest new(url). perform(). getResponseCode())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code was one of her favorites yet. She had used one of the
features she had just learned about - call chaining. &amp;ldquo;In fact&amp;rdquo;, she would
later explain to a colleague, &amp;ldquo;you can think of the dot as a comma - it
separates several method calls, but they all happen on the same object,
sequentially&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Recompiling the program after this change was exciting. There was no
configuration dialog to fill out. No complicated command-line option to add
when compiling. As a matter of fact, the single line added to the use file was
enough to make sam happy - and rock itself seemed pretty content with the &lt;code&gt;use
curl&lt;/code&gt; directive now sitting at the top of the checker module.&lt;/p&gt;

&lt;p&gt;A simple &lt;code&gt;rock -v&lt;/code&gt; did the trick. And there she had it. The perfect website
monitoring system. At last. Oh, sure, part of her brain fully realized that
the impression of perfectness would fade out over the days, but as far as
discovering a new language goes, she thought this was a pretty good run.&lt;/p&gt;

&lt;p&gt;There was just one thing left to do&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;To Give Back&lt;/h1&gt;

&lt;p&gt;At this point, she felt that watchcorgi it was worth it to publish her program
somewhere. Of course, all along, she had been keeping track of it using
&lt;a href=&#34;http://git-scm.org/&#34;&gt;git&lt;/a&gt;. In this case, she was using &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; as a host.&lt;/p&gt;

&lt;p&gt;She decided to make it easy for other people who might want to use
&lt;code&gt;watchcorgi&lt;/code&gt;, to get it. After a quick search, it quickly became evident that
the process itself was trivial. She just had to send a pull request to the
&lt;a href=&#34;https://github.com/nddrylliog/sam&#34;&gt;sam repository&lt;/a&gt; that added a formula for her new pet project.&lt;/p&gt;

&lt;p&gt;So, after forking sam on GitHub, changing the origin of her sam repository,
she opened a new file in &lt;code&gt;$OOC_LIBS/sam/library/watchcorgi.yml&lt;/code&gt;, and wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!yaml
Origin: https://github.com/example/watchcorgi.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then, she &lt;a href=&#34;https://help.github.com/articles/creating-a-pull-request&#34;&gt;submitted the pull request&lt;/a&gt;. The sun was rising.
It felt warm. I think - she thought - I just might like it here.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>coro</title>
      <link>http://oocmanual.cogneco.com/sdk/os/coro</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/coro</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Coro module&lt;/h1&gt;

&lt;p&gt;That module was originally an ooc port of Steve Dekorte&amp;rsquo;s &lt;a href=&#34;https://github.com/stevedekorte/coroutine&#34;&gt;libcoroutine&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Coroutines help achieve cooperative multi-tasking, as opposed to threads, which
achieve preemptive multitasking. In cooperative multi-tasking, each task (or
&amp;lsquo;coroutine&amp;rsquo;) is responsible for handing the control to another coroutine.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;First, we have to create a main coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Coro

mainCoro := Coro new()
mainCoro initializeMainCoro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then create another coroutine, which we&amp;rsquo;ll here use as a generator&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
letter: Char

coro1 := Coro new()
mainCoro startCoro(coro1, ||
    for (c in &amp;quot;LLAMACORE&amp;quot;) {
        letter = c
        coro1 switchTo(mainCoro)
    }
    exit(0)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can retrieve those letters one by one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (true) {
    &amp;quot;%c&amp;quot; printfln(letter)
    mainCoro switchTo(coro1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is quite simple, just printing each letter that
&lt;code&gt;coro1&lt;/code&gt; gives us on separate lines, but complex tasks can be
broken down in various coroutines and be achieved in a much
more lightweight fashion than threads or processes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Packaging</title>
      <link>http://oocmanual.cogneco.com/tools/rock/packaging</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/packaging</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;While ooc provides facilities to write highly cross-platform applications, and
makes it rather easy to develop on all these platforms, distributing standalone
applications is another matter entirely.&lt;/p&gt;

&lt;p&gt;Until a tool comes along and in the darkness binds them, this chapter documents
the manual process that goes into releasing neatly packaged software for
Windows, OSX and Linux.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Windows&lt;/h1&gt;

&lt;p&gt;Windows is surprisingly easy to package for — a 32-bit executable will happily
run on both 32-bit and 64-bit systems, there is no library path headache if you
include all the required DLLs in the same directory as the .exe, and the
current working directory is always the one with the .exe file.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Dynamic GC&lt;/h2&gt;

&lt;p&gt;If your application is multi-threaded, make sure to link with the GC
dynamically as explained in &lt;a href=&#34;/docs/tools/rock/gc/#threads&#34;&gt;the Garbage Collection chapter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you link statically with the GC and use multiple threads, chances are you
will run into very ugly memory corruption bugs that seemingly make no sense.
So, make sure to double-check that first.&lt;/p&gt;

&lt;p&gt;Since you&amp;rsquo;ll link dynamically with it, you&amp;rsquo;ll need to include &lt;code&gt;libgc-1.dll&lt;/code&gt;,
and you might also need &lt;code&gt;pthreadGC2.dll&lt;/code&gt;, which lives in &lt;code&gt;/mingw/bin/&lt;/code&gt; under
MinGW.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Resource file&lt;/h2&gt;

&lt;p&gt;To bundle an icon with your executable, and add the full program name, author,
etc, create a .rc file containing something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id ICON &amp;quot;art/foo.ico&amp;quot;
1 VERSIONINFO
FILEVERSION     1,0,0,0
PRODUCTVERSION  1,0,0,0
BEGIN
  BLOCK &amp;quot;StringFileInfo&amp;quot;
  BEGIN
    BLOCK &amp;quot;040904E4&amp;quot;
    BEGIN
      VALUE &amp;quot;CompanyName&amp;quot;, &amp;quot;Company Name&amp;quot;
      VALUE &amp;quot;FileDescription&amp;quot;, &amp;quot;Application Name&amp;quot;
      VALUE &amp;quot;FileVersion&amp;quot;, &amp;quot;1.0&amp;quot;
      VALUE &amp;quot;InternalName&amp;quot;, &amp;quot;applicationname&amp;quot;
      VALUE &amp;quot;LegalCopyright&amp;quot;, &amp;quot;Author Name&amp;quot;
      VALUE &amp;quot;OriginalFilename&amp;quot;, &amp;quot;foo.exe&amp;quot;
      VALUE &amp;quot;ProductName&amp;quot;, &amp;quot;Application Name&amp;quot;
      VALUE &amp;quot;ProductVersion&amp;quot;, &amp;quot;1.0&amp;quot;
    END
  END

  BLOCK &amp;quot;VarFileInfo&amp;quot;
  BEGIN
    VALUE &amp;quot;Translation&amp;quot;, 0x409, 1252
  END
END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adjust these values as needed. To create a high-quality &lt;code&gt;.ico&lt;/code&gt; file from a
PNG image, the usage of a tool such as &lt;a href=&#34;http://icofx.ro/&#34;&gt;IcoFX&lt;/a&gt; might be needed.&lt;/p&gt;

&lt;p&gt;Then, compile this &lt;code&gt;.rc&lt;/code&gt; file with the &lt;code&gt;windres&lt;/code&gt; command-line utility - if
you have a Makefile you might want to add a target for this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;windres -i foo.rc -o foo.res -O coff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step to include these resources is to link them with your executable.
This can be done easily if you already have a .use file, by adding a section in
a &lt;code&gt;version(windows)&lt;/code&gt; block. For example, in foo.use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Name: foo
Version: 1.0
Description: Foo builds upon bar baz and does wonderful stuff
SourcePath: source
Requires: bar, baz
Main: foo/foo

# Add resources on Windows
version (windows) {
  Libs: ./foo.res
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure to &lt;code&gt;use foo&lt;/code&gt; in the main file of your application so that rock takes
these into account. The resulting executable should have the icon built-in,
along with the author and product information you have specified in the
&lt;code&gt;foo.rc&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;Note that every time &lt;code&gt;foo.rc&lt;/code&gt; changes, it needs to be recompiled to &lt;code&gt;foo.res&lt;/code&gt;.
You don&amp;rsquo;t need to distribute either the &lt;code&gt;.rc&lt;/code&gt; or the &lt;code&gt;.res&lt;/code&gt; file with the
executable, it&amp;rsquo;s all baked in!&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;DLL dependencies&lt;/h2&gt;

&lt;p&gt;To figure out which libraries someone will need to run your application, you can use
&lt;a href=&#34;http://www.dependencywalker.com/&#34;&gt;Dependency Walker&lt;/a&gt;, also known as &lt;code&gt;depends.exe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Loading your .exe in it, with the right working directory, will allow you to
see which DLLs it loads and from where. Then, all you need is to copy those
DLLs to the directory of your application and distribute them along.&lt;/p&gt;

&lt;p&gt;Be warned: there may be several versions of a given library on your system.
Make sure to pick the right one.&lt;/p&gt;

&lt;p&gt;If your program can be launched by double-clicking on it in the Windows GUI
(instead of running it from the command-line), it&amp;rsquo;s a good sign - but it might
not be enough. Some open-source programs install libraries to system paths, and
your application may be relying on that.&lt;/p&gt;

&lt;p&gt;To make sure the application runs everywhere, testing it on a &amp;ldquo;virgin&amp;rdquo; install
of Windows is recommended. If there was a time to use a virtual machine, that
would be it.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Final notes&lt;/h2&gt;

&lt;p&gt;You can choose to generate an installer of course, but a .zip file is fine as
well.  Windows systems usually have facilities to extract .zip files without
the need for an external program.&lt;/p&gt;

&lt;p&gt;Creating a zip file can be done with the command line GNU zip utility:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zip -r Foo-1.0-Windows.zip Foo-1.0-Windows
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..or by using a graphical tool, for example, &lt;a href=&#34;http://www.7-zip.org/&#34;&gt;7-Zip&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;OSX&lt;/h1&gt;

&lt;p&gt;Releasing an app on OSX is relatively easy, as tools exist to make it easier.
64-bit executables are the norm for recent versions of Mac OS X, so there is no
pain there either.&lt;/p&gt;

&lt;p&gt;The only part where it needs a little hand holding is when creating the app
bundle.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;dylibbundler&lt;/h2&gt;

&lt;p&gt;We need to distribute libraries inside the app bundle - however, so that the
paths are resolve correctly, we&amp;rsquo;ll need to use &lt;a href=&#34;http://macdylibbundler.sourceforge.net/&#34;&gt;dylibbundler&lt;/a&gt; to modify
the executable and &amp;lsquo;fix&amp;rsquo; the paths to these libraries.&lt;/p&gt;

&lt;p&gt;With &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;, installing dylibbundler is as simple as doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install dylibbundler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step is to tell the C compiler to reserve enough room to modify the
library paths later:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rock +-headerpad_max_install_names
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we&amp;rsquo;ll have to create a folder that will be our app bundle, such as
&lt;code&gt;Foo.app&lt;/code&gt;, with the following directory structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Foo.app/
  Contents/
    Info.pList
    MacOS/
      foo
      wrapper
    Resources/
      foo.icns
    libs/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Contents/MacOS/foo&lt;/code&gt; is our executable that we have copied from before, and
&lt;code&gt;Contents/MacOS/wrapper&lt;/code&gt; will be our launcher script (described in a further
section).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Contents/MacOS&lt;/code&gt; directory should also contain any files the executable
expects to find in the current working directory when launched (e.g. for game
that would be the graphics, sounds, etc.)&lt;/p&gt;

&lt;p&gt;The next step is to dylibbundler on the executable so that libs are copied and
the paths are fixed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dylibbundler -od -b -x ./Foo.app/Contents/MacOS/helloworld -d ./Foo.app/Contents/libs/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Info.pList&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Info.pList&lt;/code&gt; file is similar to the &lt;code&gt;foo.rc&lt;/code&gt; file we discussed in the
Windows section. A stock plist file looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple Computer//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;CFBundleGetInfoString&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;Application Name&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleExecutable&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;wrapper&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;com.yourdomain.www&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleName&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;applicationname&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleIconFile&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;foo.icns&amp;lt;/string&amp;gt;
  &amp;lt;!-- Don&#39;t modify those! --&amp;gt;
  &amp;lt;key&amp;gt;CFBundleShortVersionString&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;1.0&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleInfoDictionaryVersion&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;6.0&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundlePackageType&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;APPL&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;IFMajorVersion&amp;lt;/key&amp;gt;
  &amp;lt;integer&amp;gt;0&amp;lt;/integer&amp;gt;
  &amp;lt;key&amp;gt;IFMinorVersion&amp;lt;/key&amp;gt;
  &amp;lt;integer&amp;gt;1&amp;lt;/integer&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should live in &lt;code&gt;Foo.app/Contents/Info.pList&lt;/code&gt;. Just like a Windows RC file,
it references a &lt;code&gt;foo.icns&lt;/code&gt; file. A tool like &lt;a href=&#34;http://www.img2icnsapp.com/&#34;&gt;img2icns&lt;/a&gt; can be used
to convert a high-resolution PNG image to a Mac OSX icon.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Launcher script&lt;/h2&gt;

&lt;p&gt;Finally, we have to use a launcher script so that the current working
directory of the app will be correct.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
#!/bin/bash
cd &amp;quot;${0%/*}&amp;quot;
./foo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Troubleshooting&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s not uncommon to encounter an error if an app Bundle is malformed or
otherwise problematic. Instead of double-clicking on the .app bundle to
launch it, one can open it from the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open Foo.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you get an &amp;ldquo;error -10180&amp;rdquo;, it means something went wrong while launching
the app. Make sure the files inside &lt;code&gt;Contents/MacOS/&lt;/code&gt; are executable, and
that the wrapper is trying to launch the correct executable.&lt;/p&gt;

&lt;p&gt;In doubt, running &lt;code&gt;plutil&lt;/code&gt; can help proofread the &lt;code&gt;pList&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plutil Foo.app/Contents/Info.pList
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Final notes&lt;/h2&gt;

&lt;p&gt;OSX apps are sometimes encountered as &lt;code&gt;.dmg&lt;/code&gt; files in the wild, which are
image files that contain partitions, which can be mounted and read from.
This allows a nice &amp;ldquo;drag and drop&amp;rdquo; window to be displayed.&lt;/p&gt;

&lt;p&gt;However, distributing an OSX application by just zipping up the &lt;code&gt;.app&lt;/code&gt;
bundle is acceptable. It can be done either on the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zip -r Foo.OSX.zip Foo.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;or in the graphical interface (Right Click -&amp;gt; Compress Foo.app).&lt;/p&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;Linux&lt;/h1&gt;

&lt;p&gt;Linux may be one of the comfiest platform for ooc development, but ironically,
it is one of the most painful to package standalone applications for. As a rule
of thumb, do not assume that your users will want to install libraries
themselves — always package them with the software.&lt;/p&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Multiarch&lt;/h2&gt;

&lt;p&gt;64-bit installs of Linux that aren&amp;rsquo;t multi-arch will complaing about missing
32-bit libraries, and conversely, 32-bit installs won&amp;rsquo;t be able to run a 64-bit
application at all. Which leaves us with the only option of providing both a
32-bit and a 64-bit executable.&lt;/p&gt;

&lt;p&gt;An example folder hierarchy is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo-1.0-linux/
  bin/
    foo32
    foo64
    libs32/
    libs64/
  foo.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we are going to ship dynamic libraries with the app, we should specify
the path where they are with the &lt;code&gt;-rpath&lt;/code&gt; linker option. The rock command looks
a little bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rock +-Wl,-rpath=bin/libs32 -o=foo32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;for the 32-bit version, and similarly for the 64-bit version.&lt;/p&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;Chroot&lt;/h2&gt;

&lt;p&gt;One of the easiest ways to build both a 32-bit and a 64-bit executable is to
have a 64-bit VM of Ubuntu, and set up a 32-bit chroot inside of it, then copy
files out of the chroot to retrieve the binaries and associated libraries.&lt;/p&gt;

&lt;p&gt;Setting up a chroot with debootstrap is &lt;a href=&#34;https://wiki.ubuntu.com/DebootstrapChroot&#34;&gt;documented on the Ubuntu website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_15&#34;&gt;Copying libs&lt;/h2&gt;

&lt;p&gt;To figure out the libraries you need to copy to &lt;code&gt;libs32&lt;/code&gt; or &lt;code&gt;libs64&lt;/code&gt;, the &lt;code&gt;ldd&lt;/code&gt;
command line utility can be used. Filtering its output to remove a few
libraries always present on Linux systems can help:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
ldd foo64 | egrep &amp;quot;(/usr/lib/)|(prefix64)&amp;quot; | cut -d &#39; &#39; -f 3 | egrep -v &amp;quot;lib(X|x|GL|gl|drm)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example above works for an OpenGL-based application. Copying these files
automatically can be done with a shell script such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
for l in $(ldd foo64 | egrep &amp;quot;(/usr/lib/)|(prefix64)&amp;quot; | cut -d &#39; &#39; -f 3 | egrep -v &amp;quot;lib(X|x|GL|gl|drm)&amp;quot; | tr &#39;\n&#39; &#39; &#39;); do
  cp $l libs64/
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checking that it well can be done by running &lt;code&gt;ldd bin/foo64&lt;/code&gt; in the release
directory.  Here&amp;rsquo;s some example output that shows the libs are resolved to
their relative paths:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ldd bin/foo64
libSDL2-2.0.so.0 =&amp;gt; bin/libs64/libSDL2-2.0.so.0 (0x00007fc6fa615000)
libSDL2_mixer-2.0.so.0 =&amp;gt; bin/libs64/libSDL2_mixer-2.0.so.0 (0x00007fc6f9ee0000)
libmxml.so.1 =&amp;gt; bin/libs64/libmxml.so.1 (0x00007fc6f9cd3000)
libfreetype.so.6 =&amp;gt; bin/libs64/libfreetype.so.6 (0x00007fc6f9a37000)
libyaml-0.so.2 =&amp;gt; bin/libs64/libyaml-0.so.2 (0x00007fc6f9815000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_16&#34;&gt;Launcher script&lt;/h2&gt;

&lt;p&gt;Courtesy of &lt;a href=&#34;https://twitter.com/flibitijibibo&#34;&gt;Ethan Lee&lt;/a&gt;, such a launcher script will detect the architecture
of the machine it&amp;rsquo;s running on and launch the right executable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
#!/bin/bash
# Move to the script&#39;s directory
cd &amp;quot;`dirname &amp;quot;$0&amp;quot;`&amp;quot;

# Get the kernel/architecture information
UNAME=`uname`
ARCH=`uname -m`

# Pick the proper executable
if [ &amp;quot;$ARCH&amp;quot; == &amp;quot;x86_64&amp;quot; ]; then
  ./bin/foo64
else
  ./bin/foo32
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_17&#34;&gt;Final notes&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;.tar.gz&lt;/code&gt; or &lt;code&gt;.tar.bz2&lt;/code&gt; archive formats is well-suited to distribute
applications for Linux, but &lt;code&gt;.zip&lt;/code&gt; works just as well, and &lt;code&gt;.tar.xz&lt;/code&gt; is usually
a little smaller.&lt;/p&gt;

&lt;p&gt;To create a &lt;code&gt;.tar.gz&lt;/code&gt;, do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar czvf foo-1.0-linux.tar.gz foo-1.0-linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a &lt;code&gt;.tar.bz2&lt;/code&gt;, use &lt;code&gt;cjvf&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;To create a &lt;code&gt;.tar.xz&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar cf --xz foo-1.0-linux.tar.xz foo-1.0-linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a &lt;code&gt;.zip&lt;/code&gt;, do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zip -r foo-1.0-linux.tar.zip foo-1.0-linux
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>native</title>
      <link>http://oocmanual.cogneco.com/sdk/native</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/native</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The native package&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;native&lt;/code&gt; package of the SDK contains nothing that should be
directly imported in a cross-platform application. It&amp;rsquo;s all platform-specific
support code for other parts of the SDK.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Windows&lt;/h2&gt;

&lt;p&gt;For example, the &lt;code&gt;native/win32&lt;/code&gt; package contains covers for types defined
in the Win32 API, along with a few error handling functions and other
things that are useful in the Win32 implementation of the SDK.&lt;/p&gt;

&lt;p&gt;Note that there exists &lt;code&gt;native&lt;/code&gt; sub packages elsewhere in the SDK, for example
in the &lt;code&gt;io&lt;/code&gt; or in the &lt;code&gt;os&lt;/code&gt; packages.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Operators</title>
      <link>http://oocmanual.cogneco.com/language/operators</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/operators</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Foreword&lt;/h1&gt;

&lt;p&gt;This lists all ooc operators, from highest precendence to lowest precedence&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Access&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Array access&lt;/h2&gt;

&lt;p&gt;The array-index operator is &lt;code&gt;[]&lt;/code&gt;, the array-modify operator&amp;rsquo;s short form is &lt;code&gt;[]=&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
arr[0] = &#39;\n&#39;
return arr[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Pointers&lt;/h2&gt;

&lt;p&gt;The address-of operator is a post-fix &lt;code&gt;&amp;amp;&lt;/code&gt;, the dereference operator is a post-fix
&lt;code&gt;@&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
a := 42
aPtr := a&amp;amp;
aToo := aPtr@
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Call&lt;/h2&gt;

&lt;p&gt;Technically not an operator, but call is in that priority level:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
a := func -&amp;gt; Int { 42 }
a()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Member access&lt;/h2&gt;

&lt;p&gt;Also technically not an operator. Simply two identifiers side by side,
not using dot, unlike some other programming languages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
dog name
dog race
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Casting&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; operator is used to cast from one type to the other:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pi := 3.14
roughlyPi := pi as Int
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Product&lt;/h1&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Binary operators&lt;/h2&gt;

&lt;p&gt;The exponent operator is &lt;code&gt;**&lt;/code&gt;, the multiplication operator is &lt;code&gt;*&lt;/code&gt;,
and the division operator is &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Unary operators&lt;/h2&gt;

&lt;p&gt;Logical not is a prefixed &lt;code&gt;!&lt;/code&gt;, binary not is a prefixed &lt;code&gt;~&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;Sum&lt;/h1&gt;

&lt;p&gt;The addition operator is &lt;code&gt;+&lt;/code&gt;, subtraction is &lt;code&gt;-&lt;/code&gt;,
modulo is &lt;code&gt;%&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;Shift&lt;/h1&gt;

&lt;p&gt;Right shift is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, left shift is &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;Inequality&lt;/h1&gt;

&lt;p&gt;You have your regular less than &lt;code&gt;&amp;lt;&lt;/code&gt;, greater than &lt;code&gt;&amp;gt;&lt;/code&gt;,
less than or equal &lt;code&gt;&amp;lt;=&lt;/code&gt;, more than or equal &lt;code&gt;&amp;gt;=&lt;/code&gt;,
but also the comparison operator &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; (evaluates to -1
if less than, 0 if equal, 1 if greater than).&lt;/p&gt;

&lt;h1 id=&#34;toc_13&#34;&gt;Equality&lt;/h1&gt;

&lt;p&gt;Equality operator is &lt;code&gt;==&lt;/code&gt;, inequality operator is &lt;code&gt;!=&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_14&#34;&gt;Binary and boolean operations&lt;/h1&gt;

&lt;p&gt;Binary and is &lt;code&gt;&amp;amp;&lt;/code&gt;, xor is &lt;code&gt;^&lt;/code&gt;, or is &lt;code&gt;|&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Logical and is &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, logical or is &lt;code&gt;||&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;Ternary&lt;/h1&gt;

&lt;p&gt;The ternary operator is &lt;code&gt;?:&lt;/code&gt; as in &lt;code&gt;condition ? ifTrue : ifFalse&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;Assignment&lt;/h1&gt;

&lt;p&gt;The assignment operator is &lt;code&gt;=&lt;/code&gt;, the following variants exist:
&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;**=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The declare-assignment operator is &lt;code&gt;:=&lt;/code&gt;. And the declare-property-assignment
operator is &lt;code&gt;::=&lt;/code&gt;. For more details on these, see the &lt;a href=&#34;/docs/lang/values/#variables&#34;&gt;Variables&lt;/a&gt; and
&lt;a href=&#34;/docs/lang/classes/#properties&#34;&gt;Properties&lt;/a&gt; pages.&lt;/p&gt;

&lt;h1 id=&#34;toc_17&#34;&gt;Double arrow&lt;/h1&gt;

&lt;p&gt;The double arrow operator &lt;code&gt;=&amp;gt;&lt;/code&gt; - it must be overloaded.&lt;/p&gt;

&lt;h1 id=&#34;toc_18&#34;&gt;Operator overloading&lt;/h1&gt;

&lt;p&gt;Overloading an operator can be done as a function-like, using the
&lt;code&gt;operator&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
operator + (v1, v2: Vec2) -&amp;gt; Vec2 { v1 add(v2) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if the operator is linked to a type, it&amp;rsquo;s better to declare
it in the type itself, so that it&amp;rsquo;ll be usable even if the module containing
the type declaration isn&amp;rsquo;t explicitly imported:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Vec2: class {
  // other stuff

  operator + (v: This) -&amp;gt; This { add(v) }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mmap</title>
      <link>http://oocmanual.cogneco.com/sdk/os/mmap</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/mmap</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/mmap module&lt;/h1&gt;

&lt;p&gt;As it stands, the &lt;code&gt;os/mmap&lt;/code&gt; module just exposes the *nix functions for memory
mapping: &lt;code&gt;mmap&lt;/code&gt;, &lt;code&gt;munmap&lt;/code&gt;, &lt;code&gt;mprotect&lt;/code&gt;, &lt;code&gt;madvise&lt;/code&gt;, &lt;code&gt;mincore&lt;/code&gt;, &lt;code&gt;minherit&lt;/code&gt;,
&lt;code&gt;msync&lt;/code&gt;, &lt;code&gt;mlock&lt;/code&gt;, and &lt;code&gt;munlock&lt;/code&gt;, along with the associated constants.&lt;/p&gt;

&lt;p&gt;It also contains prototypes / covers for the Windows equivalent,
&lt;code&gt;VirtualProtect&lt;/code&gt;, and its constants as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;This module is not a high-level or cross-platform interface and is not
documented extensively here.&lt;/p&gt;

&lt;p&gt;However, to find more information on memory mapping for various platform
see here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap on Wikipedia&lt;/a&gt; (for *nix platforms)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/windows/desktop/aa366898(v=vs.85).aspx&#34;&gt;VirtualProtect on MSDN&lt;/a&gt; (for Windows)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On a historical note, this module was originally included in the SDK as support
code for the closure implementation, which back then implied generating
bytecode at runtime and thus marking some memory regions as executable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lang</title>
      <link>http://oocmanual.cogneco.com/sdk/lang</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The lang package&lt;/h1&gt;

&lt;p&gt;The lang package is considered built-in: it is imported by default in ooc
modules. There is a reason for that, however - the SDK is distributed as
an ooc library itself, and as such, it has a .use file that specifies which
modules should be imported.&lt;/p&gt;

&lt;p&gt;Some of the lang package is essential, like &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Class&lt;/code&gt;, which
means that the compiler, &lt;a href=&#34;../tools/rock/&#34;&gt;rock&lt;/a&gt;, will expect them to be present,
have certain names, fields and methods. However, using a custom sdk is
possible, where the implementation for these can be swapped to something
lighter, for example.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;types&#34;&gt;Types&lt;/a&gt; section describes how Object,
 Class, and other types such as Void, Pointer, Bool, None,
 Cell are defined. It also discusses variable arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;string&#34;&gt;String&lt;/a&gt; section talks about string
 handling, the mutable variant Buffer, and formatting&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;numbers&#34;&gt;Numbers&lt;/a&gt; section talks about number
 types, either integers or floats, and the various functions available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;iterators&#34;&gt;Iterators&lt;/a&gt; section discusses
 how iterators are implemented, and what goes on behind a foreach.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;exceptions&#34;&gt;Exceptions&lt;/a&gt; section talks about
 default properties of exceptions, and how to extend them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;memory&#34;&gt;Memory&lt;/a&gt; section talks about memory
 management, mostly just how to deal with blocks of memory rather
 than more high-level data structures.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>terminal</title>
      <link>http://oocmanual.cogneco.com/sdk/os/terminal</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/terminal</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Terminal module&lt;/h1&gt;

&lt;p&gt;Terminal is used to control the terminal output, mostly by setting colors and
attributes on there.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Colors&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Color&lt;/code&gt; enum contains colors that are possible to set on the terminal:&lt;/p&gt;

&lt;p&gt;To change the foreground color, use &lt;code&gt;setFgColor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setFgColor(Color black)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To change the background color, use &lt;code&gt;setBgColor&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setBgColor(Color white)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;List of colors&lt;/h2&gt;

&lt;p&gt;Here are the colors defined in the Color enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;black&lt;/li&gt;
&lt;li&gt;red&lt;/li&gt;
&lt;li&gt;green&lt;/li&gt;
&lt;li&gt;yellow&lt;/li&gt;
&lt;li&gt;blue&lt;/li&gt;
&lt;li&gt;magenta&lt;/li&gt;
&lt;li&gt;cyan&lt;/li&gt;
&lt;li&gt;grey&lt;/li&gt;
&lt;li&gt;white&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that depending on your terminal emulator, these colors
might not map to their actual names.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Attributes&lt;/h1&gt;

&lt;p&gt;Attributes can be set using &lt;code&gt;setAttr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal setAttr(Attr bright)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;List of attributes&lt;/h2&gt;

&lt;p&gt;Here are the attributes defined in the &lt;code&gt;Attr&lt;/code&gt; enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reset&lt;/li&gt;
&lt;li&gt;bright&lt;/li&gt;
&lt;li&gt;dim&lt;/li&gt;
&lt;li&gt;under&lt;/li&gt;
&lt;li&gt;blink&lt;/li&gt;
&lt;li&gt;reverse&lt;/li&gt;
&lt;li&gt;hidden&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Resetting&lt;/h1&gt;

&lt;p&gt;Reset all color and attribute settings to default by using the
&lt;code&gt;reset&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Terminal reset()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Cross-platform considerations&lt;/h1&gt;

&lt;p&gt;On *nix platforms, all attributes are supposed. On Windows, only
the &lt;code&gt;reset&lt;/code&gt; attribute is supported.&lt;/p&gt;

&lt;p&gt;On *nix, the &lt;code&gt;Terminal&lt;/code&gt; module outputs ANSI escape sequences to
stdout, whereas on Windows it uses the console text attribute API.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why there is no cross-platform way to transform a string
into a &amp;ldquo;colored string&amp;rdquo;, because it would make no sense on Windows.&lt;/p&gt;

&lt;p&gt;Also, on *nix, color escapes will only be outputted if stdout is
a terminal and not if it&amp;rsquo;s redirected to a file or a pipe.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>