<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Manual</title>
      <link>http://oocmanual.cogneco.com/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;How to use the documentation&lt;/h1&gt;

&lt;p&gt;The documentation for ooc is structured as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tutorial/&#34;&gt;Tutorial&lt;/a&gt; is a ten minute journey meant for
newcomers to the language. By building a small program, you will learn the
basics of the syntax and even use bits of the SDK.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/lang/&#34;&gt;Language&lt;/a&gt; section explains in detail every feature
of the language: it goes through the syntax and a the main use cases for
every feature. It also contains a full grammar, and a collection of best
practices.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/sdk/&#34;&gt;SDK&lt;/a&gt; section gives an overview of the modules included
with the default ooc distribution. Whether you need access to files, to
measure time, to do some networking, or simply use common data structures,
the SDK is packed with goodness.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/&#34;&gt;Tools&lt;/a&gt; section lists useful tools for ooc development,
along with a typical workflow from the creation, compilation, testing, and
documentation of a project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/kaputt/&#34;&gt;Troubleshooting&lt;/a&gt; section gives advice on how
to address frequently encountered problems.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/glossary/&#34;&gt;Glossary&lt;/a&gt; is a collection of terms you may stumble
upon while using ooc or reading its documentation. If you don&amp;rsquo;t understand
a term, go here!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When you’re stuck with a question or a problem the documentation doesn’t
solve, considering posting to the &lt;a href=&#34;https://groups.google.com/group/ooc-lang&#34;&gt;discussion group&lt;/a&gt; or joining the
&lt;a href=&#34;irc://chat.freenode.net/#ooc-lang&#34;&gt;ooc-lang IRC channel&lt;/a&gt;. We’ll get it sorted out in no time. Check out the
&lt;a href=&#34;/community/&#34;&gt;Community&lt;/a&gt; page for details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Constructors</title>
      <link>http://oocmanual.cogneco.com/language/constructors</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/constructors</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Constructors&lt;/h1&gt;

&lt;p&gt;In ooc, unlike Java/Scala/C++/C#, &amp;lsquo;new&amp;rsquo; isn&amp;rsquo;t a keyword, but a static method.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    dog := Dog new(&amp;quot;Pif&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However it&amp;rsquo;s uncommon to directly define a new method. Instead, an init method is
defined, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func (=name) {}

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an &amp;lsquo;init&amp;rsquo; method is defined, a corresponding &amp;lsquo;new&amp;rsquo; static method is defined, in our case,
the code above is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func (name: String) {
            this name = name
        }

        new: static func (name: String) -&amp;gt; This {
            this := This alloc() as This
            this init()
            this
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;alloc&amp;rsquo; is a method of Class, which can be defined like this, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /// Create a new instance of the object of type defined by this class
    alloc: final func ~_class -&amp;gt; Object {
        object := gc_malloc(instanceSize) as Object
        if(object) {
            object class = this
        }
        return object
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In ooc implementations, Object and Class are often classes defined in .ooc source
files, so you can easily study their source code. You can typically find their definitions
in sdk/lang/ (because everything in the lang/ package is automatically imported)&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Reminder: member-arguments and assign-arguments&lt;/h2&gt;

&lt;p&gt;This:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the equivalent of this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (.value) {
            this value = value
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is the equivalent of this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (value: Int) {
            this value = value
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ie &amp;lsquo;.&amp;rsquo; allows &amp;lsquo;value&amp;rsquo;s type to be inferred from the member variable
of the same name, and &amp;lsquo;=&amp;rsquo; does the same plus assigns it in the constructor.&lt;/p&gt;

&lt;p&gt;This works for any method, not only for constructors. However, if you&amp;rsquo;re using
it for setters, you probably want to use properties instead.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Multiple constructors&lt;/h2&gt;

&lt;p&gt;As any method, constructors can be overloaded with suffixes.&lt;/p&gt;

&lt;p&gt;Suffixes may seem annoying at first, seen as a sort of &amp;lsquo;manual name mangling&amp;rsquo;,
but aside from helping to debug, they&amp;rsquo;re also a way to document the purpose of your
different constructors. For that reason, it&amp;rsquo;s always a good idea to give meaningful
suffixes that lets one hint the reason for existence of a constructor.&lt;/p&gt;

&lt;p&gt;From a constructor, you can call another constructor with init(), just like a regular
method.&lt;/p&gt;

&lt;p&gt;You can also call a super-constructor with super()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func ~defaultName {
            init(&amp;quot;The Man&amp;quot;)
        }

        init: func (=name) {}

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Inheritance&lt;/h2&gt;

&lt;p&gt;A common mistake is to think that constructor are inherited, because they are standard
methods. However, this behavior would be harmful, as explained in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Logger: class {
        prefix: String

        init: func (=prefix) {}

        log: func (msg: String) {
            &amp;quot;%s%s&amp;quot; printfln(prefix, msg)
        }
    }

    FileLogger: class extends Logger {
        output: FileWriter

        init: func ~withPath (path: String) {
            super(prefix)
            output = FileWriter new(path)
        }

        log: func (msg: String) {
            output write(prefix). write(msg). write(&#39;\n&#39;)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What would happen if the first constructor defined in Logger was available
for FileLogger? Let&amp;rsquo;s find out&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    warn := FileLogger new(&amp;quot;WARN&amp;quot;)
    warn log(&amp;quot;Somebody set us up the stacktrace&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The constructor call, if it was valid, would either return a Logger, which is
not what we want, or by some miracle trick, return a FileLogger - but one
that wouldn&amp;rsquo;t be properly initialized, so that log() would crash.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Super func (and beyond)&lt;/h2&gt;

&lt;p&gt;However, there are times when one truly wants to relay a constructor
in an inherited class, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Expression: abstract class {
        eval: abstract func -&amp;gt; Int
    }

    BinaryOp: abstract class extends Expression {
        left, right: Expression

        init: func ~lr (=left, =right) {}
    }

    Add: class extends BinaryOp {
        init: func ~lr (=left, =right) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeating the &amp;lsquo;init~lr&amp;rsquo; definition in Add violates the Don&amp;rsquo;t Repeat Yourself (DRY)
principle. Besides, if functionality is added to the base BinaryOp init~lr, it
wouldn&amp;rsquo;t be replicated in Add init~lr.&lt;/p&gt;

&lt;p&gt;For this precise case, the &amp;lsquo;super func&amp;rsquo; construct exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Add: class extends BinaryOp {
        init: super func ~lr
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This behaves exactly as if we had written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Add: class extends BinaryOp {
        init: func ~lr (.left, .right) {
            super(left, right)
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Covers vs Classes</title>
      <link>http://oocmanual.cogneco.com/language/covers-vs-classes</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/covers-vs-classes</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;When to use covers and classes&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Whenever possible, use classes.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re new to ooc, don&amp;rsquo;t use covers because you&amp;rsquo;ve heard they
are &amp;ldquo;faster&amp;rdquo;. Covers are powerful. Great power comes with great responsibility.
The sword cut both ways&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;By-reference, by-value&lt;/h2&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Classes&lt;/h2&gt;

&lt;p&gt;Classes are by-references. Which means every object is a reference. Doing that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: class {
        value: Int
        init: func (=value) {}
    }

    modifyRef: func (n: Number) {
        n = Number new(-1)
    }

    modifyInside: func (n: Number) {
        n value = -1
    }

    answer := Number new(42)
    modifyRef(answer) // does nothing
    modifyInside(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens in &amp;lsquo;modifyRef&amp;rsquo; is that we change the value of the parameter &amp;lsquo;n&amp;rsquo;.
The code does not modify what &amp;lsquo;n&amp;rsquo; was a reference to in the first place.
In the example above the variable &amp;lsquo;answer&amp;rsquo; is given as the argument and &amp;lsquo;modifyRef&amp;rsquo; has
no effect at all on &amp;lsquo;answer&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;However, in &amp;lsquo;modifyInside&amp;rsquo;, we actually modify the content of what &amp;lsquo;n&amp;rsquo; refers to.
Since &amp;lsquo;n&amp;rsquo; refers to &amp;lsquo;answer&amp;rsquo;, the code will modify its member &amp;lsquo;value&amp;rsquo; and set it to -1.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Covers&lt;/h2&gt;

&lt;p&gt;Covers are trickier. There are two types of covers: primitive covers and compound covers&lt;/p&gt;

&lt;p&gt;Primitive covers allow to us to add methods to an existing underlying type. For implementations
of ooc on top of C this means you can do stuff like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Int: cover from int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is actually the way all C types are used within ooc.&lt;/p&gt;

&lt;p&gt;As a consequence, covers are by-value. Which means that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    modify: func (i: Int) {
        i = -1
    }

    answer := 42
    modify(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doesn&amp;rsquo;t modify answer.&lt;/p&gt;

&lt;p&gt;But compound covers (you can think of them as structs) are also by value,
which means that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
    }

    modifyInside: func (n: Number) {
        n value = -1
    }

    answer: Number
    answer value = 42

    modifyInside(answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Won&amp;rsquo;t modify &amp;lsquo;answer&amp;rsquo; at all, but a &lt;em&gt;copy&lt;/em&gt; of it that has been
passed to &amp;lsquo;modifyInside&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;As an interesting side effect, a &amp;lsquo;clone&amp;rsquo; method is futile for covers.&lt;/p&gt;

&lt;p&gt;It also means that this won&amp;rsquo;t work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
        init: func (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because init will be working on a &lt;em&gt;copy&lt;/em&gt; of the object, thus leaving
the original object unmodified. That&amp;rsquo;s why func@ exists, ie.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Number: cover {
        value: Int
        init: func@ (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &amp;lsquo;this&amp;rsquo; will be passed by reference. Same goes for any cover method
that modifies its content.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Heap allocation, stack allocation&lt;/h2&gt;

&lt;p&gt;When you do&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NumberClass: class {}
    n := NumberClass new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n may be allocated on the heap or on the stack, however the compiler sees fit.&lt;/p&gt;

&lt;p&gt;However, with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NumberCover: cover {}
    n: NumberCover
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n is allocated on the stack.&lt;/p&gt;

&lt;p&gt;Choosing whether to allocate an object on the stack or on the heap is a
non-trivial decision. In C++ for example, it is the role of the programmer
to decide whether to allocate on the stack or on the heap.&lt;/p&gt;

&lt;p&gt;In ooc, it&amp;rsquo;s the role of the compiler. Until the language is properly
standardized and annotations are added for extern functions to allow
escape analysis, the compiler may choose to only allocate on the heap.&lt;/p&gt;

&lt;p&gt;Allocating on the stack is much faster (since it only involves moving
the stack pointer), and the stack is always hot, the memory you get when
allocating is much more likely to be in cache than any far heap allocated
memory.&lt;/p&gt;

&lt;p&gt;So why don&amp;rsquo;t we always allocate on the stack? Why do we even bother about
heap allocation, which involves all kinds of housekeeping to know which
memory blocks are reserved and which are free?&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Why stack allocation isn&amp;rsquo;t a silver bullet&lt;/h2&gt;

&lt;p&gt;A typical stack size for C programs on desktop OSes is between 1MB and 2MB.
Therefore, if you need to allocate big objects, you may run out of stack space.&lt;/p&gt;

&lt;p&gt;Running out of stack space is really something to be avoided. It&amp;rsquo;s a lot
harder to debug than heap allocation failures. When heap allocation fails,
you usually get back a null pointer, and tools (GDB, Valgrind) help figuring
out the cause.&lt;/p&gt;

&lt;p&gt;However, when you run out of stack space, the program usually crashes violently
with very little information about the situation that lead to the crash.
Even worse, it could corrupt data without crashing.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s more, often, when a program crashes because of a stack allocation failure,
the call stack is overwritten with random data, making it impossible to trace back
the origin of the problem.&lt;/p&gt;

&lt;p&gt;To add insult to injury, as far as I know, there is no reliable and portable way
to know how much free memory is left on the stack.&lt;/p&gt;

&lt;p&gt;For all those reasons, stack allocation is sometimes entirely avoided,
because it&amp;rsquo;s tricky to deal with manually.&lt;/p&gt;

&lt;p&gt;The following IBM DeveloperWorks article goes more in-depth into the issue:
&lt;a href=&#34;http://www.ibm.com/developerworks/java/library/j-jtp09275.html&#34;&gt;http://www.ibm.com/developerworks/java/library/j-jtp09275.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Stack and scope&lt;/h2&gt;

&lt;p&gt;But wait, there&amp;rsquo;s more! (assuming you&amp;rsquo;re still reading at that point)&lt;/p&gt;

&lt;p&gt;Stack-allocated variables are deallocated when they go out of scope.&lt;/p&gt;

&lt;p&gt;What does that mean? It means that this code is wrong.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    getAnswer: func -&amp;gt; Int* {
        // answer is allocated on the stack
        answer := 42
        // we&#39;re returning the address of a local variable
        // this is WRONG, don&#39;t do it.
        answer&amp;amp;
        // when the function returns, &#39;answer&#39; goes out of scope
        // and is deallocated
    }

    answerPtr := getAnswer()
    &amp;quot;answer = %d&amp;quot; printfln(answerPtr@)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas this one will work perfectly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    getAnswer: func -&amp;gt; Int* {
        // answer is allocated on the heap
        answer := gc_malloc(Int size)
        answer@ = 42
        // we&#39;re returning the address of a heap-allocated variable
        // no problem with that. the memory will be freed on a garbage
        // collector sweep phase, when it will have detected that
        // it&#39;s unused
        answer
    }

    answerPtr := getAnswer()
    &amp;quot;answer = %d&amp;quot; printfln(answerPtr@)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the first version (returning the address of a local variable)
might work sometimes: don&amp;rsquo;t be surprised. If the memory address (on the stack
or in a register) where the local variable was stored isn&amp;rsquo;t overwritten
between the return from the function and the time when it&amp;rsquo;s used, it might
still contain the original value. But, again - it&amp;rsquo;s wrong and unreliable.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;When to use stack allocation&lt;/h2&gt;

&lt;p&gt;For small objects for which you need by-value behavior and of which you use
gazillions in your application.&lt;/p&gt;

&lt;p&gt;Each project is a unique situation - as a rule, I&amp;rsquo;d always advise to begin
with a class, and turn it into a cover later if the situation requires it.&lt;/p&gt;

&lt;p&gt;However, keep in mind that allocation is often not the first place to look
if you want to optimize your application. Remember to always use a profiler
(I find that valgrind + KCachegrind work particularly well with ooc code)
to figure out where the hotspots are in your code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Covers</title>
      <link>http://oocmanual.cogneco.com/language/covers</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/covers</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Covers&lt;/h1&gt;

&lt;p&gt;One selling point of ooc is that it makes it easy to use C libraries which
design is object-oriented. Covers are one way to do that.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Struct-like covers&lt;/h1&gt;

&lt;p&gt;Covers are a by-value, lighter, lower-level alternative to classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Vec2: cover {
  x, y: Float

  norm: func -&amp;gt; Float {
    sqrt(x * x + y * y)
  }
}

v: Vec2
v x = 1.5
v y = 4
&amp;quot;Norm = %.2f&amp;quot; printfln(v norm())
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Covers from&lt;/h1&gt;

&lt;p&gt;Covers from are based on an external, C type, and provide a way to access
members of the external type (if it&amp;rsquo;s a struct), and to call methods on it -
either existing, external functions, or adding whole new methods.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Int: cover from int
UInt8: cover from uint8_t
LLong: cover from long long
UInt: cover from unsigned int
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Members&lt;/h1&gt;

&lt;p&gt;Members can be declared extern, like functions - which means they are defined
somewhere else and need to be accessed from ooc code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
CpFloat: cover from cpFloat

CpVect: cover from cpVect {
  x, y: extern CpFloat
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Members can be aliased by using the &lt;code&gt;extern(original_name)&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Rectangle: cover from bar_rectangle_t {
  width: extern(Width)
  height: extern(Height)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Methods&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;extern&lt;/code&gt; function can be used to describe cover methods as well. Aliasing is
often good practice, as it allows to get rid of the unnecessary prefixes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FooContext: cover from foo_context_t {
  // extern constructor
  new: static extern(foo_context_new) func (CString, Int) -&amp;gt; This

  // extern method
  doSomething: extern(foo_context_do_something) -&amp;gt; CString

  // additional method
  doSomethingTwice: func {
    doSomething()
    doSomething()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so, a properly covered C struct with methods can be used as if it was an object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
context := FooContext new()
context doSomething()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Glossary</title>
      <link>http://oocmanual.cogneco.com/glossary</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/glossary</guid>
      <description>&lt;p&gt;{{GLOSSARY}}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First-class Functions</title>
      <link>http://oocmanual.cogneco.com/language/first-class-functions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/first-class-functions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;First-class functions&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Functions are pieces of code that can take arguments, and return values.&lt;/p&gt;

&lt;p&gt;Named functions are declared with this syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;name&amp;gt; : func &amp;lt;arguments&amp;gt; &amp;lt;return type&amp;gt; {
        &amp;lt;body&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where arguments are comma-separated, enclosed between parenthesis, and return type
is prefixed with a right arrow -&amp;gt;.&lt;/p&gt;

&lt;p&gt;Arguments may be omitted if the function doesn&amp;rsquo;t take any, and return type
may be omitted too, if the function is void.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max: func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this is a valid expression too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    func &amp;lt;arguments&amp;gt; &amp;lt;return type&amp;gt; {
        &amp;lt;body&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with decl-assign, we can declare a variable named &amp;lsquo;max&amp;rsquo;, equal
to this expression. And then use it very much like a function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max := func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
    answer := max(-1, 42)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Differences between function and first-class functions&lt;/h2&gt;

&lt;p&gt;The first difference is: functions are immutable. First-class functions
are variables, and thus can be overwritten by simple assignment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // this is invalid: don&#39;t do that.
    someFunc: func {}
    someFunc = someOtherFunc

    // this, on the other hand, is valid
    someFunc := func {}
    someFunc = someOtherFunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second difference is: first-class functions can capture context.
Closures are first-class functions that capture context.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // here&#39;s a normal function
    clone: func (l: List&amp;lt;Int&amp;gt;) -&amp;gt; List&amp;lt;Int&amp;gt; {
        copy := ArrayList&amp;lt;Int&amp;gt; new(l size())
        l each(func(element: Int) {
            copy add(element)
        })
        copy
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, our anonymous, first-class function which also happens to be a closure, is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    func(element: Int) {
        copy add(element)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It captures the context because we access &amp;lsquo;copy&amp;rsquo; in it - which isn&amp;rsquo;t an
argument of the function, nor a variable declared inside the function.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s declared outside, and still we can access it - that&amp;rsquo;s what capturing
context is.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s sum up: first-class functions may be overwritten by assignment,
and may capture context.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;The type of first-class functions&lt;/h2&gt;

&lt;p&gt;So, when we do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max := func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What exactly is the type of &amp;lsquo;max&amp;rsquo; ?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s declare it in two steps  instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max : Func (Int, Int) -&amp;gt; Int
    max = func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Func&lt;/code&gt; is a type that has a special syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Func &amp;lt;argument types&amp;gt; &amp;lt;return type&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with regular functions declaration, both argument types and return types
can be omitted.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Type inference - ACS&lt;/h2&gt;

&lt;p&gt;Declaring the type of first-class functions is mostly useful in function arguments.&lt;/p&gt;

&lt;p&gt;For example, in the SDK, the declaration of each goes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    List: class &amp;lt;T&amp;gt; {
        each: func(f: Func (T)) {
            // ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it takes a function that takes one argument of type T&lt;/p&gt;

&lt;p&gt;Hence, clearly doing that in our clone function above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    l each(func(element: Int) {
        copy add(element)
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is unnecessary. Since we know that l is a List&lt;Int&gt;, and that each takes
a Func (T) then we know that element is of type Int.&lt;/p&gt;

&lt;p&gt;And thus, we can write that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    l each(|element|
        copy add(elements)
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The proper syntax for that is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(|&amp;lt;name of arguments&amp;gt;|
        &amp;lt;body&amp;gt;
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are no arguments, this is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(||
        &amp;lt;body&amp;gt;
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And is then equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(func {
        &amp;lt;body&amp;gt;
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return type is inferred as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Other differences - member functions vs member first-class functions&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        shout: func {
            &amp;quot;Woof woof&amp;quot; println()
        }

    }

    d := Dog new()
    d shout()

    Dog shout = func {
        &amp;quot;Ruff ruff&amp;quot; println()
    }
    d2 := Dog new()
    d shout()
    d2 shout()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Woof woof
    Ruff ruff
    Ruff ruff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When assigning &amp;lsquo;Dog shout&amp;rsquo;, we change the member method of &lt;em&gt;all&lt;/em&gt; past and
future Dog instances. This happens because &amp;lsquo;shout&amp;rsquo; is actually stored in the meta-class&lt;/p&gt;

&lt;p&gt;Consider the differences with that instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        shout := func {
            &amp;quot;Woof woof&amp;quot; println()
        }

    }

    d := Dog new()
    d shout()

    d shout = func {
        &amp;quot;Ruff ruff&amp;quot; println()
    }
    d2 := Dog new()
    d shout()
    d2 shout()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Woof woof
    Ruff ruff
    Woof woof
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &amp;lsquo;shout&amp;rsquo; is a member variable. Assigning to &amp;rsquo;d shout&amp;rsquo; changes it
only for that instance, so d2 shout isn&amp;rsquo;t changed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>http://oocmanual.cogneco.com/language/exceptions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/exceptions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Error handling&lt;/h1&gt;

&lt;p&gt;The C way to do error handling is usually via return codes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
openFile: (path: String) -&amp;gt; Int {
  if (error) {
    return -1
  }
  return someFileDescriptor
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, it relies on the user correctly checking the return value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
fd := openFile(&amp;quot;/etc/hosts&amp;quot;)
doSomethingWithFile(fd) // forgot to check, things might go bad!
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Exceptions&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;raise&lt;/h2&gt;

&lt;p&gt;Another way to handle that would be with exceptions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
openFile: (path: String) -&amp;gt; File {
  if (error) {
    raise(&amp;quot;Could not open %s&amp;quot; format(path))
  }
  return someFile
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That way, even if the user doesn&amp;rsquo;t explicitly check for the error, it&amp;rsquo;ll
still interrupt the flow of the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file := openFile(&amp;quot;/dev/does/not/exist&amp;quot;)
doSomethingWithFile(file) // we are never even going to reach there
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Throwing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;raise&lt;/code&gt; function above is a quick method to raise an exception. What
it really does is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Exception new(message) throw()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no special keyword to throw exceptions, it&amp;rsquo;s just a method on the
&lt;code&gt;Exception&lt;/code&gt; class.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Catching exceptions&lt;/h2&gt;

&lt;p&gt;Catching exceptions is done through the &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  openFile(&amp;quot;dev/does/not/exist&amp;quot;)
} catch (e: Exception) {
  // something wrong happened
  &amp;quot;Error: %s&amp;quot; printfln(e message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Exception sub-classes&lt;/h2&gt;

&lt;p&gt;It is possible to sub-class exceptions to have several exception types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FileNotFoundException: class extends Exception {
  init: func (path: String) {
    super(&amp;quot;File not found: %s&amp;quot; format(path))
  }
}

openFile: func (path: String) {
  if (error) {
    FileNotFoundException new(path) throw()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which makes it easy to catch a specific type of exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  file := openFile(&amp;quot;/dev/does/not/exist&amp;quot;)
  doSomethingWithFile(file)
} catch (e1: FileNotFoundException) {
  // The file wasn&#39;t found
} catch (e2: Exception) {
  // Something else went wrong.
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>exception</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/exceptions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/exceptions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Exception&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Exception&lt;/code&gt; class is the super-type of anything that can be thrown
and caught.&lt;/p&gt;

&lt;p&gt;There is no special keyword for throwing exceptions in ooc - instead, the
mechanism is implemented transparently thanks to the &lt;code&gt;throw()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
e := Exception new(&amp;quot;Something bad happened&amp;quot;)
e throw()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Message&lt;/h2&gt;

&lt;p&gt;A good exception will have a descriptive message. It can be accessed
via the &lt;code&gt;message&lt;/code&gt; field of the &lt;code&gt;Exception&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  attemptSomethingRisky()
} catch (e: Exception) {
  &amp;quot;Something bad happened, and here&#39;s what: %s&amp;quot; printfln(e message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Origin&lt;/h2&gt;

&lt;p&gt;It might be useful to know which class in particular has thrown an
exception. For this purpose, the &lt;code&gt;origin&lt;/code&gt; field exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
} catch (e: Exception) {
  &amp;quot;Something went wrong, and the culprit is: %s&amp;quot; \
    printfln(e origin ? e origin name : &amp;quot;unknown&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To have a default representation of an exception, like it would be
printed as if there was no try block to catch it, use &lt;code&gt;formatMessage()&lt;/code&gt;,
or, to print it, use &lt;code&gt;print()&lt;/code&gt; directly.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Backtrace&lt;/h2&gt;

&lt;p&gt;On platforms where it is implemented (currently, Linux with the &amp;ldquo;+-rdynamic&amp;rdquo;
compiler option), a series of backtrace can be available, containing info
about each stack frame leading up to the point the exception was thrown.&lt;/p&gt;

&lt;p&gt;The backtrace can be printed with the &lt;code&gt;printBacktrace()&lt;/code&gt; method. It&amp;rsquo;ll get
printed in the default representation, for example if there is no particular
exception handler.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Custom exceptions&lt;/h2&gt;

&lt;p&gt;To add a custom exception type, simply subclass &lt;code&gt;Exception&lt;/code&gt; and provide
a constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FunnyException: class extends Exception {
  init: func {
    super(&amp;quot;Nothing happened, just thought it&#39;d be fun to interrupt the program!&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>http://oocmanual.cogneco.com/language/functions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/functions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Functions&lt;/h1&gt;

&lt;p&gt;A parameterized piece of code is often packaged into a function.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example function that adds two numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func (a: Int, b: Int) -&amp;gt; Int {
  return a + b
}

add(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The syntax for function signatures is &lt;code&gt;NAME: func (ARG1, ARG2, ...) -&amp;gt; RETURNTYPE&lt;/code&gt;.
Both the argument definition list and the arrow return type parts are optional, in case
a function takes no argument, or returns nothing. Hence, the following definitions are
all perfectly equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func () -&amp;gt; Void {}
f: func -&amp;gt; Void {}
f: func () {}
f: func {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments of the same type may be listed in short form: &lt;code&gt;name1, name2, name3: Type&lt;/code&gt;.
Also, the &lt;code&gt;return&lt;/code&gt; keyword is optional - it is only required to exit of the normal
function flow early. Hence, the first example can be rewritten like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func (a, b: Int) -&amp;gt; Int {
  a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the absence of a &lt;code&gt;return&lt;/code&gt; keyword in the body of a non-void function, the last
expression will be returned. This works with ifs, matches, etc.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Main&lt;/h1&gt;

&lt;p&gt;Perhaps the most interesting function at first is the &lt;code&gt;main&lt;/code&gt; function, aka the
entry point of a program. If not defined, one will be implicitly created. For
example, the following is a valid ooc program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Hi, world!&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we don&amp;rsquo;t need to process command-line arguments, we can define the main function
simply like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func {
  &amp;quot;Hi, world!&amp;quot; println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that any could outside the main function (and outside class definitions, etc.)
will get executed before the code in the main function is. This gives a chance for
module to run initialization code (e.g. C libraries that need some routine to be called
before anything else, to set up stuff).&lt;/p&gt;

&lt;p&gt;If we do want command-line arguments, we can do it the C way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func (argv: Int, argc: CString*) {
  for (i in 0..argv) {
    arg = argc[i]
    &amp;quot;Got argument: %s&amp;quot; printfln(arg toString())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, we can use an array of strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func (args: String[]) {
  // and so on..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, we can use an ArrayList of Strings, if more convenient:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import structs/ArrayList
main: func (args: ArrayList&amp;lt;String&amp;gt;) {
  // etc.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that command line arguments might not be relevant for all ooc implementations.
One could imagine an ooc implementation that compiles down to JavaScript - in which
case, running in a browser, the command line arguments would always be empty.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Suffixes / overloading&lt;/h1&gt;

&lt;p&gt;Functions can have the same name, but different signatures (argument lists and
return type), as long as they have different suffixes. They can be called without
suffix, in which case the compiler will infer the right function to call, or
explicitly by specifying the suffix by hand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func ~ints (a, b: Int) -&amp;gt; Int { a + b }
add: func ~floats (a, b: Float) -&amp;gt; Float { a + b }

add(1, 2) // calls ~ints variant
add(3.14, 5.0) // calls ~floats variant
add~floats(3, 5) // explicit call
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Variable arguments&lt;/h1&gt;

&lt;p&gt;Special slot in the argument list, can only be at the end, purpose is to accept
any number of arguments.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;ooc varargs&lt;/h2&gt;

&lt;p&gt;Store the number of arguments, and the types of each argument. Syntax is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func (args: ...) {
  // body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Access &lt;code&gt;args count&lt;/code&gt; to know how many arguments were passed.
Use &lt;code&gt;args iterator()&lt;/code&gt; to be able to iterate through the arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAll: func (things: ...) {
  &amp;quot;Printing %d things&amp;quot; printfln(things count)
  iter := things iterator()

  while (iter hasNext?()) {
    T := iter getNextType()
    &amp;quot;The next argument is a %s&amp;quot; printfln(T name)

    match T {
      case Int =&amp;gt; &amp;quot;%d&amp;quot; printfln(iter next(Int))
      case Float =&amp;gt; &amp;quot;%.2f&amp;quot; printfln(iter next(Float))
      case =&amp;gt; &amp;quot;Unsupported type&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More simply, &lt;code&gt;each&lt;/code&gt; can be used on a &lt;code&gt;VarArgs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAll: func (things: ...) {
  things each(|thing|
    match thing {
      case i: Int =&amp;gt; &amp;quot;%d&amp;quot; printfln(i)
      case f: Float =&amp;gt; &amp;quot;%.2f&amp;quot; printfln(f)
      case =&amp;gt; &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;C varargs&lt;/h2&gt;

&lt;p&gt;Used by writing simply &lt;code&gt;...&lt;/code&gt; in the argument list, not &lt;code&gt;args: ...&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func (firstArg: Type, ...) {
  // body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only accessible through &lt;code&gt;va_start&lt;/code&gt;, &lt;code&gt;va_next&lt;/code&gt;, &lt;code&gt;va_end&lt;/code&gt;. See &lt;a href=&#34;http://en.wikipedia.org/wiki/Variadic_function&#34;&gt;Variadic
function&lt;/a&gt; on Wikipedia.&lt;/p&gt;

&lt;p&gt;Useful only to relay a variable number of arguments to an extern C function,
since &lt;code&gt;va_arg&lt;/code&gt; couldn&amp;rsquo;t work (can&amp;rsquo;t quote raw C types in ooc).&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
vprintf: extern (s: CString, ...)

printf: func (s: String, ...) -&amp;gt; This {
  list: VaList
  va_start(list, this)
  vprintf(s toCString(), list)
  va_end(list)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Extern functions&lt;/h1&gt;

&lt;p&gt;To call a function defined elsewhere, for example in a C library, its prototype
needs to be defined&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exit: extern func (Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lazy way: type-only args, thorough way: variable-decl-args.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exit: extern func (exitCode: Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;By-ref parameters&lt;/h1&gt;

&lt;p&gt;Instead of having to dereference each time the parameter is accessed, just declare
it as a reference type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
increment: func (a: Int*) { a@ += 1 }
// vs
increment: func (a: Int@) { a += 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saves typing, saves error, clearer code. Can still access the address via &lt;code&gt;argument&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Closures&lt;/h1&gt;

&lt;p&gt;A very concise way to pass a function as an argument. &lt;code&gt;each&lt;/code&gt; is a typical
example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// definition
List: class &amp;lt;T&amp;gt; {
  each: func (f: Func (T)) { /* ... */ }
}

// usage
list := List&amp;lt;Int&amp;gt; new()
list each(|elem|
  // do something with elem, of type Int
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also works with several parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// definition
Map: class &amp;lt;K, V&amp;gt; {
  each: func (f: Func (K, V)) { /* ... */ }
}

// usage
map := Map&amp;lt;String, Horse&amp;gt; new()
map each(|key, value|
  // key is of type String, value is of type Horse
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Argument types are inferred, hence, the code is very short.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Operators</title>
      <link>http://oocmanual.cogneco.com/language/operators</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/operators</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Foreword&lt;/h1&gt;

&lt;p&gt;This lists all ooc operators, from highest precendence to lowest precedence&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Access&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Array access&lt;/h2&gt;

&lt;p&gt;The array-index operator is &lt;code&gt;[]&lt;/code&gt;, the array-modify operator&amp;rsquo;s short form is &lt;code&gt;[]=&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
arr[0] = &#39;\n&#39;
return arr[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Pointers&lt;/h2&gt;

&lt;p&gt;The address-of operator is a post-fix &lt;code&gt;&amp;amp;&lt;/code&gt;, the dereference operator is a post-fix
&lt;code&gt;@&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
a := 42
aPtr := a&amp;amp;
aToo := aPtr@
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Call&lt;/h2&gt;

&lt;p&gt;Technically not an operator, but call is in that priority level:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
a := func -&amp;gt; Int { 42 }
a()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Member access&lt;/h2&gt;

&lt;p&gt;Also technically not an operator. Simply two identifiers side by side,
not using dot, unlike some other programming languages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
dog name
dog race
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Casting&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; operator is used to cast from one type to the other:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pi := 3.14
roughlyPi := pi as Int
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Product&lt;/h1&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Binary operators&lt;/h2&gt;

&lt;p&gt;The exponent operator is &lt;code&gt;**&lt;/code&gt;, the multiplication operator is &lt;code&gt;*&lt;/code&gt;,
and the division operator is &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Unary operators&lt;/h2&gt;

&lt;p&gt;Logical not is a prefixed &lt;code&gt;!&lt;/code&gt;, binary not is a prefixed &lt;code&gt;~&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;Sum&lt;/h1&gt;

&lt;p&gt;The addition operator is &lt;code&gt;+&lt;/code&gt;, subtraction is &lt;code&gt;-&lt;/code&gt;,
modulo is &lt;code&gt;%&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;Shift&lt;/h1&gt;

&lt;p&gt;Right shift is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, left shift is &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;Inequality&lt;/h1&gt;

&lt;p&gt;You have your regular less than &lt;code&gt;&amp;lt;&lt;/code&gt;, greater than &lt;code&gt;&amp;gt;&lt;/code&gt;,
less than or equal &lt;code&gt;&amp;lt;=&lt;/code&gt;, more than or equal &lt;code&gt;&amp;gt;=&lt;/code&gt;,
but also the comparison operator &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; (evaluates to -1
if less than, 0 if equal, 1 if greater than).&lt;/p&gt;

&lt;h1 id=&#34;toc_13&#34;&gt;Equality&lt;/h1&gt;

&lt;p&gt;Equality operator is &lt;code&gt;==&lt;/code&gt;, inequality operator is &lt;code&gt;!=&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_14&#34;&gt;Binary and boolean operations&lt;/h1&gt;

&lt;p&gt;Binary and is &lt;code&gt;&amp;amp;&lt;/code&gt;, xor is &lt;code&gt;^&lt;/code&gt;, or is &lt;code&gt;|&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Logical and is &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, logical or is &lt;code&gt;||&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;Ternary&lt;/h1&gt;

&lt;p&gt;The ternary operator is &lt;code&gt;?:&lt;/code&gt; as in &lt;code&gt;condition ? ifTrue : ifFalse&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;Assignment&lt;/h1&gt;

&lt;p&gt;The assignment operator is &lt;code&gt;=&lt;/code&gt;, the following variants exist:
&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;**=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The declare-assignment operator is &lt;code&gt;:=&lt;/code&gt;. And the declare-property-assignment
operator is &lt;code&gt;::=&lt;/code&gt;. For more details on these, see the &lt;a href=&#34;/docs/lang/values/#variables&#34;&gt;Variables&lt;/a&gt; and
&lt;a href=&#34;/docs/lang/classes/#properties&#34;&gt;Properties&lt;/a&gt; pages.&lt;/p&gt;

&lt;h1 id=&#34;toc_17&#34;&gt;Double arrow&lt;/h1&gt;

&lt;p&gt;The double arrow operator &lt;code&gt;=&amp;gt;&lt;/code&gt; - it must be overloaded.&lt;/p&gt;

&lt;h1 id=&#34;toc_18&#34;&gt;Operator overloading&lt;/h1&gt;

&lt;p&gt;Overloading an operator can be done as a function-like, using the
&lt;code&gt;operator&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
operator + (v1, v2: Vec2) -&amp;gt; Vec2 { v1 add(v2) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if the operator is linked to a type, it&amp;rsquo;s better to declare
it in the type itself, so that it&amp;rsquo;ll be usable even if the module containing
the type declaration isn&amp;rsquo;t explicitly imported:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Vec2: class {
  // other stuff

  operator + (v: This) -&amp;gt; This { add(v) }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mmap</title>
      <link>http://oocmanual.cogneco.com/sdk/os/mmap</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/mmap</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/mmap module&lt;/h1&gt;

&lt;p&gt;As it stands, the &lt;code&gt;os/mmap&lt;/code&gt; module just exposes the *nix functions for memory
mapping: &lt;code&gt;mmap&lt;/code&gt;, &lt;code&gt;munmap&lt;/code&gt;, &lt;code&gt;mprotect&lt;/code&gt;, &lt;code&gt;madvise&lt;/code&gt;, &lt;code&gt;mincore&lt;/code&gt;, &lt;code&gt;minherit&lt;/code&gt;,
&lt;code&gt;msync&lt;/code&gt;, &lt;code&gt;mlock&lt;/code&gt;, and &lt;code&gt;munlock&lt;/code&gt;, along with the associated constants.&lt;/p&gt;

&lt;p&gt;It also contains prototypes / covers for the Windows equivalent,
&lt;code&gt;VirtualProtect&lt;/code&gt;, and its constants as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;This module is not a high-level or cross-platform interface and is not
documented extensively here.&lt;/p&gt;

&lt;p&gt;However, to find more information on memory mapping for various platform
see here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap on Wikipedia&lt;/a&gt; (for *nix platforms)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/windows/desktop/aa366898(v=vs.85).aspx&#34;&gt;VirtualProtect on MSDN&lt;/a&gt; (for Windows)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On a historical note, this module was originally included in the SDK as support
code for the closure implementation, which back then implied generating
bytecode at runtime and thus marking some memory regions as executable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Control Structures</title>
      <link>http://oocmanual.cogneco.com/language/control-structures</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/control-structures</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Conditionals&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;if / else&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s your traditional if, else if, else structure. The body should be either
a single statement, or a scope.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
if (off) turnOn()

if (stressed) {
    breatheIn()
    breatheOut()
} else if (tired) {
    rest()
} else {
    allGood()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The condition can be of type &lt;code&gt;Bool&lt;/code&gt; or a Pointer, in which case it will evaluate to
&lt;code&gt;true&lt;/code&gt; if it is non-null.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;match / case&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; is ooc&amp;rsquo;s &lt;code&gt;switch&lt;/code&gt;, loosely modelled after Scala&amp;rsquo;s. In its simplest form, it tests for equality between an expression and several values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match (numFeets) {
    case 1 =&amp;gt; &amp;quot;Ouch&amp;quot;
    case 2 =&amp;gt; &amp;quot;Normal&amp;quot;
    case =&amp;gt;
        // what?
        raise(&amp;quot;Too many feet&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each case is a scope of its own - it doesn&amp;rsquo;t require braces. A case with no
expression is a catch-all.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; also works with any class T that implements the method &lt;code&gt;matches?: func
-&amp;gt; (other: T) -&amp;gt; Bool&lt;/code&gt;. Another way to get complex types to work in matches
is simply to override the &lt;code&gt;==&lt;/code&gt; operator. Hence, Strings work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match keyword {
    case &amp;quot;if&amp;quot; =&amp;gt;
        Keyword IF
    case &amp;quot;match&amp;quot; =&amp;gt;
        Keyword MATCH
    case =&amp;gt;
        Keyword UNKNOWN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; is also a good way to avoid explicit casting, by matching an object
against variable declarations, one can use its specific form directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
result := match (op) {
    case plus: Plus =&amp;gt;
        plus lhs + plus rhs
    case minus: Minus =&amp;gt;
        minus lhs - minus rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;match&lt;/code&gt; is an expression, if every case ends with an expression. Hence, a
match can be used as a return value, or in a function call, on the right hand
side of a declaration-assignment (&lt;code&gt;:=&lt;/code&gt;), as demonstrated above.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Loops&lt;/h1&gt;

&lt;p&gt;Loops are structures that control the repetition of a body of code.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;break / continue&lt;/h2&gt;

&lt;p&gt;Two particular keywords are of interest when writing loops:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; immediately exits the loop, skipping the rest of the body
and not executing any further iteration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; skips over the rest of the body and begins the next
iteration immediately&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;while&lt;/h2&gt;

&lt;p&gt;Checks the condition - if false, skips the body. If true, runs the body,
then checks the condition again, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (!satisfied) {
    buyStuff()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;for&lt;/h2&gt;

&lt;p&gt;There is no C-like &lt;code&gt;for&lt;/code&gt; in ooc, only a foreach. It can iterate through
values like ranges:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (i in 1..10) {
    &amp;quot;Counting to %d&amp;quot; printfln(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or more complex data structures:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (element in list) {
    &amp;quot;Element = %s&amp;quot; printfln(element toString())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an object to be iterable, it has to implement the
&lt;code&gt;iterator: func &amp;lt;T&amp;gt; -&amp;gt; Iterator&amp;lt;T&amp;gt;&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;A variant of foreach allows one to get the index of the current element:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for ((index, element) in list) {
    &amp;quot;list[%d] = %s&amp;quot; printfln(index, element toString())
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Advanced Usage</title>
      <link>http://oocmanual.cogneco.com/tools/rock/advanced</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/advanced</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Using more Rock options&lt;/h1&gt;

&lt;p&gt;Often, rock does the right thing by itself, but if it doesn&amp;rsquo;t, you can use some of these more
advanced options and flags.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Keep the C sources&lt;/h1&gt;

&lt;p&gt;If rock somehow generates invalid C code and you want to know why, it can be helpful to actually
take a look at all the C. Normally, rock deletes everything it has generated at exit, but you can
tell rock to keep the sources for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock --noclean ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Afterwards, you&amp;rsquo;ll find the C source files in corresponding subdirectories of &lt;code&gt;rock_tmp&lt;/code&gt;. The header
files reside in &lt;code&gt;.libs&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;More information&lt;/h1&gt;

&lt;p&gt;Also useful in these cases: Let rock tell its story of compilation. That means: print everything about
all stages of symbol resolution and code generation. Invoke rock with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -vv ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Ditch gcc for your compiler of choice&lt;/h1&gt;

&lt;p&gt;Since gcc is the evergreen of compilers, rock uses it by default. In case you want to use something else
to turn your C sources into machine code, rock provides you with some alternatives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock --gcc # if you change your mind
rock --tcc # the tiny c compiler
rock --icc # the intel c compiler
rock --clang # llvm&#39;s clang
rock --onlygen # no compiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The latter is especially useful if you want to compile your C code to assembler by hand.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dynlib</title>
      <link>http://oocmanual.cogneco.com/sdk/os/dynlib</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/dynlib</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Dynlib module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Dynlib&lt;/code&gt; module allows one to load dynamic libraries on all
major platforms.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s open a library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Dynlib

lib := Dynlib load(&amp;quot;libm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t need to specify the &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dynlib&lt;/code&gt;, or &lt;code&gt;.dll&lt;/code&gt; extension here, it is
set automatically by platform, although the original path will be tested first,
in case of non-standard file extension.&lt;/p&gt;

&lt;p&gt;If the lib returned is null, it wasn&amp;rsquo;t found or couldn&amp;rsquo;t be opened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
if (!lib) {
    raise(&amp;quot;Couldn&#39;t load library!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then retrieve a symbol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cosAddr := lib symbol(&amp;quot;cos&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And cast it to a more useful function. Since &lt;code&gt;Func&lt;/code&gt; is actually
a function pointer and a context, we use a cover literal, passing
null for the context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cos := (cosAddr, null) as Func (Double) -&amp;gt; Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which we can then use!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;cos(PI / 4) = %.3f&amp;quot; printfln(cos(3.14 * 0.25))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This prints &lt;code&gt;cos(PI / 4) = 0.707&lt;/code&gt;, as expected.&lt;/p&gt;

&lt;p&gt;When we&amp;rsquo;re done with the library we can just close it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
lib close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: on Windows, failing to close a library may lead to a
crash on application exit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>string</title>
      <link>http://oocmanual.cogneco.com/sdk/lang/string</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/lang/string</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;String&lt;/h1&gt;

&lt;p&gt;A string in ooc is a chain of bytes with no particular property.
In most cases, you&amp;rsquo;ll want to deal with UTF-8 encoded strings.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;String&lt;/code&gt; type is the full-blown ooc String - it is a pascal
string in the sense that the length is stored with it. It is
backed by the &lt;code&gt;Buffer&lt;/code&gt; type, which contains the actual bytes.&lt;/p&gt;

&lt;p&gt;Buffers are mutable, whereas Strings are immutable. Therefore,
to build up a long String from several elements, using &lt;code&gt;Buffer&lt;/code&gt;
is preferable.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h2&gt;

&lt;p&gt;The size of a String can be retrieved through the &lt;code&gt;size&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;dumb luck&amp;quot; size == 9 // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Tests&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;startsWith?&lt;/code&gt; and &lt;code&gt;endsWith?&lt;/code&gt; do exactly what they sound like.
&lt;code&gt;equals?&lt;/code&gt; tests for equality, and is aliased to the &lt;code&gt;==&lt;/code&gt; operator
and, for non-equality, the &lt;code&gt;!=&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;moonlight&amp;quot; startsWith?(&amp;quot;moon&amp;quot;) // true
&amp;quot;lightscape&amp;quot; endsWith?(&amp;quot;scape&amp;quot;) // true

&amp;quot;moon&amp;quot; == &amp;quot;moon&amp;quot; // true
&amp;quot;light&amp;quot; != &amp;quot;darkness&amp;quot; // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Indexing&lt;/h2&gt;

&lt;p&gt;One can retrieve the n-th byte with the array indexing operator, &lt;code&gt;[]&lt;/code&gt;
and an integer value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;abcdef&amp;quot;[2] // == &#39;c&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the indexes are 0-based, like arrays.&lt;/p&gt;

&lt;p&gt;To iterate through each byte of a String, a foreach can be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Let&#39;s spell!&amp;quot; println()
for (c in &amp;quot;violin&amp;quot;) {
  &amp;quot;%c, &amp;quot; printfln(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Formatting and printing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;format&lt;/code&gt; method can be used to format a string with various
elements such as integers, floats, other strings, etc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;%d&amp;quot; format(42) // == &amp;quot;42&amp;quot;
&amp;quot;%.2f&amp;quot; format(3.1567) // == &amp;quot;3.16&amp;quot;
&amp;quot;%s&amp;quot; format(&amp;quot;Hi!&amp;quot;) // == &amp;quot;Hi!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;print&lt;/code&gt; method will print a string to the standard output.
Since it is so convenient to print a string followed by a newline,
&lt;code&gt;println&lt;/code&gt; does exactly that. And since formatting is often used,
&lt;code&gt;printfln&lt;/code&gt; does formatting, then print the result followed by a newline.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Hello world!\n&amp;quot; print()
// is equivalent to:
&amp;quot;Hello world!&amp;quot; println()
// itself equivalent to:
&amp;quot;Hello %s!&amp;quot; printfln(&amp;quot;world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Concatenation&lt;/h2&gt;

&lt;p&gt;One can use the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;prepend&lt;/code&gt; methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;light&amp;quot; prepend(&amp;quot;moon&amp;quot;) // == &amp;quot;moonlight&amp;quot;
&amp;quot;storm&amp;quot; append(&amp;quot;born&amp;quot;) // == &amp;quot;stormborn&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply, the &lt;code&gt;+&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;not&amp;quot; + &amp;quot;with&amp;quot; + &amp;quot;standing&amp;quot; // == &amp;quot;notwithstanding&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Finding and replacing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;indexOf&lt;/code&gt; method returns the index of a character or string inside
a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;abcdef&amp;quot; indexOf?(&#39;c&#39;) // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;replaceAll&lt;/code&gt;, one can replace all instances of a String with
another String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// yields &amp;quot;Brother | father | lover.&amp;quot;
&amp;quot;Brother, father, lover.&amp;quot; replaceAll(&amp;quot;,&amp;quot;, &amp;quot; |&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Slicing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;substring&lt;/code&gt; method allows one to get a slice of a String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;observe&amp;quot; substring(2) // == &amp;quot;serve&amp;quot;
&amp;quot;laminate&amp;quot; substring(2, 5) // == &amp;quot;min&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, the array indexing operator, &lt;code&gt;[]&lt;/code&gt;, can be used
with a range literal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;observe&amp;quot;[2..-1] // == &amp;quot;serve&amp;quot;
&amp;quot;laminate&amp;quot;[2..5] // == &amp;quot;min&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Trimming&lt;/h2&gt;

&lt;p&gt;To get rid of extra whitespace, use the &lt;code&gt;trim&lt;/code&gt; method, or its variants,
&lt;code&gt;trimLeft&lt;/code&gt; and &lt;code&gt;trimRight&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;  Hi!  &amp;quot; trim() // = &amp;quot;Hi!&amp;quot;
&amp;quot;  Hi!  &amp;quot; trimLeft() // = &amp;quot;Hi!  &amp;quot;
&amp;quot;  Hi!  &amp;quot; trimRight() // = &amp;quot;  Hi!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They also have versions that accept which characters to trim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;[Hola.]&amp;quot; trim() // = &amp;quot;[Hola.]&amp;quot;
&amp;quot;[Hola.]&amp;quot; trim(&amp;quot;[]()&amp;quot;) // = &amp;quot;Hola.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;CString&lt;/h1&gt;

&lt;p&gt;While a pure ooc program will want to deal mostyl with &lt;code&gt;String&lt;/code&gt;s,
when dealing with C functions, one will want to convert back and forth
with &lt;code&gt;toCString()&lt;/code&gt;, which gives a &lt;code&gt;CString&lt;/code&gt;, a cover of &lt;code&gt;char*&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Conversely, converting a CString to a String can be done with &lt;code&gt;toString()&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>