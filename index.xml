<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Exceptions</title>
      <link>http://oocmanual.cogneco.com/language/exceptions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/exceptions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Error handling&lt;/h1&gt;

&lt;p&gt;The C way to do error handling is usually via return codes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
openFile: (path: String) -&amp;gt; Int {
  if (error) {
    return -1
  }
  return someFileDescriptor
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, it relies on the user correctly checking the return value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
fd := openFile(&amp;quot;/etc/hosts&amp;quot;)
doSomethingWithFile(fd) // forgot to check, things might go bad!
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Exceptions&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;raise&lt;/h2&gt;

&lt;p&gt;Another way to handle that would be with exceptions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
openFile: (path: String) -&amp;gt; File {
  if (error) {
    raise(&amp;quot;Could not open %s&amp;quot; format(path))
  }
  return someFile
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That way, even if the user doesn&amp;rsquo;t explicitly check for the error, it&amp;rsquo;ll
still interrupt the flow of the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file := openFile(&amp;quot;/dev/does/not/exist&amp;quot;)
doSomethingWithFile(file) // we are never even going to reach there
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Throwing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;raise&lt;/code&gt; function above is a quick method to raise an exception. What
it really does is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Exception new(message) throw()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no special keyword to throw exceptions, it&amp;rsquo;s just a method on the
&lt;code&gt;Exception&lt;/code&gt; class.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Catching exceptions&lt;/h2&gt;

&lt;p&gt;Catching exceptions is done through the &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  openFile(&amp;quot;dev/does/not/exist&amp;quot;)
} catch (e: Exception) {
  // something wrong happened
  &amp;quot;Error: %s&amp;quot; printfln(e message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Exception sub-classes&lt;/h2&gt;

&lt;p&gt;It is possible to sub-class exceptions to have several exception types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FileNotFoundException: class extends Exception {
  init: func (path: String) {
    super(&amp;quot;File not found: %s&amp;quot; format(path))
  }
}

openFile: func (path: String) {
  if (error) {
    FileNotFoundException new(path) throw()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which makes it easy to catch a specific type of exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
try {
  file := openFile(&amp;quot;/dev/does/not/exist&amp;quot;)
  doSomethingWithFile(file)
} catch (e1: FileNotFoundException) {
  // The file wasn&#39;t found
} catch (e2: Exception) {
  // Something else went wrong.
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Manual</title>
      <link>http://oocmanual.cogneco.com/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;How to use the documentation&lt;/h1&gt;

&lt;p&gt;The documentation for ooc is structured as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tutorial/&#34;&gt;Tutorial&lt;/a&gt; is a ten minute journey meant for
newcomers to the language. By building a small program, you will learn the
basics of the syntax and even use bits of the SDK.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/lang/&#34;&gt;Language&lt;/a&gt; section explains in detail every feature
of the language: it goes through the syntax and a the main use cases for
every feature. It also contains a full grammar, and a collection of best
practices.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/sdk/&#34;&gt;SDK&lt;/a&gt; section gives an overview of the modules included
with the default ooc distribution. Whether you need access to files, to
measure time, to do some networking, or simply use common data structures,
the SDK is packed with goodness.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/&#34;&gt;Tools&lt;/a&gt; section lists useful tools for ooc development,
along with a typical workflow from the creation, compilation, testing, and
documentation of a project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/kaputt/&#34;&gt;Troubleshooting&lt;/a&gt; section gives advice on how
to address frequently encountered problems.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/glossary/&#34;&gt;Glossary&lt;/a&gt; is a collection of terms you may stumble
upon while using ooc or reading its documentation. If you don&amp;rsquo;t understand
a term, go here!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When you’re stuck with a question or a problem the documentation doesn’t
solve, considering posting to the &lt;a href=&#34;https://groups.google.com/group/ooc-lang&#34;&gt;discussion group&lt;/a&gt; or joining the
&lt;a href=&#34;irc://chat.freenode.net/#ooc-lang&#34;&gt;ooc-lang IRC channel&lt;/a&gt;. We’ll get it sorted out in no time. Check out the
&lt;a href=&#34;/community/&#34;&gt;Community&lt;/a&gt; page for details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First-class Functions</title>
      <link>http://oocmanual.cogneco.com/language/first-class-functions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/first-class-functions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;First-class functions&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Functions are pieces of code that can take arguments, and return values.&lt;/p&gt;

&lt;p&gt;Named functions are declared with this syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;name&amp;gt; : func &amp;lt;arguments&amp;gt; &amp;lt;return type&amp;gt; {
        &amp;lt;body&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where arguments are comma-separated, enclosed between parenthesis, and return type
is prefixed with a right arrow -&amp;gt;.&lt;/p&gt;

&lt;p&gt;Arguments may be omitted if the function doesn&amp;rsquo;t take any, and return type
may be omitted too, if the function is void.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max: func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this is a valid expression too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    func &amp;lt;arguments&amp;gt; &amp;lt;return type&amp;gt; {
        &amp;lt;body&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with decl-assign, we can declare a variable named &amp;lsquo;max&amp;rsquo;, equal
to this expression. And then use it very much like a function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max := func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
    answer := max(-1, 42)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Differences between function and first-class functions&lt;/h2&gt;

&lt;p&gt;The first difference is: functions are immutable. First-class functions
are variables, and thus can be overwritten by simple assignment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // this is invalid: don&#39;t do that.
    someFunc: func {}
    someFunc = someOtherFunc

    // this, on the other hand, is valid
    someFunc := func {}
    someFunc = someOtherFunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second difference is: first-class functions can capture context.
Closures are first-class functions that capture context.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // here&#39;s a normal function
    clone: func (l: List&amp;lt;Int&amp;gt;) -&amp;gt; List&amp;lt;Int&amp;gt; {
        copy := ArrayList&amp;lt;Int&amp;gt; new(l size())
        l each(func(element: Int) {
            copy add(element)
        })
        copy
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, our anonymous, first-class function which also happens to be a closure, is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    func(element: Int) {
        copy add(element)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It captures the context because we access &amp;lsquo;copy&amp;rsquo; in it - which isn&amp;rsquo;t an
argument of the function, nor a variable declared inside the function.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s declared outside, and still we can access it - that&amp;rsquo;s what capturing
context is.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s sum up: first-class functions may be overwritten by assignment,
and may capture context.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;The type of first-class functions&lt;/h2&gt;

&lt;p&gt;So, when we do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max := func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What exactly is the type of &amp;lsquo;max&amp;rsquo; ?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s declare it in two steps  instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    max : Func (Int, Int) -&amp;gt; Int
    max = func (a, b: Int) -&amp;gt; Int {
        a &amp;gt; b ? a : b
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Func&lt;/code&gt; is a type that has a special syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Func &amp;lt;argument types&amp;gt; &amp;lt;return type&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with regular functions declaration, both argument types and return types
can be omitted.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Type inference - ACS&lt;/h2&gt;

&lt;p&gt;Declaring the type of first-class functions is mostly useful in function arguments.&lt;/p&gt;

&lt;p&gt;For example, in the SDK, the declaration of each goes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    List: class &amp;lt;T&amp;gt; {
        each: func(f: Func (T)) {
            // ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it takes a function that takes one argument of type T&lt;/p&gt;

&lt;p&gt;Hence, clearly doing that in our clone function above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    l each(func(element: Int) {
        copy add(element)
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is unnecessary. Since we know that l is a List&lt;Int&gt;, and that each takes
a Func (T) then we know that element is of type Int.&lt;/p&gt;

&lt;p&gt;And thus, we can write that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    l each(|element|
        copy add(elements)
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The proper syntax for that is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(|&amp;lt;name of arguments&amp;gt;|
        &amp;lt;body&amp;gt;
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are no arguments, this is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(||
        &amp;lt;body&amp;gt;
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And is then equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    call(func {
        &amp;lt;body&amp;gt;
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return type is inferred as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Other differences - member functions vs member first-class functions&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        shout: func {
            &amp;quot;Woof woof&amp;quot; println()
        }

    }

    d := Dog new()
    d shout()

    Dog shout = func {
        &amp;quot;Ruff ruff&amp;quot; println()
    }
    d2 := Dog new()
    d shout()
    d2 shout()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Woof woof
    Ruff ruff
    Ruff ruff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When assigning &amp;lsquo;Dog shout&amp;rsquo;, we change the member method of &lt;em&gt;all&lt;/em&gt; past and
future Dog instances. This happens because &amp;lsquo;shout&amp;rsquo; is actually stored in the meta-class&lt;/p&gt;

&lt;p&gt;Consider the differences with that instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        shout := func {
            &amp;quot;Woof woof&amp;quot; println()
        }

    }

    d := Dog new()
    d shout()

    d shout = func {
        &amp;quot;Ruff ruff&amp;quot; println()
    }
    d2 := Dog new()
    d shout()
    d2 shout()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Woof woof
    Ruff ruff
    Woof woof
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &amp;lsquo;shout&amp;rsquo; is a member variable. Assigning to &amp;rsquo;d shout&amp;rsquo; changes it
only for that instance, so d2 shout isn&amp;rsquo;t changed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>http://oocmanual.cogneco.com/language/functions</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/functions</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Functions&lt;/h1&gt;

&lt;p&gt;A parameterized piece of code is often packaged into a function.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example function that adds two numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func (a: Int, b: Int) -&amp;gt; Int {
  return a + b
}

add(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The syntax for function signatures is &lt;code&gt;NAME: func (ARG1, ARG2, ...) -&amp;gt; RETURNTYPE&lt;/code&gt;.
Both the argument definition list and the arrow return type parts are optional, in case
a function takes no argument, or returns nothing. Hence, the following definitions are
all perfectly equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func () -&amp;gt; Void {}
f: func -&amp;gt; Void {}
f: func () {}
f: func {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments of the same type may be listed in short form: &lt;code&gt;name1, name2, name3: Type&lt;/code&gt;.
Also, the &lt;code&gt;return&lt;/code&gt; keyword is optional - it is only required to exit of the normal
function flow early. Hence, the first example can be rewritten like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func (a, b: Int) -&amp;gt; Int {
  a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the absence of a &lt;code&gt;return&lt;/code&gt; keyword in the body of a non-void function, the last
expression will be returned. This works with ifs, matches, etc.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Main&lt;/h1&gt;

&lt;p&gt;Perhaps the most interesting function at first is the &lt;code&gt;main&lt;/code&gt; function, aka the
entry point of a program. If not defined, one will be implicitly created. For
example, the following is a valid ooc program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Hi, world!&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we don&amp;rsquo;t need to process command-line arguments, we can define the main function
simply like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func {
  &amp;quot;Hi, world!&amp;quot; println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that any could outside the main function (and outside class definitions, etc.)
will get executed before the code in the main function is. This gives a chance for
module to run initialization code (e.g. C libraries that need some routine to be called
before anything else, to set up stuff).&lt;/p&gt;

&lt;p&gt;If we do want command-line arguments, we can do it the C way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func (argv: Int, argc: CString*) {
  for (i in 0..argv) {
    arg = argc[i]
    &amp;quot;Got argument: %s&amp;quot; printfln(arg toString())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, we can use an array of strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
main: func (args: String[]) {
  // and so on..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, we can use an ArrayList of Strings, if more convenient:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import structs/ArrayList
main: func (args: ArrayList&amp;lt;String&amp;gt;) {
  // etc.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that command line arguments might not be relevant for all ooc implementations.
One could imagine an ooc implementation that compiles down to JavaScript - in which
case, running in a browser, the command line arguments would always be empty.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Suffixes / overloading&lt;/h1&gt;

&lt;p&gt;Functions can have the same name, but different signatures (argument lists and
return type), as long as they have different suffixes. They can be called without
suffix, in which case the compiler will infer the right function to call, or
explicitly by specifying the suffix by hand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
add: func ~ints (a, b: Int) -&amp;gt; Int { a + b }
add: func ~floats (a, b: Float) -&amp;gt; Float { a + b }

add(1, 2) // calls ~ints variant
add(3.14, 5.0) // calls ~floats variant
add~floats(3, 5) // explicit call
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Variable arguments&lt;/h1&gt;

&lt;p&gt;Special slot in the argument list, can only be at the end, purpose is to accept
any number of arguments.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;ooc varargs&lt;/h2&gt;

&lt;p&gt;Store the number of arguments, and the types of each argument. Syntax is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func (args: ...) {
  // body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Access &lt;code&gt;args count&lt;/code&gt; to know how many arguments were passed.
Use &lt;code&gt;args iterator()&lt;/code&gt; to be able to iterate through the arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAll: func (things: ...) {
  &amp;quot;Printing %d things&amp;quot; printfln(things count)
  iter := things iterator()

  while (iter hasNext?()) {
    T := iter getNextType()
    &amp;quot;The next argument is a %s&amp;quot; printfln(T name)

    match T {
      case Int =&amp;gt; &amp;quot;%d&amp;quot; printfln(iter next(Int))
      case Float =&amp;gt; &amp;quot;%.2f&amp;quot; printfln(iter next(Float))
      case =&amp;gt; &amp;quot;Unsupported type&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More simply, &lt;code&gt;each&lt;/code&gt; can be used on a &lt;code&gt;VarArgs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAll: func (things: ...) {
  things each(|thing|
    match thing {
      case i: Int =&amp;gt; &amp;quot;%d&amp;quot; printfln(i)
      case f: Float =&amp;gt; &amp;quot;%.2f&amp;quot; printfln(f)
      case =&amp;gt; &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;C varargs&lt;/h2&gt;

&lt;p&gt;Used by writing simply &lt;code&gt;...&lt;/code&gt; in the argument list, not &lt;code&gt;args: ...&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
f: func (firstArg: Type, ...) {
  // body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only accessible through &lt;code&gt;va_start&lt;/code&gt;, &lt;code&gt;va_next&lt;/code&gt;, &lt;code&gt;va_end&lt;/code&gt;. See &lt;a href=&#34;http://en.wikipedia.org/wiki/Variadic_function&#34;&gt;Variadic
function&lt;/a&gt; on Wikipedia.&lt;/p&gt;

&lt;p&gt;Useful only to relay a variable number of arguments to an extern C function,
since &lt;code&gt;va_arg&lt;/code&gt; couldn&amp;rsquo;t work (can&amp;rsquo;t quote raw C types in ooc).&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
vprintf: extern (s: CString, ...)

printf: func (s: String, ...) -&amp;gt; This {
  list: VaList
  va_start(list, this)
  vprintf(s toCString(), list)
  va_end(list)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Extern functions&lt;/h1&gt;

&lt;p&gt;To call a function defined elsewhere, for example in a C library, its prototype
needs to be defined&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exit: extern func (Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lazy way: type-only args, thorough way: variable-decl-args.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exit: extern func (exitCode: Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;By-ref parameters&lt;/h1&gt;

&lt;p&gt;Instead of having to dereference each time the parameter is accessed, just declare
it as a reference type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
increment: func (a: Int*) { a@ += 1 }
// vs
increment: func (a: Int@) { a += 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saves typing, saves error, clearer code. Can still access the address via &lt;code&gt;argument&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Closures&lt;/h1&gt;

&lt;p&gt;A very concise way to pass a function as an argument. &lt;code&gt;each&lt;/code&gt; is a typical
example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// definition
List: class &amp;lt;T&amp;gt; {
  each: func (f: Func (T)) { /* ... */ }
}

// usage
list := List&amp;lt;Int&amp;gt; new()
list each(|elem|
  // do something with elem, of type Int
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also works with several parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// definition
Map: class &amp;lt;K, V&amp;gt; {
  each: func (f: Func (K, V)) { /* ... */ }
}

// usage
map := Map&amp;lt;String, Horse&amp;gt; new()
map each(|key, value|
  // key is of type String, value is of type Horse
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Argument types are inferred, hence, the code is very short.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generics</title>
      <link>http://oocmanual.cogneco.com/language/generics</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/generics</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Generic functions&lt;/h1&gt;

&lt;p&gt;Since ooc is strongly typed, usually when definining a function,
it will only accept one type of argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printInt: func (value: Int) {
  value toString() println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But what if a function is meant to accept various types and react
accordingly? Generics can be used for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAnything: func &amp;lt;T&amp;gt; (value: T) {
  value toString() println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that&amp;rsquo;s a step in the right direction. But it won&amp;rsquo;t work, because
you can&amp;rsquo;t call methods on generics types. Since &lt;code&gt;T&lt;/code&gt; could be anything,
from a String to an array to an Int, we can&amp;rsquo;t make sure it even has a
&lt;code&gt;toString&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;What we can do is match on &lt;code&gt;T&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAnything: func &amp;lt;T&amp;gt; (value: T) {
  match T {
    case Int =&amp;gt;
      value as Int toString() println()
    case =&amp;gt;
      &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot; println()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s not very convenient - here&amp;rsquo;s another way to write it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printAnything: func &amp;lt;T&amp;gt; (value: T) {
  match value {
    case i: Int =&amp;gt;
      i toString()
    case =&amp;gt;
      &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;
  } println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Inference&lt;/h2&gt;

&lt;p&gt;Notice how we didn&amp;rsquo;t have to specify &lt;code&gt;T&lt;/code&gt; when calling &lt;code&gt;printAnything&lt;/code&gt;,
above? That&amp;rsquo;s because the type of &lt;code&gt;T&lt;/code&gt; is inferred. More complex inference
is supported as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map := HashMap&amp;lt;String, Int&amp;gt; new()
map put(&amp;quot;one&amp;quot;, 1)
printMap(map)

printMap: func &amp;lt;K, V&amp;gt; (list: HashMap&amp;lt;K, V&amp;gt;) {
  // when called from above, K == String, and V == Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works for closures as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import structs/[ArrayList, List]

map: func &amp;lt;T, U&amp;gt; (list: List&amp;lt;T&amp;gt;, f: Func (T) -&amp;gt; U) -&amp;gt; List&amp;lt;U&amp;gt; {
  copy := ArrayList&amp;lt;U&amp;gt; new()
  for (elem in list) {
    copy add(f(elem))
  }
  copy
}

a := [1, 2, 3] as ArrayList&amp;lt;Int&amp;gt;
b := map(a, |i| i toString())
b join(&amp;quot;, &amp;quot;) println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;U&lt;/code&gt; is inferred from the return type of the closure.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Generic classes&lt;/h1&gt;

&lt;p&gt;Above, we have used generic types, such as &lt;code&gt;ArrayList&amp;lt;T&amp;gt;&lt;/code&gt; and
&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; - how can they be defined? Just like functions, by
putting generic type arguments in-between chevrons (&lt;code&gt;&amp;lt;Type1, Type2&amp;gt;&lt;/code&gt;)
in the class definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Container: class &amp;lt;T&amp;gt; {
  t: T

  init: func (=t)
  get: func -&amp;gt; T { t }
  set: func (=t)
}

c := Container&amp;lt;Int&amp;gt; new(24)
c set(12)
c get() toString() println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that inference works here too - since we are passing
a &lt;code&gt;T&lt;/code&gt; to the constructor, the instanciation part could be
simply rewritten as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
c := Container new(24)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Inheritance&lt;/h2&gt;

&lt;p&gt;Generic types can have subtypes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
ContainerToo: class &amp;lt;T&amp;gt; extends Container&amp;lt;T&amp;gt; {
  print: func {
    match t {
      case i: Int =&amp;gt; i toString()
      case =&amp;gt; &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;
    } print()
  }
}

c := ContainerToo new(24)
c print()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Specialization&lt;/h2&gt;

&lt;p&gt;Specialization happens when a sub-type has fewer type parameters
than its super-type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
IntContainer: class extends Container&amp;lt;Int&amp;gt; {
  print: func {
    get() toString() println()
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Modules</title>
      <link>http://oocmanual.cogneco.com/language/modules</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/modules</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Modules&lt;/h1&gt;

&lt;p&gt;Any &lt;code&gt;.ooc&lt;/code&gt; file is a module. Modules are organized in packages, relative
to source path elements.&lt;/p&gt;

&lt;p&gt;For example, for the following directory structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source
|-- czmq
|   `-- extras
|       `-- PipeSink.ooc
`-- czmq.ooc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have two modules, and their fully qualified names are &lt;code&gt;czmq&lt;/code&gt; and &lt;code&gt;czmq/extras/PipeSink&lt;/code&gt;.
We&amp;rsquo;ll say that the &lt;code&gt;czmq&lt;/code&gt; module is in the root package, and that the &lt;code&gt;PipeSink&lt;/code&gt; module is
in the &lt;code&gt;czmq/extras&lt;/code&gt; package.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Import&lt;/h2&gt;

&lt;p&gt;The example modules above can be imported like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import czmq
import czmq/extras/PipeSink
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, on one single line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import czmq, czmq/extras/PipeSink
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Import paths can be relative, so when in the &lt;code&gt;czmq.ooc&lt;/code&gt; module, one can import
with the full path, &lt;code&gt;czmq/extras/PipeSink&lt;/code&gt;, or with the relative path, &lt;code&gt;extras/PipeSink&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Similarly, inside PipeSink, one could import another extra via &lt;code&gt;../KitchenSink&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When importing several modules from the same package, one can use the multi-import
syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/[Process, Terminal, Env]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, symbols imported another module are available in the global scope.  To import the symbols into a namespace, use &lt;code&gt;into&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import czmq/extras/PipeSink into PipeSink
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Non-modules&lt;/h1&gt;

&lt;p&gt;Other files may be involved in the compilation process, especially when using
C libraries. Dynamic libraries and header paths will typically be specified
in a &lt;a href=&#34;/docs/tools/rock/usefiles/&#34;&gt;usefile&lt;/a&gt;, whereas C headers can be directly included in .ooc files&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Include&lt;/h2&gt;

&lt;p&gt;To include a standard header ssuch as &lt;code&gt;stdio.h&lt;/code&gt;, one can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
include stdio, stdlib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the absence of &lt;code&gt;.h&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Include with defines&lt;/h2&gt;

&lt;p&gt;Some C header files&amp;rsquo; behaviour vary depending on what&amp;rsquo;s defined when including
them. For example, to use functions such as &lt;code&gt;GetSystemInfo&lt;/code&gt; or &lt;code&gt;GetComputerNameEx&lt;/code&gt;
from the Windows API, one needs to define a &lt;code&gt;_WIN32_WINNT&lt;/code&gt; constant to be equal
or greater than &lt;code&gt;0x0500&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The following syntax achieves exactly this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
include windows | (_WIN32_WINNT=0x0500)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Relative include&lt;/h2&gt;

&lt;p&gt;It might also be useful to include a header file bundled with an ooc library.
Prefixing the path with &lt;code&gt;./&lt;/code&gt; will do just that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
include ./stb-image
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The header file will get copied in the output directory with the other
generated C files.&lt;/p&gt;

&lt;p&gt;For a good example of relative import, and using additionals in &lt;a href=&#34;/docs/tools/rock/usefiles/&#34;&gt;usefiles&lt;/a&gt;,
see the &lt;a href=&#34;https://github.com/nddrylliog/ooc-stb-image&#34;&gt;ooc-stb-image&lt;/a&gt; library.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sdk</title>
      <link>http://oocmanual.cogneco.com/sdk</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;An overview of the SDK&amp;rsquo;s packages&lt;/h1&gt;

&lt;p&gt;These pages will give you an overview of what you can find in the SDK:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;lang&#34;&gt;lang&lt;/a&gt; package is imported by default in any ooc file.
It contains essentials usable without further ado in any .ooc program.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;structs&#34;&gt;structs&lt;/a&gt; package contains useful containers like
lists and hash maps, but also stacks, and more cornercase stuff like
multimaps and bags.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;io&#34;&gt;io&lt;/a&gt; package has modules for reading files, writing
to files, and other input/output related matters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;math&#34;&gt;math&lt;/a&gt; package is the home to everything numbers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;os&#34;&gt;os&lt;/a&gt; package contains lots of goodies, from time
management to terminal handling, to launching processes, reading from
pipes, getting hardware information, manipulating environment variables,
creating a parallel job pool, and even coroutines and channels!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;net&#34;&gt;net&lt;/a&gt; package has modules for relatively low-level
network operations such as creating TCP and UDP sockets, and making DNS
requests.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;text&#34;&gt;text&lt;/a&gt; package contains a Regexp class, a JSON encoder
and decoder, a simple template engine, a string tokenizer, an option
parser, and a helper classes for escape sequences.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;threading&#34;&gt;threading&lt;/a&gt; package contains all things threads.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;native&#34;&gt;native&lt;/a&gt; package should not be imported directly -
it contains platform-specific specific implementations of certain features.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>os</title>
      <link>http://oocmanual.cogneco.com/sdk/os</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os package&lt;/h1&gt;

&lt;p&gt;The os packages contains various modules pertaining to Operating System functionality such as:&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Concurrency&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;process&#34;&gt;Process&lt;/a&gt;, to launch child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;jobpool&#34;&gt;JobPool&lt;/a&gt;, to easily control a pool of child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[Coro](coro, which provides a basic coroutine implementation&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;I/O&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;terminal&#34;&gt;Terminal&lt;/a&gt;, used to control terminal text output (color, etc.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;pipe&#34;&gt;Pipe&lt;/a&gt;, to open, read from, and write to pipes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;dynlib&#34;&gt;Dynlib&lt;/a&gt;, which deals with dynamic library loading&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;mmap&#34;&gt;mmap&lt;/a&gt;, which exposes memory mapping capabilities&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;channel&#34;&gt;Channel&lt;/a&gt;, which implements channels&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;System&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;system&#34;&gt;System&lt;/a&gt;, to get information such as the number of processors,
the hostname, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;env&#34;&gt;Env&lt;/a&gt;, to deal with environment variables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;shellutils&#34;&gt;ShellUtils&lt;/a&gt;, used mostly to find executables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;time&#34;&gt;Time&lt;/a&gt;, to get the current time and date, and sleep&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Generics 2</title>
      <link>http://oocmanual.cogneco.com/language/generics2</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/generics2</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Generics&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Generics are one of the most commonly misunderstood features of ooc.&lt;/p&gt;

&lt;p&gt;Many people attempt confuse them with templates (like in C++ or D) and are
surprised when things like this don&amp;rsquo;t work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Vector2: class &amp;lt;T&amp;gt; {
        x, y: T
    init: func(=x, =y) {}
        add: func (r: This&amp;lt;T&amp;gt;) {
            new(x + r x, y + r y)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Don&amp;rsquo;t worry about the syntax for now, I&amp;rsquo;ll get to it later)&lt;/p&gt;

&lt;p&gt;Why doesn&amp;rsquo;t this work? It&amp;rsquo;s because you can&amp;rsquo;t do much with generic variables.
The whole point is that &lt;em&gt;we don&amp;rsquo;t know which type they are&lt;/em&gt; until we run the
program.&lt;/p&gt;

&lt;p&gt;One might instanciate a Vector2&amp;lt;Int&amp;gt; - in which case the + operator
makes sense - but they could also instanciate a Vector2&amp;lt;Carrot&amp;gt;, where Carrot
wouldn&amp;rsquo;t necessarily have a + operator.&lt;/p&gt;

&lt;p&gt;Besides, since ooc is statically typed, we wouldn&amp;rsquo;t know which + operator
to use - they&amp;rsquo;re not all the same! We don&amp;rsquo;t add two ints the same manner that
we add two floats, and so on.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Generic functions and type parameters&lt;/h2&gt;

&lt;p&gt;So, if we can&amp;rsquo;t use any operator on generic variables - nor can we call
methods on them, then what are they good for? Sure looks useless from here.&lt;/p&gt;

&lt;p&gt;Well, here&amp;rsquo;s one thing we can do, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    identity: func &amp;lt;T&amp;gt; (val: T) -&amp;gt; T {
        val
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Woha. What just happened here? Let&amp;rsquo;s recap line by line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    identity: func &amp;lt;T&amp;gt; (val: T) -&amp;gt; T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we declare a function named &amp;lsquo;identity&amp;rsquo;, with one type parameter named T,
taking one parameter named &amp;lsquo;val&amp;rsquo;, and returning a value of type T.&lt;/p&gt;

&lt;p&gt;Type parameters are the names listed between the angular brackets &amp;lt; and &amp;gt;. You
can have as many as you want (although if you have more than few of them,
you&amp;rsquo;re probably doing it wrong)&lt;/p&gt;

&lt;p&gt;When you declare a type parameter, it tells the compiler about a new type,
that we know nothing about at compile-time. Well, not nothing. Remember
classes? Here&amp;rsquo;s how we access the class of an object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    object class
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if object was of type Carrot, that amounts exactly to doing just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Carrot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is that, exactly? It&amp;rsquo;s an access to a class. What is a class? An instance
of Class, which is declared in lang/CoreTypes.ooc If you actually go on and open
CoreTypes, here is a simplified version of what you will find:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Class: class {
        name: String
        size, instanceSize: SizeT
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Reminder: SizeT can be used to store the size of something. On 32-bits
platforms, it&amp;rsquo;s 32-bits wide. On 64-bits platforms, it&amp;rsquo;s 64-bits wide, and so
on. Basically, it&amp;rsquo;s an integer type that is as wide as a Pointer)&lt;/p&gt;

&lt;p&gt;So back to our generic stuff. I said we knew nothing about generic types. And
in fact, it was a downright lie. Please accept my apologies. The reality is -
we know all that matters! If you try to execute the following piece of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    test: func &amp;lt;T&amp;gt; (t: T) { T class name println() }
    test(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll find out something very strange and puzzling.. it prints &amp;ldquo;Class&amp;rdquo; !&lt;/p&gt;

&lt;p&gt;We just discovered that we can access type parameters just like any other
variable. And since T is a class, and we can access various fields of a class,
here&amp;rsquo;s what we can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    test2: func &amp;lt;T&amp;gt; (t: T) {
        &amp;quot;name = %s, size = %zd, instanceSize = %zd&amp;quot; printfln(
        T name, T size, T instanceSize)
    }
    test2(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will likely print something like &amp;ldquo;name = Int, size = 4, instanceSize =
4&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Then you must wonder why is there &amp;lsquo;size&amp;rsquo; and &amp;lsquo;instanceSize&amp;rsquo;, if they&amp;rsquo;re equal?
Well, they&amp;rsquo;re not equal in all cases. Most importantly, for objects (which are
references, remember), &amp;lsquo;object class size&amp;rsquo; is equal to &amp;lsquo;Pointer size&amp;rsquo;, but
&amp;lsquo;object class instanceSize&amp;rsquo; is equal to the actual number of bytes we should
allocate when we create an object of this class.&lt;/p&gt;

&lt;p&gt;But I digress. (Then again, you&amp;rsquo;re the curious one - not me.)&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s analyze the second line of our &amp;lsquo;identity&amp;rsquo; function above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    val
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see. It&amp;rsquo;s the last line of a non-void function, so it means it&amp;rsquo;s
returned. &amp;lsquo;val&amp;rsquo; refers to a variable declaration which happens to be a
function argument, of a generic type. (&lt;em&gt;phew&lt;/em&gt; - at this point, repeat that
last line to yourself two or three times to impreign it into your brain)&lt;/p&gt;

&lt;p&gt;So basically what our function does is&amp;hellip; just pass through what we give it as
an argument! Let&amp;rsquo;s try that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    42 toString() println() // just to be sure
    identity(42) toString() println() // still a little trivial
    identity(identity(identity(identity(42)))) toString() println() // whoa.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yup, it prints 42 alright.&lt;/p&gt;

&lt;p&gt;But wait! I just said above that the compiler &lt;em&gt;couldn&amp;rsquo;t do anything useful
with a generic variable&lt;/em&gt;, that is, either use an operator on it or call a
function on it, because it doesn&amp;rsquo;t know its type. And in our example, we
clearly see that the &amp;lsquo;identity&amp;rsquo; function has return type T, which is a generic
type! (Because it&amp;rsquo;s between the &amp;lt; and &amp;gt;, remember?)&lt;/p&gt;

&lt;p&gt;Have I lied again? Let&amp;rsquo;s find out.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Generic type inference&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s do a little experiment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    a := 42
    b := identity(42)
    &amp;quot;%s and %s&amp;quot; printfln(a class name, b class name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What did you get? Int and Int, right? But - but the return type of &amp;lsquo;identity&amp;rsquo;
is T! Shouldn&amp;rsquo;t b&amp;rsquo;s type be T too?&lt;/p&gt;

&lt;p&gt;Well, no.&lt;/p&gt;

&lt;p&gt;And thank God for that.&lt;/p&gt;

&lt;p&gt;In fact, if it was so, generics would be pretty much useless (heh, they&amp;rsquo;re limited enough already!)&lt;/p&gt;

&lt;p&gt;So what kind of magic is going on? White magic. Which really isn&amp;rsquo;t magic at
all.&lt;/p&gt;

&lt;p&gt;You see, when you call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    identity(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the definition of identity is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    identity: func &amp;lt;T&amp;gt; (val: T) -&amp;gt; T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what the compiler figures out: well, we have one unknown type (that
is, generic type), called &amp;rsquo;T&amp;rsquo;. Also, the first (and only) argument is of that
type. Hey - let&amp;rsquo;s infer what &amp;rsquo;T&amp;rsquo; is from the type of this argument!&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s exactly what it does. As a result, it figures the type of b to be
Int - since we can know all that at compile-time. It makes b easier to use,
avoid tons of cast, and is good for your karma.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    printTypeName: func &amp;lt;T&amp;gt; (T: Class) { T name println() }
    printTypeName(Object)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it prints &amp;ldquo;Object&amp;rdquo;. Did we find a way to print strings without having to
enclose them between quotes? Hopefully not. That would be messy, man. Talk
about Perl :/&lt;/p&gt;

&lt;p&gt;However, we have just discovered that we can pass types as arguments to
functions. Of course, because types are just instances of &amp;lsquo;Class&amp;rsquo;, right? So
they&amp;rsquo;re objects. So they&amp;rsquo;re values. So we can pass them around.&lt;/p&gt;

&lt;p&gt;So here, the compiler figures that, well - we give it the solution to &amp;lsquo;what is
T&amp;rsquo;. It is then not too big a challenge for the compiler to go from here.&lt;/p&gt;

&lt;p&gt;Then again, we could have done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    dumbPrintTypeName: func (T: Class) { T name println() }
    dumbPrintTypeName(Object)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we don&amp;rsquo;t use T as a type anywhere. So why even bother with this &amp;lt;T&amp;gt;
thing, hmm? Why does the compiler even allow it? Read on if you want to find out.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Generic return types&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s a little riddle for you. How does the compiler figure out the real return
type of this function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sackOfUnknown: func &amp;lt;T&amp;gt; -&amp;gt; T { 42 }
    sackOfUnknown()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyone? Ah, I see a hand in the back. What do you say? The type of the return
expression? WRONG. But that was an honest try. One point for effort.&lt;/p&gt;

&lt;p&gt;So what&amp;rsquo;s the solution? &amp;ldquo;It doesn&amp;rsquo;t.&amp;rdquo; That&amp;rsquo;s right. The compiler doesn&amp;rsquo;t even
bother. We give absolutely no clue as to the type of T when we&amp;rsquo;re calling it -
and the compiler never tries to infer a generic type from the return
expression (that&amp;rsquo;s useless, I mean - why even make a generic function in the
first place? Too lazy to type out &amp;lsquo;Int&amp;rsquo;? Yeah. Call me back when you have ABI
incompatibilities because you changed a return expression. Or rather - don&amp;rsquo;t.)&lt;/p&gt;

&lt;p&gt;So how do we make a function that&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;has a generic return type, let&amp;rsquo;s say &amp;rsquo;T&amp;rsquo;&lt;/li&gt;
&lt;li&gt;doesn&amp;rsquo;t take an argument of type T ?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Well, that&amp;rsquo;s precisely where that useless thing presented in the previous
section comes in very handy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    theAnswer: func &amp;lt;T&amp;gt; (T: Class) -&amp;gt; T {
        match T {
            case Int    =&amp;gt; 42
            case Float  =&amp;gt; 42.0
            case String =&amp;gt; &amp;quot;forty-two&amp;quot;
            case        =&amp;gt; Exception new(&amp;quot;You&#39;re not worthy.&amp;quot;) throw(); 0
        }
    }
   rational := theAnswer(Int)
   real     := theAnswer(Float)
   text     := theAnswer(String)
   theAnswer(Object) // ka-boom!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What just happened? We used a match on &amp;rsquo;T&amp;rsquo;, which means we&amp;rsquo;re comparing it.
We&amp;rsquo;re comparing it with the types &amp;lsquo;Int&amp;rsquo;, &amp;lsquo;Float&amp;rsquo;, &amp;lsquo;String&amp;rsquo;, trying to return
expressions. And if it&amp;rsquo;s none of these types, it just blows up.&lt;/p&gt;

&lt;p&gt;Note: in that case, our theAnswer function is pretty useless&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Generic classes&lt;/h2&gt;

&lt;p&gt;Now that&amp;rsquo;s all good and fancy - but generic functions aren&amp;rsquo;t actually that
useful. If we can&amp;rsquo;t use operators nor functions on generic types, what can we
do? Well - store them! That&amp;rsquo;s the way all collections work.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with a simple one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Slot: class &amp;lt;T&amp;gt; {
        element: T
        init: func (.element) { set(element) }
        set: func (=element) {}
        get: func -&amp;gt; T { element }
    }

    s := Slot new(3.14)
    s get() toString() println()
    s T name println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not that bad, eh? (It should print 3.14 and Float - or some other type, if
you&amp;rsquo;re in the future and ooc has a proper number tower)&lt;/p&gt;

&lt;p&gt;But wait - get is defined like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    get: func -&amp;gt; T { element }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And clearly T is a generic type, ie. it could be anything at runtime, and
&lt;em&gt;yet&lt;/em&gt; the compiler figures it out right.&lt;/p&gt;

&lt;p&gt;So what happens here? Let&amp;rsquo;s look at the call, since it&amp;rsquo;s the info from which
the compiler works to infer generic types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s get()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmmph. Not many types there - except maybe.. the type of s. Which is what
exactly?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s := Slot new(3.14)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well it turns out that Slot new is just a regular method call, the generic
type T is inferred to &amp;lsquo;Float&amp;rsquo;, and so &amp;rsquo;s&amp;rsquo; becomes a Slot&amp;lt;Float&amp;gt;&lt;/p&gt;

&lt;p&gt;Hence, the compiler sees the get() call as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Slot&amp;lt;Float&amp;gt; get()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it sees the get definition as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Sloat&amp;lt;T&amp;gt; get: func {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From here, inferring that T = Float is trivial.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Advanced type inference&lt;/h2&gt;

&lt;p&gt;One of the most advanced example of type inference in the whole SDK
is probably the List map() function. Here is its signature (ie.
definition without the body) :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    map: func &amp;lt;K&amp;gt; (f: Func (T) -&amp;gt; K) -&amp;gt; This&amp;lt;K&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So basically it turns a List&amp;lt;T&amp;gt; into a List&amp;lt;K&amp;gt;, by calling f to turn
every T into a K. Makes sense.&lt;/p&gt;

&lt;p&gt;The question is now - how does the compiler infer K? The only info we have
about it, is that it&amp;rsquo;s the return type of function we pass as an argument
to the function.&lt;/p&gt;

&lt;p&gt;Well - no big deal then, if we do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    intToString: func (i: Int) -&amp;gt; String { i toString() }
    strings := numbers map(intToString)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we know that K = String from the definition of intToString.&lt;/p&gt;

&lt;p&gt;But wait, there&amp;rsquo;s a nice infers-everything syntax for closures, ie.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stringsToo := numbers map(|x| x toString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here, we&amp;rsquo;re doomed. The closure insides attempts to infers its whole
signature (argument types, return type, etc.) from the type of the
corresponding argmuent in the map definition. But map doesn&amp;rsquo;t provide
a definitive answer, since the return type is generic.&lt;/p&gt;

&lt;p&gt;Hence, the compiler falls back to the only possible resolution of this
madness: it infers K from the return expression inside the closure.&lt;/p&gt;

&lt;p&gt;This case is the &lt;em&gt;only case&lt;/em&gt; where rock considers the return expression
inside functions to infer any type at all.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Under the hood&lt;/h2&gt;

&lt;p&gt;How does it work under the hood?&lt;/p&gt;

&lt;p&gt;Here is the naive implementation: generic type arguments as passed
as function arguments, ie a call to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ArrayList&amp;lt;Int&amp;gt; new()
    identity(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;becomes (without mangling):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ArrayList_new(Int_class());
    identity()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type arguments in classes become variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ArrayList: class &amp;lt;T&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ArrayList: class {
        T: Class
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Class type arguments are assigned in the constructor to the appropriate
values.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Language</title>
      <link>http://oocmanual.cogneco.com/language</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The OOC Language&lt;/h1&gt;

&lt;p&gt;The language has grown over the years, but it&amp;rsquo;s still relatively tidy.
Here&amp;rsquo;s a list of sections of the language documentation:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;modules&#34;&gt;Modules&lt;/a&gt; chapter discusses &lt;code&gt;.ooc&lt;/code&gt; files, what
a module is, what a package is, how imports and includes work.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;values&#34;&gt;Values&lt;/a&gt; chapter talks number literals, string
literals, operators, variable declarations, and a few built-in types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;control-structures&#34;&gt;Control Structures&lt;/a&gt; chapter describes
mundane constructs like if, else, for, while, break, continue, but also
match.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;collections&#34;&gt;Collections&lt;/a&gt; chapter talks about
arrays and maps, among other things.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;functions&#34;&gt;Functions&lt;/a&gt; chapter will teach you anything
from declaring function to calling them, to using external functions
(from a C library, for example), but also variable arguments, default
arguments, first-class functions and a nice syntax for closures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;classes&#34;&gt;Classes&lt;/a&gt; chapter is here to help you realize
that ooc classes are a lot like Java classes, except when they are not.
Constructors, inheritance, abstract methods, initializers, and even
interfaces have found their way in here.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;operators&#34;&gt;Operators&lt;/a&gt; chapter lists various mathematic
and logic operators, their priorities, how to overload them, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;covers&#34;&gt;Covers&lt;/a&gt; chapter discusses a construct halfway
between C structs and ooc classes, that is a major actor in making C
libraries easier to use.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;enumerations&#34;&gt;Enumerations&lt;/a&gt; chapter goes over the last kind of ooc
types - an enumeration of things. How to define them, use them, you
name it. (No, seriously, anonymous enums don&amp;rsquo;t exist)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;tuples&#34;&gt;Tuples&lt;/a&gt; chapter explains what tuples are and
what they aren&amp;rsquo;t. It covers multi-return, multi-declaration, variable
swapping, and cover literals.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;generics&#34;&gt;Generics&lt;/a&gt; chapter talks about parameterized
types, how to define them, how to use them, what are their strong points
and their shortcomings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;exceptions&#34;&gt;Exceptions&lt;/a&gt; chapter talks about error
handling, how to throw and catch Exceptions, and how to create your own
exception types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;preprocessor&#34;&gt;Preprocessor&lt;/a&gt; describes what happens to
the code before it is even compiled.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>jobpool</title>
      <link>http://oocmanual.cogneco.com/sdk/os/jobpool</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/jobpool</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/JobPool module&lt;/h1&gt;

&lt;p&gt;JobPool is useful when several background tasks have to be launched in
parallel. It allows to control how many tasks are run in parallel, and to wait
until all tasks have ended.&lt;/p&gt;

&lt;p&gt;A good example of JobPool usage would be a build system, where multiple
instances of a compiler have to be ran on different files, and the number of
instances running in parallel should be limited.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;Creating a job pool is trivial:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/JobPool
pool := JobPool new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then jobs should be added. Jobs are attached to processes, so the process
must be launched beforehand.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;find&amp;quot;, &amp;quot;./&amp;quot;, &amp;quot;-name&amp;quot;, &amp;quot;*.log&amp;quot;])
p executeNoWait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then an associated job can be created and added to the pool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
job := Job new(p)
pool add(job)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;pool add&lt;/code&gt; call might block, if there already is too many
jobs running in parallel, waiting for at least one job to complete.&lt;/p&gt;

&lt;p&gt;When all jobs have been added, one can wait for all jobs to finish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exitCode := pool waitAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If at least one job failed (returned with a non-zero exit code),
&lt;code&gt;waitAll&lt;/code&gt; will return its exit code. If they all succeeded, &lt;code&gt;waitAll&lt;/code&gt;
will just return 0.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Proof of concept&lt;/h2&gt;

&lt;p&gt;To demonstrate how it works, we can launch several &lt;code&gt;sleep&lt;/code&gt; commands
in the background, and wait for them all to finish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pool := JobPool new()

for (i in 0..pool parallelism) {
    p := Process new([&amp;quot;sleep&amp;quot;, &amp;quot;1&amp;quot;])
    p executeNoWait()
    pool add(Job new(p))
}

pool waitAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program wil take about 1 second to complete, no matter the level
of parallelism. Instead of being executed sequentially (which would add
up the time of execution), they&amp;rsquo;re being executed in parallel.&lt;/p&gt;

&lt;p&gt;Note that this is a contrived example. In a real example, one would not
adjust the total number of jobs from the &lt;code&gt;pool parallelism&lt;/code&gt; setting, but
rather let the natural number of jobs be distributed by the job pool itself.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Customization&lt;/h1&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Parallelism&lt;/h2&gt;

&lt;p&gt;By default, &lt;code&gt;JobPool&lt;/code&gt; tries to have a level of parallelism (max jobs in
parallel) equal to the number of cores on the machine it&amp;rsquo;s running on.&lt;/p&gt;

&lt;p&gt;It can be adjusted by hand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// never run more that 2 jobs in parallel
pool parallelism = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Custom job&lt;/h2&gt;

&lt;p&gt;In our examples above we&amp;rsquo;ve always used the default &lt;code&gt;Job&lt;/code&gt; class. But it can be
extended as well. By making a subclass of it, we can override the &lt;code&gt;Job onExit&lt;/code&gt;
method, allowing us to take action after each job is finished.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
CompilationJob: class extends Job {
    init: func {
        p := Process new([&amp;quot;gcc&amp;quot;, &amp;quot;-v&amp;quot;])
        p executeNoWait()
        super(p)
    }

    onExit: func (code: Int) {
        if (code != 0) {
            raise(&amp;quot;Compilation failed!&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our new job type can then be used, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pool := Pool new()
for (i in 0..10) {
    pool add(CompilationJob new())
}
pool waitAll()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>system</title>
      <link>http://oocmanual.cogneco.com/sdk/os/system</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/system</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/System module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;System&lt;/code&gt; module allows to get information about the system, such
as the number of processors, as an &lt;code&gt;Int&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cores := System numProcessors()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the hostname of the machine, as a &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
hostname := System hostname()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>time</title>
      <link>http://oocmanual.cogneco.com/sdk/os/time</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/time</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Time module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Time&lt;/code&gt; module allows for both time measurement and sleeping.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Sleep&lt;/h2&gt;

&lt;p&gt;There are three granularities for sleep: second, milli, and microseconds.
Note that each system has different guarantees as to the actual clock
granularity, but the SDK will use the most precise method available.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// sleep for one second
Time sleepSec(1)

// then for 12 milliseconds
Time sleepMilli(12)

// then for 300 microseconds
Time sleepMicro(300)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Date and time&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;dateTime&lt;/code&gt; will return the current time date and time formatted as a
human-readable string. The exact format might depend on the locale and
operating system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Today is: %s&amp;quot; printfln(Time dateTime())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;sec&lt;/code&gt; return the current hour, minute, and second.&lt;/p&gt;

&lt;p&gt;Executed at 12h34 and 56 seconds, the following will print 123456:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;%d%d%d&amp;quot; printfln(Time hour(), Time min(), Time sec())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;microtime&lt;/code&gt; returns the microseconds that have elapsed in the current
minute, whereas &lt;code&gt;microsec&lt;/code&gt; returns the microseconds that have elapsed
int he current second.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runTime&lt;/code&gt; returns the number of milliseconds elapsed since program start.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;Uptime: %d seconds.&amp;quot; printfln(Time runTime() / 1_000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Measure&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;measure&lt;/code&gt; function accepts a block and returns the number of milliseconds
spent elapsing it. It might be used as a poor humanoid&amp;rsquo;s profiler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
duration := Time measure(||
    // some time-consuming task
)
&amp;quot;Huge task done in %d ms&amp;quot; printfln(duration)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Basic Usage</title>
      <link>http://oocmanual.cogneco.com/tools/rock/basic</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/rock/basic</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Using rock, the basic way&lt;/h1&gt;

&lt;p&gt;If you have a usefile, calling rock is pretty easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will look for usefiles in your current directory and, if possible, build them.&lt;/p&gt;

&lt;p&gt;Since the world is not always perfect, it&amp;rsquo;s also possible to pass an &lt;code&gt;.ooc&lt;/code&gt; file directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock mmorpg.ooc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sadly, it&amp;rsquo;s possible that rock thinks your ooc code is alright and passes the C files to your
C compiler which then prints pages of errors and explodes subsequently.
In that case, you&amp;rsquo;ll need to increase rock&amp;rsquo;s verbosity to see the compiler output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -v ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Building an executable and tired of typing &lt;code&gt;./mmorpg&lt;/code&gt; all over again?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -r ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will run your executable after having built it successfully.&lt;/p&gt;

&lt;p&gt;To speed up the compilation process and to save you some time, rock caches compiled dependencies
in a hidden subdirectory called &lt;code&gt;.libs&lt;/code&gt;. In most cases, this is awesome, but sometimes, something
goes wrong and you get pretty strange unexplainable error messages. Just to be sure, you can just&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
rock -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then, recompile and see if it works.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Editors</title>
      <link>http://oocmanual.cogneco.com/tools/editors</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/tools/editors</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;ooc support in text editors&lt;/h1&gt;

&lt;p&gt;ooc has a varying level of support among different text editors.&lt;/p&gt;

&lt;p&gt;Read on to find if your favourite flavor is supported. If you add
support for a new editor, please open an issue on the &lt;a href=&#34;https://github.com/nddrylliog/ooc-lang.org&#34;&gt;ooc-lang.org repo&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;vim&lt;/h1&gt;

&lt;p&gt;ooc support for vim is provided by the &lt;a href=&#34;https://github.com/nddrylliog/ooc.vim&#34;&gt;ooc.vim&lt;/a&gt; plug-in. It provides:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Syntax highlighting&lt;/li&gt;
&lt;li&gt;Indentation support&lt;/li&gt;
&lt;li&gt;A syntastic plug-in for use with &lt;a href=&#34;https://github.com/nddrylliog/sam&#34;&gt;sam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:make&lt;/code&gt; command support (launches &lt;code&gt;rock -v&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can read more at the &lt;a href=&#34;https://github.com/nddrylliog/ooc.vim&#34;&gt;project repository&lt;/a&gt;&amp;rsquo;s page.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;emacs&lt;/h1&gt;

&lt;p&gt;ooc support for emacs is provided by &lt;a href=&#34;https://github.com/nixeagle/ooc-mode&#34;&gt;ooc-mode&lt;/a&gt;. It provides:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Syntax highlighting&lt;/li&gt;
&lt;li&gt;Indentation support&lt;/li&gt;
&lt;li&gt;On the fly syntax check with flymake-ooc&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;TextMate&lt;/h1&gt;

&lt;p&gt;ooc support for TextMate is provided by &lt;a href=&#34;https://github.com/nilium/ooc.tmbundle&#34;&gt;ooc.tmbundle&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Atom&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://atom.io/&#34;&gt;Atom editor&lt;/a&gt; can use converted TextMate bundles.&lt;/p&gt;

&lt;p&gt;You can easily convert &lt;a href=&#34;https://github.com/nilium/ooc.tmbundle&#34;&gt;ooc.tmbundle&lt;/a&gt; for your own usage, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apm init --package ~/.atom/packages/language-ooc --convert https://github.com/nilium/ooc.tmbundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might need to restart Atom to see the changes.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Brackets&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;http://brackets.io/&#34;&gt;Brackets editor&lt;/a&gt; now has an extension for ooc syntax highlighting.
It can be installed from the Extensions Manager by searching for &lt;code&gt;ooc syntax&lt;/code&gt;.
The source is available &lt;a href=&#34;https://github.com/nddrylliog/brackets-ooc&#34;&gt;on GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;gtksourceview&lt;/h1&gt;

&lt;p&gt;gtksourceview-based tools such as gedit, meld, etc. have
ooc support out of the box.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;pygments&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://pygments.org/&#34;&gt;pygments&lt;/a&gt; has relatively good ooc support built-in. It is a python
solution for syntax highlighting used on GitHub and easy to integrate with
static website generators such as &lt;a href=&#34;http://nanoc.ws/&#34;&gt;nanoc&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>