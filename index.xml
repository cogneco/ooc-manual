<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on The OOC Manual </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://oocmanual.cogneco.com/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Tue, 01 Jan 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Glossary</title>
      <link>http://oocmanual.cogneco.com/glossary</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/glossary</guid>
      <description>&lt;p&gt;{{GLOSSARY}}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Manual</title>
      <link>http://oocmanual.cogneco.com/</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;How to use the documentation&lt;/h1&gt;

&lt;p&gt;The documentation for ooc is structured as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tutorial/&#34;&gt;Tutorial&lt;/a&gt; is a ten minute journey meant for
newcomers to the language. By building a small program, you will learn the
basics of the syntax and even use bits of the SDK.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/lang/&#34;&gt;Language&lt;/a&gt; section explains in detail every feature
of the language: it goes through the syntax and a the main use cases for
every feature. It also contains a full grammar, and a collection of best
practices.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/sdk/&#34;&gt;SDK&lt;/a&gt; section gives an overview of the modules included
with the default ooc distribution. Whether you need access to files, to
measure time, to do some networking, or simply use common data structures,
the SDK is packed with goodness.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/tools/&#34;&gt;Tools&lt;/a&gt; section lists useful tools for ooc development,
along with a typical workflow from the creation, compilation, testing, and
documentation of a project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/kaputt/&#34;&gt;Troubleshooting&lt;/a&gt; section gives advice on how
to address frequently encountered problems.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;/docs/glossary/&#34;&gt;Glossary&lt;/a&gt; is a collection of terms you may stumble
upon while using ooc or reading its documentation. If you don&amp;rsquo;t understand
a term, go here!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When you’re stuck with a question or a problem the documentation doesn’t
solve, considering posting to the &lt;a href=&#34;https://groups.google.com/group/ooc-lang&#34;&gt;discussion group&lt;/a&gt; or joining the
&lt;a href=&#34;irc://chat.freenode.net/#ooc-lang&#34;&gt;ooc-lang IRC channel&lt;/a&gt;. We’ll get it sorted out in no time. Check out the
&lt;a href=&#34;/community/&#34;&gt;Community&lt;/a&gt; page for details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>channel</title>
      <link>http://oocmanual.cogneco.com/sdk/os/channel</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/channel</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Channel module&lt;/h1&gt;

&lt;p&gt;Channels are another way to think about data flow in the program.
Perhaps most famous in their Go implementation, &amp;lsquo;goroutines&amp;rsquo;, can
communicate via channels.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;os/Channel&lt;/code&gt; module contains a trivial implementation of channels
which may be used like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By importing this module, a scheduler is set to run before the program
exits. Let&amp;rsquo;s start by making a channel by which Ints can travel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
chan := make(Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then let&amp;rsquo;s make a data producer coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 0..5) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And another one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    for (i in 5..10) {
        chan &amp;lt;&amp;lt; i
        yield()
    }
    chan &amp;lt;&amp;lt; -1
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-1 will be used as a stopping signal here. &lt;code&gt;go&lt;/code&gt; create a new
coroutine, and &lt;code&gt;chan &amp;lt;&amp;lt; value&lt;/code&gt; sends a value down a channel.
&lt;code&gt;yield&lt;/code&gt; switches from the current coroutine back to the scheduler.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now make a consumer channel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
go(||
    while (true) match (i := !chan) {
        case -1 =&amp;gt; break
        case =&amp;gt; &amp;quot;%d&amp;quot; printfln(i)
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re reading from the channel with the not operator: &lt;code&gt;!chan&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will print 0, 5, 1, 6, 2, 7, 3, 8, 4, 9, and then exit, as
expected.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>coro</title>
      <link>http://oocmanual.cogneco.com/sdk/os/coro</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/coro</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Coro module&lt;/h1&gt;

&lt;p&gt;That module was originally an ooc port of Steve Dekorte&amp;rsquo;s &lt;a href=&#34;https://github.com/stevedekorte/coroutine&#34;&gt;libcoroutine&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Coroutines help achieve cooperative multi-tasking, as opposed to threads, which
achieve preemptive multitasking. In cooperative multi-tasking, each task (or
&amp;lsquo;coroutine&amp;rsquo;) is responsible for handing the control to another coroutine.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;First, we have to create a main coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Coro

mainCoro := Coro new()
mainCoro initializeMainCoro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then create another coroutine, which we&amp;rsquo;ll here use as a generator&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
letter: Char

coro1 := Coro new()
mainCoro startCoro(coro1, ||
    for (c in &amp;quot;LLAMACORE&amp;quot;) {
        letter = c
        coro1 switchTo(mainCoro)
    }
    exit(0)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can retrieve those letters one by one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
while (true) {
    &amp;quot;%c&amp;quot; printfln(letter)
    mainCoro switchTo(coro1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is quite simple, just printing each letter that
&lt;code&gt;coro1&lt;/code&gt; gives us on separate lines, but complex tasks can be
broken down in various coroutines and be achieved in a much
more lightweight fashion than threads or processes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dynlib</title>
      <link>http://oocmanual.cogneco.com/sdk/os/dynlib</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/dynlib</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Dynlib module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Dynlib&lt;/code&gt; module allows one to load dynamic libraries on all
major platforms.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s open a library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Dynlib

lib := Dynlib load(&amp;quot;libm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t need to specify the &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dynlib&lt;/code&gt;, or &lt;code&gt;.dll&lt;/code&gt; extension here, it is
set automatically by platform, although the original path will be tested first,
in case of non-standard file extension.&lt;/p&gt;

&lt;p&gt;If the lib returned is null, it wasn&amp;rsquo;t found or couldn&amp;rsquo;t be opened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
if (!lib) {
    raise(&amp;quot;Couldn&#39;t load library!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then retrieve a symbol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cosAddr := lib symbol(&amp;quot;cos&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And cast it to a more useful function. Since &lt;code&gt;Func&lt;/code&gt; is actually
a function pointer and a context, we use a cover literal, passing
null for the context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cos := (cosAddr, null) as Func (Double) -&amp;gt; Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which we can then use!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;cos(PI / 4) = %.3f&amp;quot; printfln(cos(3.14 * 0.25))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This prints &lt;code&gt;cos(PI / 4) = 0.707&lt;/code&gt;, as expected.&lt;/p&gt;

&lt;p&gt;When we&amp;rsquo;re done with the library we can just close it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
lib close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: on Windows, failing to close a library may lead to a
crash on application exit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>os</title>
      <link>http://oocmanual.cogneco.com/sdk/os</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os package&lt;/h1&gt;

&lt;p&gt;The os packages contains various modules pertaining to Operating System functionality such as:&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Concurrency&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;process&#34;&gt;Process&lt;/a&gt;, to launch child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;jobpool&#34;&gt;JobPool&lt;/a&gt;, to easily control a pool of child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[Coro](coro, which provides a basic coroutine implementation&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;I/O&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;terminal&#34;&gt;Terminal&lt;/a&gt;, used to control terminal text output (color, etc.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;pipe&#34;&gt;Pipe&lt;/a&gt;, to open, read from, and write to pipes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;dynlib&#34;&gt;Dynlib&lt;/a&gt;, which deals with dynamic library loading&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;mmap&#34;&gt;mmap&lt;/a&gt;, which exposes memory mapping capabilities&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;channel&#34;&gt;Channel&lt;/a&gt;, which implements channels&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;System&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;system&#34;&gt;System&lt;/a&gt;, to get information such as the number of processors,
the hostname, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;env&#34;&gt;Env&lt;/a&gt;, to deal with environment variables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;shellutils&#34;&gt;ShellUtils&lt;/a&gt;, used mostly to find executables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;time&#34;&gt;Time&lt;/a&gt;, to get the current time and date, and sleep&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Constructors</title>
      <link>http://oocmanual.cogneco.com/language/constructors</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/constructors</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Constructors&lt;/h1&gt;

&lt;p&gt;In ooc, unlike Java/Scala/C++/C#, &amp;lsquo;new&amp;rsquo; isn&amp;rsquo;t a keyword, but a static method.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    dog := Dog new(&amp;quot;Pif&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However it&amp;rsquo;s uncommon to directly define a new method. Instead, an init method is
defined, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func (=name) {}

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an &amp;lsquo;init&amp;rsquo; method is defined, a corresponding &amp;lsquo;new&amp;rsquo; static method is defined, in our case,
the code above is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func (name: String) {
            this name = name
        }

        new: static func (name: String) -&amp;gt; This {
            this := This alloc() as This
            this init()
            this
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;alloc&amp;rsquo; is a method of Class, which can be defined like this, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /// Create a new instance of the object of type defined by this class
    alloc: final func ~_class -&amp;gt; Object {
        object := gc_malloc(instanceSize) as Object
        if(object) {
            object class = this
        }
        return object
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In ooc implementations, Object and Class are often classes defined in .ooc source
files, so you can easily study their source code. You can typically find their definitions
in sdk/lang/ (because everything in the lang/ package is automatically imported)&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Reminder: member-arguments and assign-arguments&lt;/h2&gt;

&lt;p&gt;This:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (=value) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the equivalent of this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (.value) {
            this value = value
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is the equivalent of this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiceRoll: class {
        value: Int

        init: func (value: Int) {
            this value = value
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ie &amp;lsquo;.&amp;rsquo; allows &amp;lsquo;value&amp;rsquo;s type to be inferred from the member variable
of the same name, and &amp;lsquo;=&amp;rsquo; does the same plus assigns it in the constructor.&lt;/p&gt;

&lt;p&gt;This works for any method, not only for constructors. However, if you&amp;rsquo;re using
it for setters, you probably want to use properties instead.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Multiple constructors&lt;/h2&gt;

&lt;p&gt;As any method, constructors can be overloaded with suffixes.&lt;/p&gt;

&lt;p&gt;Suffixes may seem annoying at first, seen as a sort of &amp;lsquo;manual name mangling&amp;rsquo;,
but aside from helping to debug, they&amp;rsquo;re also a way to document the purpose of your
different constructors. For that reason, it&amp;rsquo;s always a good idea to give meaningful
suffixes that lets one hint the reason for existence of a constructor.&lt;/p&gt;

&lt;p&gt;From a constructor, you can call another constructor with init(), just like a regular
method.&lt;/p&gt;

&lt;p&gt;You can also call a super-constructor with super()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog: class {

        name: String

        init: func ~defaultName {
            init(&amp;quot;The Man&amp;quot;)
        }

        init: func (=name) {}

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Inheritance&lt;/h2&gt;

&lt;p&gt;A common mistake is to think that constructor are inherited, because they are standard
methods. However, this behavior would be harmful, as explained in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Logger: class {
        prefix: String

        init: func (=prefix) {}

        log: func (msg: String) {
            &amp;quot;%s%s&amp;quot; printfln(prefix, msg)
        }
    }

    FileLogger: class extends Logger {
        output: FileWriter

        init: func ~withPath (path: String) {
            super(prefix)
            output = FileWriter new(path)
        }

        log: func (msg: String) {
            output write(prefix). write(msg). write(&#39;\n&#39;)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What would happen if the first constructor defined in Logger was available
for FileLogger? Let&amp;rsquo;s find out&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    warn := FileLogger new(&amp;quot;WARN&amp;quot;)
    warn log(&amp;quot;Somebody set us up the stacktrace&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The constructor call, if it was valid, would either return a Logger, which is
not what we want, or by some miracle trick, return a FileLogger - but one
that wouldn&amp;rsquo;t be properly initialized, so that log() would crash.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Super func (and beyond)&lt;/h2&gt;

&lt;p&gt;However, there are times when one truly wants to relay a constructor
in an inherited class, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Expression: abstract class {
        eval: abstract func -&amp;gt; Int
    }

    BinaryOp: abstract class extends Expression {
        left, right: Expression

        init: func ~lr (=left, =right) {}
    }

    Add: class extends BinaryOp {
        init: func ~lr (=left, =right) {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeating the &amp;lsquo;init~lr&amp;rsquo; definition in Add violates the Don&amp;rsquo;t Repeat Yourself (DRY)
principle. Besides, if functionality is added to the base BinaryOp init~lr, it
wouldn&amp;rsquo;t be replicated in Add init~lr.&lt;/p&gt;

&lt;p&gt;For this precise case, the &amp;lsquo;super func&amp;rsquo; construct exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Add: class extends BinaryOp {
        init: super func ~lr
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This behaves exactly as if we had written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Add: class extends BinaryOp {
        init: func ~lr (.left, .right) {
            super(left, right)
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mmap</title>
      <link>http://oocmanual.cogneco.com/sdk/os/mmap</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/mmap</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/mmap module&lt;/h1&gt;

&lt;p&gt;As it stands, the &lt;code&gt;os/mmap&lt;/code&gt; module just exposes the *nix functions for memory
mapping: &lt;code&gt;mmap&lt;/code&gt;, &lt;code&gt;munmap&lt;/code&gt;, &lt;code&gt;mprotect&lt;/code&gt;, &lt;code&gt;madvise&lt;/code&gt;, &lt;code&gt;mincore&lt;/code&gt;, &lt;code&gt;minherit&lt;/code&gt;,
&lt;code&gt;msync&lt;/code&gt;, &lt;code&gt;mlock&lt;/code&gt;, and &lt;code&gt;munlock&lt;/code&gt;, along with the associated constants.&lt;/p&gt;

&lt;p&gt;It also contains prototypes / covers for the Windows equivalent,
&lt;code&gt;VirtualProtect&lt;/code&gt;, and its constants as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;This module is not a high-level or cross-platform interface and is not
documented extensively here.&lt;/p&gt;

&lt;p&gt;However, to find more information on memory mapping for various platform
see here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap on Wikipedia&lt;/a&gt; (for *nix platforms)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/windows/desktop/aa366898(v=vs.85).aspx&#34;&gt;VirtualProtect on MSDN&lt;/a&gt; (for Windows)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On a historical note, this module was originally included in the SDK as support
code for the closure implementation, which back then implied generating
bytecode at runtime and thus marking some memory regions as executable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jobpool</title>
      <link>http://oocmanual.cogneco.com/sdk/os/jobpool</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/jobpool</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/JobPool module&lt;/h1&gt;

&lt;p&gt;JobPool is useful when several background tasks have to be launched in
parallel. It allows to control how many tasks are run in parallel, and to wait
until all tasks have ended.&lt;/p&gt;

&lt;p&gt;A good example of JobPool usage would be a build system, where multiple
instances of a compiler have to be ran on different files, and the number of
instances running in parallel should be limited.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;Creating a job pool is trivial:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/JobPool
pool := JobPool new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then jobs should be added. Jobs are attached to processes, so the process
must be launched beforehand.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
p := Process new([&amp;quot;find&amp;quot;, &amp;quot;./&amp;quot;, &amp;quot;-name&amp;quot;, &amp;quot;*.log&amp;quot;])
p executeNoWait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then an associated job can be created and added to the pool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
job := Job new(p)
pool add(job)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;pool add&lt;/code&gt; call might block, if there already is too many
jobs running in parallel, waiting for at least one job to complete.&lt;/p&gt;

&lt;p&gt;When all jobs have been added, one can wait for all jobs to finish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
exitCode := pool waitAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If at least one job failed (returned with a non-zero exit code),
&lt;code&gt;waitAll&lt;/code&gt; will return its exit code. If they all succeeded, &lt;code&gt;waitAll&lt;/code&gt;
will just return 0.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Proof of concept&lt;/h2&gt;

&lt;p&gt;To demonstrate how it works, we can launch several &lt;code&gt;sleep&lt;/code&gt; commands
in the background, and wait for them all to finish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pool := JobPool new()

for (i in 0..pool parallelism) {
    p := Process new([&amp;quot;sleep&amp;quot;, &amp;quot;1&amp;quot;])
    p executeNoWait()
    pool add(Job new(p))
}

pool waitAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program wil take about 1 second to complete, no matter the level
of parallelism. Instead of being executed sequentially (which would add
up the time of execution), they&amp;rsquo;re being executed in parallel.&lt;/p&gt;

&lt;p&gt;Note that this is a contrived example. In a real example, one would not
adjust the total number of jobs from the &lt;code&gt;pool parallelism&lt;/code&gt; setting, but
rather let the natural number of jobs be distributed by the job pool itself.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Customization&lt;/h1&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Parallelism&lt;/h2&gt;

&lt;p&gt;By default, &lt;code&gt;JobPool&lt;/code&gt; tries to have a level of parallelism (max jobs in
parallel) equal to the number of cores on the machine it&amp;rsquo;s running on.&lt;/p&gt;

&lt;p&gt;It can be adjusted by hand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// never run more that 2 jobs in parallel
pool parallelism = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Custom job&lt;/h2&gt;

&lt;p&gt;In our examples above we&amp;rsquo;ve always used the default &lt;code&gt;Job&lt;/code&gt; class. But it can be
extended as well. By making a subclass of it, we can override the &lt;code&gt;Job onExit&lt;/code&gt;
method, allowing us to take action after each job is finished.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
CompilationJob: class extends Job {
    init: func {
        p := Process new([&amp;quot;gcc&amp;quot;, &amp;quot;-v&amp;quot;])
        p executeNoWait()
        super(p)
    }

    onExit: func (code: Int) {
        if (code != 0) {
            raise(&amp;quot;Compilation failed!&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our new job type can then be used, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
pool := Pool new()
for (i in 0..10) {
    pool add(CompilationJob new())
}
pool waitAll()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>system</title>
      <link>http://oocmanual.cogneco.com/sdk/os/system</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/system</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/System module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;System&lt;/code&gt; module allows to get information about the system, such
as the number of processors, as an &lt;code&gt;Int&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
cores := System numProcessors()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the hostname of the machine, as a &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
hostname := System hostname()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>env</title>
      <link>http://oocmanual.cogneco.com/sdk/os/env</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/env</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/Env module&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;Env&lt;/code&gt; module allows to get and set environment variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/Env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting an environment variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
path := Env get(&amp;quot;PATH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt; if the given environment variable is not set.&lt;/p&gt;

&lt;p&gt;Setting an environment variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Env set(&amp;quot;CFLAGS&amp;quot;, &amp;quot;-Os&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Environment variables can be unset as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Env unset(&amp;quot;PKG_CONFIG_PATH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>shellutils</title>
      <link>http://oocmanual.cogneco.com/sdk/os/shellutils</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/os/shellutils</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The os/ShellUtils module&lt;/h1&gt;

&lt;p&gt;The entire purpose of the &lt;code&gt;ShellUtils&lt;/code&gt; module is to find an
executable in the PATH environment variable.&lt;/p&gt;

&lt;p&gt;It can be used to implement functionality usually found in the
*nix &lt;code&gt;which&lt;/code&gt; command-line utility.&lt;/p&gt;

&lt;p&gt;For example, to know where &lt;code&gt;autoconf&lt;/code&gt; is hiding, one can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import os/ShellUtils
file := ShellUtils findExecutable(&amp;quot;autoconf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the executable is not found, &lt;code&gt;file&lt;/code&gt; here will be null. Otherwise,
it&amp;rsquo;ll correspond to the executable first found in the path:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
match file {
    case null =&amp;gt; &amp;quot;autoconf not found&amp;quot;
    case =&amp;gt; &amp;quot;found: %s&amp;quot; format(file path)
} println()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Cross-platform&lt;/h2&gt;

&lt;p&gt;Adding the &lt;code&gt;.exe&lt;/code&gt; suffix is not necessary on Windows - it&amp;rsquo;ll be
added automatically on this platform when searching.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Crucial&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;findExecutable&lt;/code&gt; can be made to throw an exception in case an
executable is not found, instead of returning null. For this, pass
&lt;code&gt;true&lt;/code&gt; as its second argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// if we can&#39;t find make, don&#39;t even bother
make := ShellUtils findExecutable(&amp;quot;make&amp;quot;, true)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>structs</title>
      <link>http://oocmanual.cogneco.com/sdk/structs</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/structs</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The structs package&lt;/h1&gt;

&lt;p&gt;A few frequently used data structures ship with the SDK.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Lists&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;structs/List&lt;/code&gt; contains the generic interface for lists, which are ordered, indexed
collections of elements of any type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list: List&amp;lt;String&amp;gt; = // something
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elements can be added to or removed from anywhere in the list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list add(&amp;quot;hi&amp;quot;) // append &amp;quot;hi&amp;quot; to the list
list add(0, &amp;quot;hoe&amp;quot;) // prepend &amp;quot;ho&amp;quot; to the list
list remove(&amp;quot;hi&amp;quot;) // remove the first element equal to &amp;quot;hi&amp;quot;
list removeAt(0) // remove the first element

list addAll(otherList) // append all elements from other list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They can also be retrieved from anywhere in the list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list get(24) == list[24] // get the 24th element
list first() // get the first element
list last() // get the last element
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number of elements in a list is available as the &lt;code&gt;size&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;There are %d elements in this list.&amp;quot; printfln(list size)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going through each element is easy as well, either using a foreach:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
for (elem in list) {
  elem println()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or by passing a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list each(|elem|
  elem println()
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Removing all elements can be done via &lt;code&gt;clear&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
list clear()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;ArrayList&lt;/h2&gt;

&lt;p&gt;An array list is backed by an array, which it grows or shrinks depending
on how many elements are in there.&lt;/p&gt;

&lt;p&gt;Removing or adding an element in the middle of an ArrayList is expensive, as
it shifts all elements after it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// constructed through successive add() calls:
a1 := ArrayList&amp;lt;Int&amp;gt; new()
a1 add(1); a1 add(2); a2 add(3)

// constructed from an array literal
a1 := [1, 2, 3] as ArrayList&amp;lt;Int&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An ArrayList can be easily converted to an array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
printArray(list toArray())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;LinkedList&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;LinkedList&lt;/code&gt; is a doubly linked list, ie. each element points to the
element after it and the element before it.&lt;/p&gt;

&lt;p&gt;Unlike the ArrayList, removing or adding an element in the middle of a linked list
is inexpensive.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Maps&lt;/h1&gt;

&lt;p&gt;Maps are associative objects, ie. they associate keys to values.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;HashMap&lt;/h2&gt;

&lt;p&gt;The most oftenly used map collection is &lt;code&gt;structs/HashMap&lt;/code&gt;. It can only associate
a given key to one value. E.g. there cannot be duplicate keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map := HashMap&amp;lt;String, Int&amp;gt; new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Key-&amp;gt;value pairs are added to a HashMap using &lt;code&gt;put&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map put(&amp;quot;one&amp;quot;, 1)
map put(&amp;quot;two&amp;quot;, 2)
map put(&amp;quot;three&amp;quot;, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..and retrieved using &lt;code&gt;get&lt;/code&gt;. Key presence is tested with &lt;code&gt;containsKey?&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map get(&amp;quot;two&amp;quot;) == 2 // true
map containsKey?(&amp;quot;two&amp;quot;) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The whole point of a HashMap is that checking for presence or finding the
value corresponding to a key is faster than storing values in a list and
iterating through it entirely every time.&lt;/p&gt;

&lt;p&gt;To remove pairs, one has to specify the key:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map remove(&amp;quot;two&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A HashMap can be iterated through:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map each(|key, value|
  &amp;quot;%s =&amp;gt; %s&amp;quot; printfln(key, value)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s possible to get a list of all keys contained in a map:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
map getKeys()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in a HashMap, iteration order is not guaranteed to be equivalent to
insertion order - due to the hashing done, keys might get reordered for efficiency.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;MultiMap&lt;/h2&gt;

&lt;p&gt;MultiMap is a HashMap variant that can contain multiple values for a given key.&lt;/p&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;OrderedMultiMap&lt;/h2&gt;

&lt;p&gt;OrderedMultiMap is a MultiMap variant that will maintain the order in which keys
were inserted, for iteration.&lt;/p&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;Bag variants&lt;/h1&gt;

&lt;p&gt;In the structures presenting above, all elements must have the same type in a given
collection. Bags are different: each element can be a different type.&lt;/p&gt;

&lt;h2 id=&#34;toc_9&#34;&gt;Cell&lt;/h2&gt;

&lt;p&gt;Actually defined in &lt;code&gt;lang/types&lt;/code&gt;, Cell can contain anything:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
intCell := Cell new(42)
stringCell := Cell new(&amp;quot;turtle&amp;quot;)
// and so on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unwrapping a cell can be done via the indexing operator &lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := cell[Int]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that unwrapping a cell with an incompatible type will throw an error.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Bag&lt;/h2&gt;

&lt;p&gt;Technically, a Bag can be seen as a list of cells, with convenience methods to
deal directly with the values contained inside the cells.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
bag := Bag new()
bag add(93) // add an Int
bag add(&amp;quot;seaside&amp;quot;) // add a String
bag add(bag) // add itself! the fun never ends.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve elements from a bag, one has to specify the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := bag get(0, Int)
title := bag get(1, String)
// and so on
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;HashBag&lt;/h2&gt;

&lt;p&gt;A HashBag maps string values to any type of value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
hash := HashBag new()
hash put(&amp;quot;number&amp;quot;, 93)
hash put(&amp;quot;title&amp;quot;, &amp;quot;seaside&amp;quot;)
hash put(&amp;quot;ourselves&amp;quot;, hash)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve elements from a &lt;code&gt;HashBag&lt;/code&gt;, one has to specify both the string key
and the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
number := hash get(&amp;quot;number&amp;quot;, Int)
title := hash get(&amp;quot;title&amp;quot;, String)
// etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashBags are particularly useful to represent a tree-like document, that was originally
encoded as JSON or YAML, for example.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;getPath&lt;/code&gt; method allows one to retrieve an element of a tree of &lt;code&gt;HashBag&lt;/code&gt;s and &lt;code&gt;Bag&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say the original JSON looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!json
{&amp;quot;elements&amp;quot;: {
  &amp;quot;house&amp;quot;: {},
  &amp;quot;car&amp;quot;: {
    &amp;quot;wheels&amp;quot;: [
      { &amp;quot;diameter&amp;quot;: 2 }
    ]}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One could use the following code to retrieve the diameter of the first wheel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
data: HashBag = // read from JSON
diameter := data getPath(&amp;quot;elements/car/wheels#0/diameter&amp;quot;, Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;Stacks&lt;/h1&gt;

&lt;p&gt;Stacks are list-like data structures, except their primary purpose is to have elements
pushed on top of them and popped from the top, in a LIFO (last-in, first-out) fashion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
stack := Stack&amp;lt;Int&amp;gt; new()
stack push(1). push(2). push(3)

stack pop() == 3 // true
stack pop() == 2 // also true
stack pop() == 1 // left as an exercise to the reader
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Stick&lt;/h2&gt;

&lt;p&gt;The ill-named &lt;code&gt;Stick&lt;/code&gt; data structure can be thought of as a bag stack - e.g. a Stack
that can contain any type of element.&lt;/p&gt;

&lt;p&gt;Example usage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
stick := Stick new(Float size + Object size)
stick push(1.23)
stick push(&amp;quot;Hi!&amp;quot;)

stick pop(String) == &amp;quot;Hi!&amp;quot; // true
stick pop(Float) == 1.23 // truthful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Stick&lt;/code&gt; is quite low-level - it doesn&amp;rsquo;t resize automatically, it does no
bounds checking, no type checking at all. To be used when you absolutely,
positively need to squeeze bytes together as close as possible and don&amp;rsquo;t care
about safety at all.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>text</title>
      <link>http://oocmanual.cogneco.com/sdk/text</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/sdk/text</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;The text package&lt;/h1&gt;

&lt;p&gt;This package contains various helper classes to work with text
and JSON.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Escape sequences&lt;/h1&gt;

&lt;p&gt;The module &lt;code&gt;text/EscapeSequence&lt;/code&gt; contains a class &lt;code&gt;EscapeSequence&lt;/code&gt; which defines
some methods to work with backslash escape sequences. In the real world, you probably
just need the two following methods:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;escape&lt;/code&gt; takes a string and converts all special characters to escape sequences.
In this context, special characters are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;non-printable characters&lt;/li&gt;
&lt;li&gt;single and double quotes&lt;/li&gt;
&lt;li&gt;backslashes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
escaped := EscapeSequence escape(&amp;quot;This is\na &#39;String&#39;&amp;quot;)
// now, `escaped` looks like this:
escaped == &amp;quot;This is \\n a \\&#39;String\\&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that is only one half of the truth: You can additionally pass a
string of all characters that should not be escaped as the
second argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
escaped := EscapeSequence escape(&amp;quot;This is\na &#39;String&#39;&amp;quot;, &amp;quot;&#39;\n&amp;quot;)
// The method did not escape anything now.
escaped == &amp;quot;This is\na &#39;String&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;unescape&lt;/code&gt; is useful if you have a string containing escape sequences
and you need a string with these sequences converted to their real character
counterparts. This method supports one-character escape sequences like
&amp;ldquo;\n&amp;rdquo;, &amp;ldquo;\r&amp;rdquo; or &amp;ldquo;\t&amp;rdquo;, but also hexadecimal sequences like &amp;ldquo;\x34&amp;rdquo;.
Usage is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
&amp;quot;\\x27\\163up\\t\\x62ro\\n\\x3f&amp;quot; println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which will print&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bash
&#39;sup    bro
?
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;StringTokenizer&lt;/h1&gt;

&lt;p&gt;Sometimes, one needs to split a string at a special character and turn
it into an array. In ooc, the &lt;code&gt;text/StringTokenizer&lt;/code&gt; module adds
every desirable variation of the good old &lt;code&gt;split&lt;/code&gt; method to &lt;code&gt;Buffer&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;,
each returning an &lt;code&gt;ArrayList&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/StringTokenizer
import structs/ArrayList

// split at a specific character
&amp;quot;A|simple and stupid|example&amp;quot; split(&#39;|&#39;)
// This creates an ArrayList:
//  [&amp;quot;A&amp;quot;, &amp;quot;simple and stupid&amp;quot;, &amp;quot;example&amp;quot;]

// split until a specific number of tokens is reached.
// This will produce an ArrayList like
//    [&amp;quot;A&amp;quot;, &amp;quot;simple and stupid|example&amp;quot;]
&amp;quot;A|simple and stupid|example&amp;quot; split(&#39;|&#39;, 2)

// There is also a function to split at delimiters longer
// than one char:
&amp;quot;:-)A case :-)of intimidating:-)smiley abuse :-)&amp;quot; split(&amp;quot;:-&amp;quot;)
// ... produces
//  [&amp;quot;&amp;quot;, &amp;quot;A case &amp;quot;, &amp;quot;of intimidating&amp;quot;, &amp;quot;smiley abuse &amp;quot;, &amp;quot;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;StringTemplate&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;io/StringTemplate&lt;/code&gt; module adds a lightweight &lt;code&gt;formatTemplate&lt;/code&gt; string interpolation
function to strings, which can be used in cases where &lt;code&gt;format&lt;/code&gt; is not enough. This function
uses a hashmap to access items by value:&lt;/p&gt;

&lt;p&gt;{{=&amp;lt;% %&amp;gt;=}}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/StringTemplate
import structs/HashMap

values := HashMap&amp;lt;String, String&amp;gt; new()
values put(&amp;quot;day&amp;quot;, &amp;quot;Saturday&amp;quot;) \
      .put(&amp;quot;weather&amp;quot;, &amp;quot;cloudy&amp;quot;)

&amp;quot;Hi! Today&#39;s {{day}}, and it is a pretty {{  weather   }} {{ day }}!&amp;quot; formatTemplate(values) println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lt;%={{ }}=%&amp;gt;&lt;/p&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi! Today&#39;s Saturday, and it is a pretty cloudy Saturday!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, you can access the values by their keys, order isn&amp;rsquo;t important
and you can interpolate one value multiple times.&lt;br /&gt;
However, this is still pretty basic, since it does not support filters or control
structures, but this is often enough.&lt;/p&gt;

&lt;p&gt;In case a key is referenced that does not exist in the hashmap, it will be
replaced by an empty string.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Shell-like Lexer&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;text/Shlex&lt;/code&gt; module implements a basic lexer for strings containing
quoted strings and backslash escape sequences. Basically, it splits an input
string into an Array, using whitespace characters as delimiters. Single and double
quotes can be used to include whitespace in the string items.&lt;/p&gt;

&lt;p&gt;The public API can be accessed like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/Shlex
import structs/ArrayList
Shlex split(&amp;quot;&#39;This is a \\&#39;quoted\\&#39; string&#39;     and I \&amp;quot;like \\x69\\x74.\&amp;quot;&amp;quot;)
// This produces the following ArrayList:
// [&amp;quot;This is a &#39;quoted&#39; string&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;like it.&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can be useful to parse command-line arguments. However, be careful, since
this module was not designed with security in mind.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Regular Expressions&lt;/h1&gt;

&lt;p&gt;The SDK provides a simple cover for the &lt;a href=&#34;http://www.pcre.org/&#34;&gt;Perl Compatible Regular Expressions&lt;/a&gt;
library. Its use is pretty straightforward. First, you need to compile a regular
expression pattern, passing some options as a bitmask if you want to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/Regexp

pattern := Regexp compile(&amp;quot;on (?P&amp;lt;year&amp;gt;[0-9]{4})-?P&amp;lt;month&amp;gt;[0-9]{1,2})-(?P&amp;lt;day&amp;gt;[0-9]{1,2})&amp;quot;, RegexOptions CASELESS)
pattern matches(&amp;quot;foo&amp;quot;) // this will return null, since the pattern could not be matched

someDate := pattern matches(&amp;quot;On 2013-08-07&amp;quot;)
// `someDate` is now a `Match` object. You can access groups by index or by name:
someDate group(1)
someDate group(&amp;quot;year&amp;quot;)
// ... both return &amp;quot;2013&amp;quot;.
// Group zero is the whole matched string:
someDate group(0) // is &amp;quot;On 2013-08-07&amp;quot;

// You can also iterate over the matches. This will include
// group 0 (the whole string), though.
for(group in someDate) {
    // `group` is now a String.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information about the Perl regular expression syntax, take a look
at the &lt;a href=&#34;http://perldoc.perl.org/perlre.html&#34;&gt;Perl documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;JSON&lt;/h1&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Basic reading and writing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;text/json/&lt;/code&gt; package contains a JSON parser and generator, written in ooc
without external dependencies, which is able to deal with basic JSON. However,
if you care about speed or compliance (especially when dealing with numbers),
you should check out &lt;a href=&#34;https://github.com/nddrylliog/ooc-yaml&#34;&gt;ooc-yaml&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The JSON classes operate on nested &lt;a href=&#34;/docs/sdk/structs/#bag-variants&#34;&gt;HashBags and Bags&lt;/a&gt;,
so if you parse JSON, you get some (Hash)Bags, and if you want to generate JSON, you need
to pass the data as (Hash)Bags.&lt;/p&gt;

&lt;p&gt;To parse or generate JSON, you can just use the convenience &lt;code&gt;text/json&lt;/code&gt; module.
Every function exists in two flavours: Normally, you need to pass the class
of your expected base value. So, for example, if you want to parse JSON like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!json
[&amp;quot;Hi&amp;quot;, &amp;quot;World&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to pass &lt;code&gt;Bag&lt;/code&gt; as the base value class. However, since most of the time
you will parse JSON objects that will represented by a &lt;code&gt;HashBag&lt;/code&gt;, &lt;code&gt;HashBag&lt;/code&gt; is
used by default if you do not pass a class explicitly.&lt;/p&gt;

&lt;p&gt;Here are some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
import text/json
import structs/HashBag

// if you have a `Reader` (to read directly from a file, for example):
import io/FileReader
myObject := JSON parse(FileReader new(&amp;quot;package.json&amp;quot;))

// ... and if your base value is not a JSON object:
import structs/Bag
myArray := JSON parse(FileReader new(&amp;quot;myarray.json&amp;quot;), Bag)

// reading directly from strings is also supported:
JSON parse(&amp;quot;{\&amp;quot;hello\&amp;quot;: \&amp;quot;world\&amp;quot;}&amp;quot;)
JSON parse(&amp;quot;\&amp;quot;just a string\&amp;quot;&amp;quot;, String)

// and to generate JSON, there is:
myBag := HashBag new()
myBag put(&amp;quot;integer&amp;quot;, 1234) \
     .put(&amp;quot;string&amp;quot;, &amp;quot;Yes&amp;quot;)

import io/FileWriter
JSON generate(FileWriter new(&amp;quot;output.json&amp;quot;), myBag)

myJSONString := JSON generateString(myBag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When dealing with the &lt;code&gt;HashBag&lt;/code&gt; class, you should take a look at its
&lt;a href=&#34;/docs/sdk/structs/#hashbag&#34;&gt;getPath&lt;/a&gt; function, which will save you
a lot of typing.&lt;/p&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;A JSON generation DSL&lt;/h2&gt;

&lt;p&gt;If you find yourself generating a lot of JSON, you might find
the &lt;code&gt;HashBag&lt;/code&gt;/&lt;code&gt;Bag&lt;/code&gt; objects create a lot of syntactic noise. For this
reason, the SDK contains another convenience module implementing
a small DSL for JSON generation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
// Let&#39;s import the module into a namespace, since `make`
// is a bit ambiguous.
import text/json/DSL into JSON

data := JSON make(|j|
    j object(
        &amp;quot;some-key&amp;quot;,
            &amp;quot;some-value&amp;quot;,
        &amp;quot;here comes a list&amp;quot;,
            j array(
                1, 2, &amp;quot;three&amp;quot;, 4
            ),
        &amp;quot;and a nested object&amp;quot;,
            j object(
                &amp;quot;true&amp;quot;, true
            )
    )
)
data println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt; creates a helper object with &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;array&lt;/code&gt; functions and passes
it to the function you provide; using a closure is the most convenient way here.
You can use &lt;code&gt;object&lt;/code&gt; to create JSON objects, passing as many key-value pairs
as you want, and &lt;code&gt;array&lt;/code&gt; for JSON arrays.&lt;/p&gt;

&lt;p&gt;When it&amp;rsquo;s done, it returns the JSON data as a string.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Covers</title>
      <link>http://oocmanual.cogneco.com/language/covers</link>
      <pubDate>Tue, 01 Jan 2008 00:00:00 UTC</pubDate>
      
      <guid>http://oocmanual.cogneco.com/language/covers</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Covers&lt;/h1&gt;

&lt;p&gt;One selling point of ooc is that it makes it easy to use C libraries which
design is object-oriented. Covers are one way to do that.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Struct-like covers&lt;/h1&gt;

&lt;p&gt;Covers are a by-value, lighter, lower-level alternative to classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Vec2: cover {
  x, y: Float

  norm: func -&amp;gt; Float {
    sqrt(x * x + y * y)
  }
}

v: Vec2
v x = 1.5
v y = 4
&amp;quot;Norm = %.2f&amp;quot; printfln(v norm())
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Covers from&lt;/h1&gt;

&lt;p&gt;Covers from are based on an external, C type, and provide a way to access
members of the external type (if it&amp;rsquo;s a struct), and to call methods on it -
either existing, external functions, or adding whole new methods.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Int: cover from int
UInt8: cover from uint8_t
LLong: cover from long long
UInt: cover from unsigned int
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Members&lt;/h1&gt;

&lt;p&gt;Members can be declared extern, like functions - which means they are defined
somewhere else and need to be accessed from ooc code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
CpFloat: cover from cpFloat

CpVect: cover from cpVect {
  x, y: extern CpFloat
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Members can be aliased by using the &lt;code&gt;extern(original_name)&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
Rectangle: cover from bar_rectangle_t {
  width: extern(Width)
  height: extern(Height)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Methods&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;extern&lt;/code&gt; function can be used to describe cover methods as well. Aliasing is
often good practice, as it allows to get rid of the unnecessary prefixes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
FooContext: cover from foo_context_t {
  // extern constructor
  new: static extern(foo_context_new) func (CString, Int) -&amp;gt; This

  // extern method
  doSomething: extern(foo_context_do_something) -&amp;gt; CString

  // additional method
  doSomethingTwice: func {
    doSomething()
    doSomething()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so, a properly covered C struct with methods can be used as if it was an object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ooc
context := FooContext new()
context doSomething()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>